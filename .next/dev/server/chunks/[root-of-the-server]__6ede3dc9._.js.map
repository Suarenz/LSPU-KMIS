{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\n// Create Prisma client instance\r\nconst createPrismaClient = () => {\r\n  return new PrismaClient({\r\n    log: ['query', 'info', 'warn', 'error'], // Enable detailed logging\r\n  })\r\n}\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined\r\n}\r\n\r\n// Use the global instance in development to prevent exceeding connection limits\r\nconst client = globalThis.prisma || createPrismaClient()\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = client\r\n\r\nexport default client"],"names":[],"mappings":";;;;AAAA;;AAEA,gCAAgC;AAChC,MAAM,qBAAqB;IACzB,OAAO,IAAI,6IAAY,CAAC;QACtB,KAAK;YAAC;YAAS;YAAQ;YAAQ;SAAQ;IACzC;AACF;AAOA,gFAAgF;AAChF,MAAM,SAAS,WAAW,MAAM,IAAI;AACpC,wCAA2C,WAAW,MAAM,GAAG;uCAEhD"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/colivara-error-handler.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport ColivaraService from './colivara-service';\r\nimport { Document } from '@/lib/api/types';\r\n\r\nexport enum ColivaraErrorType {\r\n  API_UNAVAILABLE = 'API_UNAVAILABLE',\r\n  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',\r\n  AUTHENTICATION_FAILED = 'AUTHENTICATION_FAILED',\r\n  PROCESSING_FAILED = 'PROCESSING_FAILED',\r\n  TIMEOUT = 'TIMEOUT',\r\n  INVALID_RESPONSE = 'INVALID_RESPONSE',\r\n  NETWORK_ERROR = 'NETWORK_ERROR',\r\n  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',\r\n}\r\n\r\nexport class ColivaraError extends Error {\r\n  constructor(\r\n    public type: ColivaraErrorType,\r\n    message: string,\r\n    public originalError?: any,\r\n    public status?: number\r\n  ) {\r\n    super(message);\r\n    this.name = 'ColivaraError';\r\n  }\r\n}\r\n\r\nexport interface ErrorHandlingOptions {\r\n  maxRetries?: number;\r\n  retryDelay?: number;\r\n  fallbackToTraditional?: boolean;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface ProcessingResult {\r\n  success: boolean;\r\n  error?: ColivaraError;\r\n  fallbackUsed?: boolean;\r\n  data?: any;\r\n}\r\n\r\nexport class ColivaraErrorHandler {\r\n  private static instance: ColivaraErrorHandler;\r\n  private circuitBreakerOpen = false;\r\n  private lastFailureTime: Date | null = null;\r\n  private failureCount = 0;\r\n  private maxFailures = 5;\r\n  private resetTimeout = 300000; // 5 minutes\r\n  \r\n  private constructor() {}\r\n\r\n  public static getInstance(): ColivaraErrorHandler {\r\n    if (!ColivaraErrorHandler.instance) {\r\n      ColivaraErrorHandler.instance = new ColivaraErrorHandler();\r\n    }\r\n    return ColivaraErrorHandler.instance;\r\n  }\r\n\r\n  async handleColivaraOperation<T>(\r\n    operation: () => Promise<T>,\r\n    options: ErrorHandlingOptions = {}\r\n  ): Promise<{ result: T | null; error?: ColivaraError; fallbackUsed: boolean }> {\r\n    const { \r\n      maxRetries = 3, \r\n      retryDelay = 1000, \r\n      fallbackToTraditional = true,\r\n      timeout = 30000 \r\n    } = options;\r\n\r\n    // Check circuit breaker status\r\n    if (this.isCircuitBreakerOpen()) {\r\n      if (fallbackToTraditional) {\r\n        console.warn('Circuit breaker is open, using fallback to traditional processing');\r\n        return { result: null, error: new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'Service temporarily unavailable'), fallbackUsed: true };\r\n      } else {\r\n        throw new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'Service temporarily unavailable due to circuit breaker');\r\n      }\r\n    }\r\n\r\n    let lastError: ColivaraError | undefined;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Add timeout to the operation\r\n        const result = await this.withTimeout(operation(), timeout);\r\n        this.resetCircuitBreaker(); // Reset on success\r\n        return { result, error: undefined, fallbackUsed: false };\r\n      } catch (error) {\r\n        lastError = this.convertErrorToColivaraError(error);\r\n\r\n        // Log the error\r\n        console.error(`Colivara operation failed on attempt ${attempt + 1}:`, lastError);\r\n\r\n        // Check if this is a permanent error that shouldn't be retried\r\n        if (lastError && this.isPermanentError(lastError)) {\r\n          break;\r\n        }\r\n\r\n        // Update circuit breaker on failure\r\n        this.updateCircuitBreaker();\r\n\r\n        // If this isn't the last attempt, wait before retrying\r\n        if (attempt < maxRetries) {\r\n          await this.delay(retryDelay * Math.pow(2, attempt)); // Exponential backoff\r\n        }\r\n      }\r\n    }\r\n\r\n    // If we've exhausted retries and fallback is enabled\r\n    if (fallbackToTraditional) {\r\n      console.warn('Using fallback after Colivara operation failed:', lastError?.message);\r\n      return { result: null, error: lastError, fallbackUsed: true };\r\n    }\r\n\r\n    // If fallback is not enabled, throw the last error\r\n    throw lastError;\r\n  }\r\n\r\n  private async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<T>((_, reject) => {\r\n        setTimeout(() => {\r\n          reject(new ColivaraError(ColivaraErrorType.TIMEOUT, `Operation timed out after ${timeoutMs}ms`));\r\n        }, timeoutMs);\r\n      })\r\n    ]);\r\n  }\r\n\r\n  public convertErrorToColivaraError(error: any): ColivaraError {\r\n    if (error instanceof ColivaraError) {\r\n      return error;\r\n    }\r\n\r\n    // Check for specific error types\r\n    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\r\n      return new ColivaraError(ColivaraErrorType.NETWORK_ERROR, 'Network connection failed', error);\r\n    }\r\n\r\n    if (error.status === 429) {\r\n      return new ColivaraError(ColivaraErrorType.RATE_LIMIT_EXCEEDED, 'Rate limit exceeded', error, error.status);\r\n    }\r\n\r\n    if (error.status === 401 || error.status === 403) {\r\n      return new ColivaraError(ColivaraErrorType.AUTHENTICATION_FAILED, 'Authentication failed', error, error.status);\r\n    }\r\n\r\n    if (error.status === 404) {\r\n      return new ColivaraError(ColivaraErrorType.DOCUMENT_NOT_FOUND, 'Document not found in Colivara collections', error, error.status);\r\n    }\r\n\r\n    if (error.status >= 500) {\r\n      return new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'API temporarily unavailable', error, error.status);\r\n    }\r\n\r\n    if (error.name === 'TimeoutError') {\r\n      return new ColivaraError(ColivaraErrorType.TIMEOUT, error.message, error);\r\n    }\r\n\r\n    // Default to processing failed\r\n    return new ColivaraError(ColivaraErrorType.PROCESSING_FAILED, error.message || 'Processing failed', error);\r\n  }\r\n\r\n  private isPermanentError(error: ColivaraError): boolean {\r\n    // These errors should not be retried\r\n    return [\r\n      ColivaraErrorType.AUTHENTICATION_FAILED,\r\n      ColivaraErrorType.INVALID_RESPONSE,\r\n      ColivaraErrorType.DOCUMENT_NOT_FOUND\r\n    ].includes(error.type);\r\n  }\r\n\r\n  private isCircuitBreakerOpen(): boolean {\r\n    if (!this.circuitBreakerOpen) {\r\n      return false;\r\n    }\r\n\r\n    // Check if enough time has passed to close the circuit\r\n    if (this.lastFailureTime && \r\n        new Date().getTime() - this.lastFailureTime.getTime() > this.resetTimeout) {\r\n      this.circuitBreakerOpen = false;\r\n      this.failureCount = 0;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateCircuitBreaker(): void {\r\n    this.failureCount++;\r\n    this.lastFailureTime = new Date();\r\n    \r\n    if (this.failureCount >= this.maxFailures) {\r\n      this.circuitBreakerOpen = true;\r\n      console.warn('Circuit breaker opened due to too many failures');\r\n    }\r\n  }\r\n\r\n  private resetCircuitBreaker(): void {\r\n    this.circuitBreakerOpen = false;\r\n    this.failureCount = 0;\r\n    this.lastFailureTime = null;\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  // Method to check service health\r\n  async checkServiceHealth(service: ColivaraService): Promise<boolean> {\r\n    try {\r\n      return await service.validateApiKey();\r\n    } catch (error) {\r\n      console.error('Colivara service health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Method to handle graceful degradation\r\n  async handleGracefulDegradation<T>(\r\n    colivaraOperation: () => Promise<T>,\r\n    fallbackOperation: () => Promise<T>,\r\n    options: ErrorHandlingOptions = {}\r\n  ): Promise<{ result: T; degraded: boolean; error?: ColivaraError }> {\r\n    const { result, error, fallbackUsed } = await this.handleColivaraOperation(\r\n      colivaraOperation,\r\n      { ...options, fallbackToTraditional: true }\r\n    );\r\n\r\n    if (fallbackUsed && result === null) {\r\n      // Use fallback operation\r\n      try {\r\n        const fallbackResult = await fallbackOperation();\r\n        return { result: fallbackResult, degraded: true, error };\r\n      } catch (fallbackError) {\r\n        console.error('Fallback operation also failed:', fallbackError);\r\n        throw new ColivaraError(\r\n          ColivaraErrorType.PROCESSING_FAILED, \r\n          'Both primary and fallback operations failed',\r\n          fallbackError\r\n        );\r\n      }\r\n    }\r\n\r\n    if (result !== null) {\r\n      return { result, degraded: false };\r\n    }\r\n\r\n    throw new ColivaraError(ColivaraErrorType.PROCESSING_FAILED, 'Operation failed', error);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const colivaraErrorHandler = ColivaraErrorHandler.getInstance();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/colivara-service.ts"],"sourcesContent":["import { ColiVara } from 'colivara-ts';\r\nimport prisma from '@/lib/prisma';\r\nimport { Document } from '@/lib/api/types';\r\nimport { ColivaraDocument, ColivaraIndex } from '@/lib/types/colivara-types';\r\nimport { colivaraErrorHandler, ColivaraError as ColivaraServiceError, ColivaraErrorType } from './colivara-error-handler';\r\n\r\ninterface DocumentMetadata {\r\n  originalName: string;\r\n  size: number;\r\n  type: string;\r\n  extension: string;\r\n  uploadedAt: Date;\r\n lastModified: Date;\r\n  hash: string;\r\n}\r\n\r\ninterface ProcessingStatus {\r\n  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED';\r\n  progress?: number;\r\n  error?: string;\r\n  processedAt?: Date;\r\n  num_pages?: number;  // Add page count field\r\n}\r\n\r\ninterface SearchFilters {\r\n  unitId?: string;\r\n  category?: string;\r\n  dateRange?: { start: Date; end: Date };\r\n  fileType?: string[];\r\n}\r\n\r\ninterface SearchResults {\r\n  results: SearchResult[];\r\n  total: number;\r\n  query: string;\r\n processingTime: number;\r\n}\r\n\r\ninterface SearchResult {\r\n  documentId: string;\r\n  title: string;\r\n  content: string;\r\n  score: number;\r\n  pageNumbers: number[];\r\n  documentSection?: string;\r\n  confidenceScore?: number;\r\n  snippet: string;\r\n  document: Document;\r\n  visualContent?: string; // Base64 encoded visual content\r\n  extractedText?: string; // Extracted text content\r\n  screenshots?: string[]; // Array of screenshot base64 strings\r\n}\r\n\r\ninterface ColivaraConfig {\r\n  apiKey: string;\r\n  processingTimeout: number;\r\n  maxFileSize: number;\r\n  retryAttempts: number;\r\n  batchSize: number;\r\n  cacheEnabled: boolean;\r\n  cacheTtl: number;\r\n  defaultCollection: string;\r\n}\r\n\r\nclass ColivaraError extends Error {\r\n  constructor(message: string, public code?: string, public status?: number) {\r\n    super(message);\r\n    this.name = 'ColivaraError';\r\n }\r\n}\r\n\r\nclass ColivaraApiError extends ColivaraError {\r\n  constructor(message: string, public response?: any) {\r\n    super(message, 'API_ERROR', response?.status);\r\n    this.name = 'ColivaraApiError';\r\n  }\r\n}\r\n\r\nclass ColivaraProcessingError extends ColivaraError {\r\n  constructor(message: string, public documentId: string) {\r\n    super(message, 'PROCESSING_ERROR');\r\n    this.name = 'ColivaraProcessingError';\r\n  }\r\n}\r\n\r\nclass ColivaraService {\r\n  private client: ColiVara;\r\n  private config: ColivaraConfig;\r\n  private isInitialized: boolean;\r\n  private defaultCollection: string = 'lspu-kmis-documents';\r\n\r\n  constructor(config?: Partial<ColivaraConfig>) {\r\n    this.config = this.mergeConfig(config);\r\n    this.client = new ColiVara(this.config.apiKey);\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  private mergeConfig(userConfig?: Partial<ColivaraConfig>): ColivaraConfig {\r\n    return {\r\n      apiKey: process.env.COLIVARA_API_KEY || userConfig?.apiKey || '',\r\n      processingTimeout: userConfig?.processingTimeout || 300000, // 5 minutes default\r\n      maxFileSize: userConfig?.maxFileSize || 52428800, // 50MB default\r\n      retryAttempts: userConfig?.retryAttempts || 3,\r\n      batchSize: userConfig?.batchSize || 10,\r\n      cacheEnabled: userConfig?.cacheEnabled ?? true,\r\n      cacheTtl: userConfig?.cacheTtl || 3600000, // 1 hour default\r\n      defaultCollection: userConfig?.defaultCollection || 'lspu-kmis-documents',\r\n    };\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      // Validate API key by checking health\r\n      await this.validateApiKey();\r\n      \r\n      // Ensure the default collection exists\r\n      await this.ensureDefaultCollection();\r\n      \r\n      this.isInitialized = true;\r\n      console.log('Colivara service initialized successfully');\r\n    } catch (error) {\r\n      console.error('Failed to initialize Colivara service:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async validateApiKey(): Promise<boolean> {\r\n    try {\r\n      // Test connectivity to Colivara service using the health check\r\n      if (typeof this.client.checkHealth !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a checkHealth method');\r\n      }\r\n      await this.client.checkHealth();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('API key validation failed:', error);\r\n      throw colivaraErrorHandler.convertErrorToColivaraError(error);\r\n    }\r\n  }\r\n\r\n  private async ensureDefaultCollection(): Promise<void> {\r\n    try {\r\n      // Try to get the collection first\r\n      if (typeof this.client.getCollection !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getCollection method');\r\n      }\r\n      \r\n      try {\r\n        await this.client.getCollection({ collection_name: this.config.defaultCollection });\r\n        console.log(`Collection '${this.config.defaultCollection}' already exists`);\r\n      } catch (error) {\r\n        // Check if the error is because the method doesn't exist or collection doesn't exist\r\n        if (error instanceof TypeError || (error instanceof Error && error.message.includes('method'))) {\r\n          throw error; // Re-throw if it's a method not found error\r\n        }\r\n        \r\n        // If collection doesn't exist, create it\r\n        console.log(`Creating collection '${this.config.defaultCollection}'`);\r\n        \r\n        if (typeof this.client.createCollection !== 'function') {\r\n          throw new ColivaraApiError('Colivara client does not have a createCollection method');\r\n        }\r\n        \r\n        await this.client.createCollection({\r\n          name: this.config.defaultCollection,\r\n          metadata: {\r\n            description: 'Default collection for LSPU KMIS documents',\r\n            created_at: new Date().toISOString()\r\n          }\r\n        });\r\n        console.log(`Collection '${this.config.defaultCollection}' created successfully`);\r\n      }\r\n    } catch (error) {\r\n      console.error(`Failed to ensure default collection exists:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async uploadDocument(fileUrl: string, documentId: string, metadata: DocumentMetadata, base64Content?: string): Promise<string> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Update document status to PROCESSING using raw SQL since Prisma client hasn't been updated\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'PROCESSING', \"colivaraChecksum\" = ${metadata.hash}\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      // Check if the upsertDocument method exists\r\n      if (typeof this.client.upsertDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have an upsertDocument method');\r\n      }\r\n      \r\n      // Validate document metadata before upload\r\n      if (!documentId || typeof documentId !== 'string') {\r\n        throw new ColivaraApiError('Invalid document ID provided for upload');\r\n      }\r\n\r\n      // Validate document name\r\n      const documentName = `${documentId}_${metadata.originalName}`;\r\n      if (!documentName || documentName.length > 255) {\r\n        throw new ColivaraApiError('Document name is invalid or too long');\r\n      }\r\n\r\n      // Validate collection name\r\n      if (!this.config.defaultCollection || typeof this.config.defaultCollection !== 'string') {\r\n        throw new ColivaraApiError('Invalid collection name provided');\r\n      }\r\n\r\n      // Prepare upload parameters\r\n      const uploadParams: any = {\r\n        name: documentName,\r\n        collection_name: this.config.defaultCollection,\r\n        metadata: {\r\n          documentId,\r\n          title: metadata.originalName, // Ensure the title is stored in metadata for proper display\r\n          ...metadata\r\n        },\r\n        wait: false // Don't wait for processing to complete, we'll check status separately\r\n      };\r\n\r\n      // If base64 content is provided, use it instead of the URL\r\n      if (base64Content) {\r\n        console.log('Uploading document with base64 content:', {\r\n          name: documentName,\r\n          collection_name: this.config.defaultCollection,\r\n          metadata: {\r\n            documentId,\r\n            ...metadata\r\n          }\r\n        });\r\n        uploadParams.document_base64 = base64Content; // Use document_base64 instead of content for Colivara API\r\n      } else {\r\n        // If no base64 content provided, use the URL (fallback for backward compatibility)\r\n        if (!fileUrl || typeof fileUrl !== 'string') {\r\n          throw new ColivaraApiError('Invalid file URL provided for upload');\r\n        }\r\n        console.log('Uploading document with URL:', {\r\n          name: documentName,\r\n          collection_name: this.config.defaultCollection,\r\n          document_url: fileUrl,\r\n          metadata: {\r\n            documentId,\r\n            ...metadata\r\n          }\r\n        });\r\n        uploadParams.document_url = fileUrl;\r\n      }\r\n\r\n      const response = await this.client.upsertDocument(uploadParams);\r\n\r\n      console.log('Upload response received:', response);\r\n\r\n      // Extract document ID from response - adjust based on actual API response structure\r\n      // Ensure we return a string value, not the entire response object\r\n      const responseObj = response as any;\r\n      const documentIdFromResponse = responseObj.id || responseObj.documentId || responseObj.name ||\r\n                                    (typeof response === 'string' ? response : documentName);\r\n\r\n      if (!documentIdFromResponse) {\r\n        throw new ColivaraApiError('Invalid response from upsertDocument - no document ID returned');\r\n      }\r\n\r\n      // Validate that the document ID is a proper string\r\n      if (typeof documentIdFromResponse !== 'string' || documentIdFromResponse === '[object Object]') {\r\n        throw new ColivaraApiError(`Invalid document ID returned from API: ${typeof documentIdFromResponse}`);\r\n      }\r\n\r\n      // Store the Colivara document ID using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraDocumentId\" = ${documentIdFromResponse}\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      return documentIdFromResponse;\r\n    } catch (error) {\r\n      console.error(`Failed to upload document ${documentId} to Colivara:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED', \"colivaraMetadata\" = ${JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' })}::jsonb\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      if (error instanceof ColivaraError) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ColivaraProcessingError(\r\n        `Failed to upload document to Colivara: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        documentId\r\n      );\r\n    }\r\n  }\r\n\r\n  async checkProcessingStatus(colivaraDocumentId: string): Promise<ProcessingStatus> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]' || !colivaraDocumentId) {\r\n        throw new ColivaraApiError('Invalid document ID provided to checkProcessingStatus');\r\n      }\r\n\r\n      console.log(`Checking processing status for document ID: ${colivaraDocumentId}`);\r\n\r\n      if (typeof this.client.getDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getDocument method');\r\n      }\r\n      \r\n      const response = await this.client.getDocument({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection  // Include collection name in the request\r\n      });\r\n\r\n      console.log(`Processing status response for ${colivaraDocumentId}:`, response);\r\n\r\n      // Handle the response based on the actual ColiVara API response structure\r\n      // Since we don't have exact type information, we'll access fields safely\r\n      return {\r\n        status: (response as any).status as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' || 'PENDING',\r\n        progress: (response as any).progress || 0,\r\n        error: (response as any).error,\r\n        processedAt: (response as any).processedAt ? new Date((response as any).processedAt) : undefined,\r\n        num_pages: (response as any).num_pages || (response as any).pages || (response as any).page_count || 0,  // Add page count information\r\n      };\r\n    } catch (error) {\r\n      console.error(`Failed to check processing status for ${colivaraDocumentId}:`, error);\r\n      \r\n      // Convert error to ColivaraError to check if it's a 404\r\n      const colivaraError = colivaraErrorHandler.convertErrorToColivaraError(error);\r\n      \r\n      // If it's a document not found error, return appropriate status\r\n      if (colivaraError.type === ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n        console.warn(`Document ${colivaraDocumentId} not found in Colivara collections`);\r\n        return {\r\n          status: 'FAILED',\r\n          error: `Document not found in Colivara: ${colivaraError.message}`,\r\n          processedAt: new Date(),\r\n        };\r\n      }\r\n      \r\n      // For other errors, log them and re-throw\r\n      console.error(`Error checking processing status for ${colivaraDocumentId}:`, colivaraError);\r\n      throw colivaraError;\r\n    }\r\n  }\r\n\r\n  async waitForProcessing(colivaraDocumentId: string, maxWaitTime: number = 3000): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    const checkInterval = 5000; // Check every 5 seconds\r\n\r\n    // Add a 2-second delay before starting the status check loop\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n    console.log(`Waiting 2 seconds before starting status check for document: ${colivaraDocumentId}`);\r\n\r\n    while (Date.now() - startTime < maxWaitTime) {\r\n      try {\r\n        const status = await this.checkProcessingStatus(colivaraDocumentId);\r\n        \r\n        if (status.status === 'COMPLETED' || (status.num_pages !== undefined && status.num_pages > 0)) {\r\n          return true;\r\n        } else if (status.status === 'FAILED') {\r\n          console.error(`Document processing failed for ${colivaraDocumentId}: ${status.error}`);\r\n          return false;\r\n        }\r\n        \r\n        // Wait before next check\r\n        await new Promise(resolve => setTimeout(resolve, checkInterval));\r\n      } catch (error) {\r\n        console.error(`Error checking processing status for ${colivaraDocumentId}:`, error);\r\n        // If the error is due to document not being found, return false immediately\r\n        if (error instanceof ColivaraServiceError && (error as any).type === ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n          console.error(`Document ${colivaraDocumentId} not found in Colivara, failing immediately`);\r\n          return false;\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    console.warn(`Processing timeout for ${colivaraDocumentId} after ${maxWaitTime}ms`);\r\n    return false;\r\n  }\r\n\r\n  async performSemanticSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      const startTime = Date.now();\r\n      \r\n      let response;\r\n      \r\n      // Check if the search method exists on the client\r\n      if (typeof this.client.search !== 'function') {\r\n        console.warn('Colivara client does not have a search method, falling back to traditional search');\r\n        return {\r\n          results: [],\r\n          total: 0,\r\n          query,\r\n          processingTime: 0,\r\n        };\r\n      }\r\n      \r\n      try {\r\n        response = await this.client.search({\r\n          query,\r\n          collection_name: this.config.defaultCollection,\r\n          top_k: 10 // Return top 10 results\r\n          // Note: Filters are not directly supported in the search call,\r\n          // they would need to be implemented using metadata filtering if available in the actual API\r\n        });\r\n      } catch (error) {\r\n        console.error('Colivara search API call failed:', error);\r\n        // Return empty results but don't throw, let the fallback mechanism handle it\r\n        return {\r\n          results: [],\r\n          total: 0,\r\n          query,\r\n          processingTime: 0,\r\n        };\r\n      }\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      // Format results to match our expected structure\r\n      const results: SearchResult[] = response.results.map((item: any) => {\r\n        // Extract the original document ID from multiple possible locations\r\n        let originalDocumentId = item.metadata?.documentId ||\r\n                                (item.document && item.document.metadata?.documentId) ||\r\n                                item.metadata?.id ||\r\n                                item.id;\r\n                                \r\n        // If still not found, try to extract from document_metadata in the document object\r\n        if (!originalDocumentId && item.document && item.document_metadata) {\r\n          originalDocumentId = item.document.document_metadata.documentId;\r\n        }\r\n        \r\n        // If still not found, try to extract directly from document_metadata property\r\n        if (!originalDocumentId && item.document_metadata) {\r\n          originalDocumentId = item.document_metadata.documentId;\r\n        }\r\n        \r\n        // If still not found, try to extract from the document name (which contains the document ID)\r\n        if (!originalDocumentId && item.document?.document_name) {\r\n          // Extract document ID from document_name which is in format \"docId_originalName.ext\"\r\n          const nameParts = item.document.document_name.split('_');\r\n          if (nameParts.length >= 1) {\r\n            originalDocumentId = nameParts[0];\r\n          }\r\n        }\r\n                                  \r\n        // Extract score - prioritize similarity/prob over confidence since those are more likely to be the actual relevance scores\r\n        const score = item.score || item.similarity || item.prob || item.confidence || 0;\r\n                                  \r\n        return {\r\n          documentId: originalDocumentId,\r\n          title: item.metadata?.title || item.title || item.metadata?.originalName || item.name || 'Untitled Document',\r\n          content: item.content || item.text || item.metadata?.content || '',\r\n          score: score,\r\n          pageNumbers: item.page_numbers || item.pageNumbers || item.pages || [item.document?.page_number] || [],\r\n          documentSection: item.section || item.documentSection || item.metadata?.section || '',\r\n          confidenceScore: score, // Use the same score value for consistency\r\n          snippet: item.snippet || item.content?.substring(0, 200) + '...' || item.text?.substring(0, 200) + '...' || item.metadata?.content?.substring(0, 200) + '...' || '',\r\n          document: item.document || item.metadata?.document || item || {} as Document,\r\n          visualContent: item.visualContent || item.image || item.image_data || undefined,\r\n          extractedText: item.extractedText || item.text || item.content || undefined,\r\n        };\r\n      });\r\n\r\n      return {\r\n        results,\r\n        total: results.length,\r\n        query,\r\n        processingTime,\r\n      };\r\n    } catch (error) {\r\n      console.error('Semantic search failed:', error);\r\n      // Return an empty result set in case of error\r\n      return {\r\n        results: [],\r\n        total: 0,\r\n        query,\r\n        processingTime: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  async performHybridSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Perform semantic search with Colivara\r\n      const semanticResults = await this.performSemanticSearch(query, filters, userId);\r\n\r\n      // Perform traditional database search\r\n      const traditionalResults = await this.performTraditionalSearch(query, filters, userId);\r\n\r\n      // Combine and rank results\r\n      const combinedResults = this.combineSearchResults(semanticResults, traditionalResults);\r\n\r\n      return {\r\n        results: combinedResults,\r\n        total: combinedResults.length,\r\n        query,\r\n        processingTime: semanticResults.processingTime + (traditionalResults as any).processingTime || 0,\r\n      };\r\n    } catch (error) {\r\n      console.error('Hybrid search failed:', error);\r\n      // Fallback to traditional search only\r\n      return await this.performTraditionalSearch(query, filters, userId);\r\n    }\r\n  }\r\n\r\n  private async performTraditionalSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    // This would use the existing search functionality from enhanced-document-service\r\n    // For now, we'll implement a basic version\r\n    const documents = await prisma.document.findMany({\r\n      where: {\r\n        AND: [\r\n          {\r\n            OR: [\r\n              { title: { contains: query, mode: 'insensitive' } },\r\n              { description: { contains: query, mode: 'insensitive' } },\r\n              { tags: { path: ['$[*]'], string_contains: query } as any }, // Search for query string within the tags array using JSON path as array\r\n            ]\r\n          },\r\n          filters?.unitId ? { unitId: filters.unitId } : {},\r\n          filters?.category ? { category: filters.category } : {},\r\n        ],\r\n        status: 'ACTIVE',\r\n      },\r\n      include: {\r\n        uploadedByUser: true,\r\n        documentUnit: true,\r\n      },\r\n      take: 50, // Limit to 50 results\r\n    });\r\n\r\n    const results: SearchResult[] = documents.map((doc: any) => ({\r\n      documentId: doc.id,\r\n      title: doc.title,\r\n      content: doc.description,\r\n      score: 0.5, // Default score for traditional search\r\n      pageNumbers: [],\r\n      documentSection: 'description',\r\n      confidenceScore: 0.5,\r\n      snippet: doc.description.substring(0, 200) + '...',\r\n      document: {\r\n        ...doc,\r\n        tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n        uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n        unit: doc.documentUnit ? {\r\n          id: doc.documentUnit.id,\r\n          name: doc.documentUnit.name,\r\n          code: doc.documentUnit.code,\r\n          description: doc.documentUnit.description || undefined,\r\n          createdAt: doc.documentUnit.createdAt,\r\n          updatedAt: doc.documentUnit.updatedAt,\r\n        } : undefined,\r\n        uploadedAt: new Date(doc.uploadedAt),\r\n        createdAt: new Date(doc.createdAt),\r\n        updatedAt: new Date(doc.updatedAt),\r\n        // Colivara fields (for consistency)\r\n        colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n      } as Document,\r\n    }));\r\n\r\n    return {\r\n      results,\r\n      total: results.length,\r\n      query,\r\n      processingTime: 0, // We don't track this for traditional search here\r\n    };\r\n  }\r\n\r\n  private combineSearchResults(semanticResults: SearchResults, traditionalResults: SearchResults): SearchResult[] {\r\n   // This is a simplified combination - in a real implementation, we would have more sophisticated ranking\r\n   const combined = [...semanticResults.results];\r\n   \r\n   // Add traditional results that aren't already in semantic results\r\n   for (const tradResult of traditionalResults.results) {\r\n     // Check if document already exists in combined results using documentId field\r\n     const exists = combined.some(semResult => {\r\n       const semDocId = semResult.documentId;\r\n       const tradDocId = tradResult.documentId;\r\n       return semDocId && tradDocId && semDocId === tradDocId;\r\n     });\r\n     if (!exists) {\r\n       combined.push(tradResult);\r\n     }\r\n   }\r\n   \r\n   // Sort by score (or some combination of scores)\r\n   return combined.sort((a, b) => (b.score || 0) - (a.score || 0));\r\n }\r\n\r\n  async indexDocument(documentId: string, base64Content?: string): Promise<boolean> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Get document from database\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!document) {\r\n        throw new ColivaraProcessingError(`Document not found: ${documentId}`, documentId);\r\n      }\r\n\r\n      // Update document status to PROCESSING using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'PROCESSING'\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      // Upload document to Colivara for processing\r\n      const colivaraDocId = await this.uploadDocument(\r\n        document.fileUrl,\r\n        documentId,\r\n        {\r\n          originalName: document.fileName,\r\n          size: document.fileSize,\r\n          type: document.fileType,\r\n          extension: document.fileName.split('.').pop() || '',\r\n          uploadedAt: document.uploadedAt,\r\n          lastModified: document.updatedAt,\r\n          hash: (document as any).colivaraChecksum || ''\r\n        },\r\n        base64Content // Pass the base64 content if provided\r\n      );\r\n\r\n      console.log('Upload result from upsertDocument:', { colivaraDocId, documentId });\r\n\r\n      // Start background processing without blocking\r\n      this.waitForProcessingAndComplete(documentId, colivaraDocId);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Failed to index document ${documentId}:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED'\r\n        WHERE id = ${documentId}\r\n      `;\r\n      \r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async waitForProcessingAndComplete(documentId: string, colivaraDocId: string): Promise<void> {\r\n    try {\r\n      // Wait for processing to complete\r\n      const completed = await this.waitForProcessing(colivaraDocId, this.config.processingTimeout);\r\n\r\n      if (completed) {\r\n        // Update document with Colivara results using raw SQL\r\n        await prisma.$executeRaw`\r\n          UPDATE documents\r\n          SET \"colivaraDocumentId\" = ${colivaraDocId},\r\n              \"colivaraProcessingStatus\" = 'COMPLETED',\r\n              \"colivaraProcessedAt\" = ${new Date()}::timestamp\r\n          WHERE id = ${documentId}\r\n        `;\r\n\r\n        // Extract and store the processed content in ColivaraIndex\r\n        await this.storeProcessedContent(documentId, colivaraDocId);\r\n      } else {\r\n        // Handle timeout or failure\r\n        await prisma.$executeRaw`\r\n          UPDATE documents\r\n          SET \"colivaraProcessingStatus\" = 'FAILED'\r\n          WHERE id = ${documentId}\r\n        `;\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error completing processing for document ${documentId}:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED'\r\n        WHERE id = ${documentId}\r\n      `;\r\n    }\r\n  }\r\n\r\n  private async storeProcessedContent(documentId: string, colivaraDocId: string): Promise<void> {\r\n    try {\r\n      // Get the processed content from Colivara\r\n      // Note: The official API might not have a direct content endpoint\r\n      // We'll need to implement this based on what the actual API provides\r\n      console.log(`Storing processed content for document ${documentId} with Colivara ID ${colivaraDocId}`);\r\n      \r\n      // For now, we'll just log this operation\r\n      // The actual implementation would depend on what data the Colivara API returns\r\n      // after document processing is complete\r\n    } catch (error) {\r\n      console.error(`Failed to store processed content for document ${documentId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n   async updateIndex(documentId: string, base64Content?: string): Promise<boolean> {\r\n     try {\r\n       // Get the current document to check if it has changed\r\n       const document = await prisma.document.findUnique({\r\n         where: { id: documentId }\r\n       });\r\n \r\n       if (!document) {\r\n         return false;\r\n       }\r\n \r\n       // Check if we need to reprocess (e.g., if file has changed)\r\n       // For now, we'll just reprocess - we'll need to implement proper change detection\r\n       // once the Prisma client is updated with new fields\r\n       if ((document as any).colivaraProcessingStatus === 'COMPLETED' && (document as any).colivaraChecksum) {\r\n         // In a real implementation, we would check if the file has changed\r\n         // For now, we'll just reprocess\r\n       }\r\n \r\n       return await this.indexDocument(documentId, base64Content);\r\n     } catch (error) {\r\n       console.error(`Failed to update index for document ${documentId}:`, error);\r\n       return false;\r\n     }\r\n   }\r\n\r\n  async deleteFromIndex(documentId: string): Promise<boolean> {\r\n    try {\r\n      // Get the document first to check if it has a Colivara document ID\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId }\r\n      });\r\n\r\n      // If document exists and has a Colivara document ID, delete from Colivara collection\r\n      if (document && (document as any).colivaraDocumentId) {\r\n        try {\r\n          // Delete from Colivara collection using the official API\r\n          await this.client.deleteDocument({\r\n            document_name: (document as any).colivaraDocumentId,\r\n            collection_name: this.config.defaultCollection\r\n          });\r\n          console.log(`Successfully deleted document ${documentId} (${(document as any).colivaraDocumentId}) from Colivara collection`);\r\n        } catch (colivaraError) {\r\n          // Log the error but continue with database cleanup\r\n          console.error(`Failed to delete document ${documentId} from Colivara collection:`, colivaraError);\r\n          \r\n          // Check if it's a \"document not found\" error, which is acceptable\r\n          const colivaraServiceError = colivaraErrorHandler.convertErrorToColivaraError(colivaraError);\r\n          if (colivaraServiceError.type !== ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n            // For other errors, log but continue with database cleanup\r\n            console.warn(`Non-critical error deleting document from Colivara collection, proceeding with database cleanup:`, colivaraError);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Delete all index entries for this document using raw SQL\r\n      await prisma.$executeRaw`\r\n        DELETE FROM colivara_indexes WHERE \"documentId\" = ${documentId}\r\n      `;\r\n\r\n      // Update document to reset Colivara fields using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraDocumentId\" = NULL,\r\n            \"colivaraEmbeddings\" = NULL,\r\n            \"colivaraMetadata\" = NULL,\r\n            \"colivaraProcessingStatus\" = NULL,\r\n            \"colivaraProcessedAt\" = NULL,\r\n            \"colivaraChecksum\" = NULL\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Failed to delete document ${documentId} from index:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async extractDocumentMetadata(colivaraDocumentId: string): Promise<any> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to extractDocumentMetadata');\r\n      }\r\n\r\n      if (typeof this.client.getDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getDocument method');\r\n      }\r\n      \r\n      const response = await this.client.getDocument({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection  // Include collection name in the request\r\n      });\r\n      return response.metadata || response;\r\n    } catch (error) {\r\n      console.error(`Failed to extract metadata for ${colivaraDocumentId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async processNewDocument(document: Document, fileUrl: string, base64Content?: string): Promise<void> {\r\n    // This method processes a newly uploaded document\r\n    // It will be called after a document is successfully uploaded to the system\r\n    // Processing happens in the background without blocking the upload response\r\n    this.processNewDocumentAsync(document, fileUrl, base64Content);\r\n  }\r\n\r\n  private async processNewDocumentAsync(document: Document, fileUrl: string, base64Content?: string): Promise<void> {\r\n    try {\r\n      // The document should already be in the database with PENDING status\r\n      // We just need to trigger the Colivara processing\r\n      // Processing happens in the background without waiting for completion\r\n      this.indexDocument(document.id, base64Content);\r\n    } catch (error) {\r\n      console.error(`Error starting processing for new document ${document.id}:`, error);\r\n    }\r\n }\r\n\r\n  async handleDocumentUpdate(documentId: string, updatedDocument: Document, fileUrl?: string, base64Content?: string): Promise<void> {\r\n    try {\r\n      // Handle document updates\r\n      // If the file has changed (fileUrl is provided), reprocess the document\r\n      if (fileUrl) {\r\n        // Use updateIndex which will call indexDocument with the base64 content if provided\r\n        const success = await this.updateIndex(documentId, base64Content);\r\n        if (!success) {\r\n          console.error(`Failed to reprocess updated document ${documentId} with Colivara`);\r\n        }\r\n      } else {\r\n        // If only metadata changed, we might need to update the index differently\r\n        // For now, just return\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error handling document update for ${documentId}:`, error);\r\n    }\r\n  }\r\n\r\n /**\r\n   * Get visual content (screenshots/pages) from processed documents\r\n   * @param colivaraDocumentId The document ID in Colivara\r\n   * @param pageNumbers Specific pages to retrieve (optional, if not provided, returns all available)\r\n   */\r\n  async getVisualContent(colivaraDocumentId: string, pageNumbers?: number[]): Promise<string[]> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to getVisualContent');\r\n      }\r\n\r\n      console.log(`Getting visual content for document: ${colivaraDocumentId}, pages: ${pageNumbers || 'all'}`);\r\n\r\n      // Check if the getDocumentPages method exists on the client\r\n      if (typeof (this.client as any).getDocumentPages !== 'function') {\r\n        console.warn('Colivara client does not have a getDocumentPages method, returning empty array');\r\n        return [];\r\n      }\r\n\r\n      const response = await (this.client as any).getDocumentPages({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection,\r\n        page_numbers: pageNumbers\r\n      });\r\n\r\n      // Process the response to extract base64 images\r\n      if (response && response.pages) {\r\n        // If pages is an array of objects with image data\r\n        if (Array.isArray(response.pages)) {\r\n          return response.pages.map((page: any) => {\r\n            // Return base64 image data if available, otherwise return empty string\r\n            return page.image_data || page.image || page.base64 || '';\r\n          }).filter((img: string) => img !== ''); // Filter out empty strings\r\n        }\r\n        // If response has a different structure, try to extract images\r\n        else if (response.images && Array.isArray(response.images)) {\r\n          return response.images;\r\n        }\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error(`Failed to get visual content for ${colivaraDocumentId}:`, error);\r\n      return [];\r\n    }\r\n }\r\n\r\n  /**\r\n   * Get extracted text content from processed documents\r\n   * @param colivaraDocumentId The document ID in Colivara\r\n   * @param pageNumbers Specific pages to retrieve text from (optional, if not provided, returns all available)\r\n   */\r\n  async getExtractedText(colivaraDocumentId: string, pageNumbers?: number[]): Promise<string> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to getExtractedText');\r\n      }\r\n\r\n      console.log(`Getting extracted text for document: ${colivaraDocumentId}, pages: ${pageNumbers || 'all'}`);\r\n\r\n      // Check if the getDocumentText method exists on the client\r\n      if (typeof (this.client as any).getDocumentText !== 'function') {\r\n        console.warn('Colivara client does not have a getDocumentText method, returning empty string');\r\n        return '';\r\n      }\r\n\r\n      const response = await (this.client as any).getDocumentText({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection,\r\n        page_numbers: pageNumbers\r\n      });\r\n\r\n      // Return the extracted text content\r\n      return response.text || response.content || response.extracted_text || '';\r\n    } catch (error) {\r\n      console.error(`Failed to get extracted text for ${colivaraDocumentId}:`, error);\r\n      return '';\r\n    }\r\n }\r\n\r\n  /**\r\n   * Enhanced search method that includes visual content and extracted text for multimodal processing\r\n   */\r\n  async performEnhancedSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      // First, perform the standard semantic search\r\n      const standardResults = await this.performSemanticSearch(query, filters, userId);\r\n\r\n      // Instead of calling getVisualContent and getExtractedText which may trigger getDocumentPages errors,\r\n      // we'll return the standard results which should already contain the content from the search response\r\n      // This avoids the problematic API calls while still providing data for Gemini\r\n      return standardResults;\r\n    } catch (error) {\r\n      console.error('Enhanced search failed:', error);\r\n      // Fallback to standard search\r\n      return await this.performSemanticSearch(query, filters, userId);\r\n    }\r\n  }\r\n}\r\n\r\nexport default ColivaraService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/enhanced-document-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma';\r\nimport { Document } from '@/lib/api/types';\r\nimport ColivaraService from './colivara-service';\r\n\r\nconst colivaraService = new ColivaraService();\r\n\r\nclass EnhancedDocumentService {\r\n  /**\r\n   * Get all documents with optional filtering and pagination\r\n   * Enhanced with unit, year, quarter filtering capabilities\r\n   */\r\n  async getDocuments(\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    category?: string,\r\n    search?: string,\r\n    userId?: string,\r\n    sort?: string,\r\n    order: 'asc' | 'desc' = 'desc',\r\n    unitId?: string, // NEW: Filter by unit\r\n    year?: number, // NEW: Filter by reporting year\r\n    quarter?: number // NEW: Filter by reporting quarter\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    const skip = (page - 1) * limit;\r\n    \r\n    // Build where clause based on permissions and filters\r\n    const whereClause: any = {\r\n      status: 'ACTIVE', // Only show active documents\r\n    };\r\n\r\n    // Add category filter if provided\r\n    if (category && category !== 'all') {\r\n      whereClause.category = category;\r\n    }\r\n\r\n    // Add unit filter if provided\r\n    if (unitId) {\r\n      whereClause.unitId = unitId; // Using the new field name that was renamed from departmentId\r\n    }\r\n\r\n    // Add year filter if provided\r\n    if (year) {\r\n      whereClause.year = year;\r\n    }\r\n\r\n    // Add quarter filter if provided\r\n    if (quarter) {\r\n      whereClause.quarter = quarter;\r\n    }\r\n\r\n    // Add search filter if provided\r\n    if (search) {\r\n      const searchCondition = {\r\n        OR: [\r\n          { title: { contains: search, mode: 'insensitive' } },\r\n          { description: { contains: search, mode: 'insensitive' } },\r\n          { tags: { array_contains: [search] } }, // Updated for JSON field\r\n        ]\r\n      };\r\n      \r\n      // If we already have conditions (like category or unit), wrap everything in AND\r\n      if (Object.keys(whereClause).length > 1) { // More than just status\r\n        whereClause.AND = whereClause.AND || [];\r\n        whereClause.AND.push(searchCondition);\r\n      } else {\r\n        // If no other conditions exist, just add the search condition\r\n        Object.assign(whereClause, searchCondition);\r\n      }\r\n    }\r\n\r\n    // If user is not admin, only show documents they have access to\r\n    if (userId) {\r\n      // First, try to find the user by the provided userId (which might be the database ID)\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n\r\n      // In the new system, we only use the database ID\r\n      // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n      // The permission checks later will handle access control\r\n\r\n      if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n        // For non-admin and non-faculty users, we need to check document permissions\r\n        // This is a simplified approach - in a real system, you'd have more complex permission logic\r\n        const permissionCondition = {\r\n          OR: [\r\n            { uploadedById: user.id }, // Allow access to user's own documents (using db ID)\r\n            { permissions: { some: { userId: user.id, permission: { in: ['READ', 'WRITE', 'ADMIN'] } } } }, // Documents with explicit permissions\r\n          ]\r\n        };\r\n\r\n        // If we already have conditions in whereClause, wrap everything in AND\r\n        if (Object.keys(whereClause).length > 1) { // More than just status\r\n          whereClause.AND = whereClause.AND || [];\r\n          whereClause.AND.push(permissionCondition);\r\n        } else {\r\n          // If no other conditions exist, just add the permission condition\r\n          Object.assign(whereClause, permissionCondition);\r\n        }\r\n      }\r\n    }\r\n\r\n    try {\r\n      const [documents, total] = await Promise.all([\r\n        prisma.document.findMany({\r\n          where: whereClause,\r\n          skip,\r\n          take: limit,\r\n          orderBy: sort ? { [sort]: order } : { uploadedAt: 'desc' },\r\n          include: {\r\n            uploadedByUser: true,\r\n            documentUnit: true,\r\n          }\r\n        }),\r\n        prisma.document.count({ where: whereClause }),\r\n      ]);\r\n\r\n      return {\r\n        documents: documents.map((doc: any) => ({\r\n          ...doc,\r\n          tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n          unitId: doc.unitId ?? undefined,\r\n          year: doc.year ?? undefined,\r\n          quarter: doc.quarter ?? undefined,\r\n          isQproDocument: doc.isQproDocument ?? false,\r\n          versionNotes: doc.versionNotes ?? undefined, // Convert null to undefined\r\n          uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n          status: doc.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n          unit: doc.documentUnit ? {\r\n            id: doc.documentUnit.id,\r\n            name: doc.documentUnit.name,\r\n            code: doc.documentUnit.code,\r\n            description: doc.documentUnit.description || undefined, // Convert null to undefined\r\n            createdAt: doc.documentUnit.createdAt,\r\n            updatedAt: doc.documentUnit.updatedAt,\r\n          } : undefined,\r\n          uploadedAt: new Date(doc.uploadedAt),\r\n          createdAt: new Date(doc.createdAt),\r\n          updatedAt: new Date(doc.updatedAt),\r\n          // Colivara fields\r\n          colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n          colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n          colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n          colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n        })),\r\n        total,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocuments:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific document by ID\r\n   * Enhanced with unit access controls\r\n   */\r\n  async getDocumentById(id: string, userId?: string): Promise<Document | null> {\r\n    try {\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!document) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has access to the document\r\n      if (userId) {\r\n        // First, try to find the user by the provided userId (which might be the database ID)\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: userId },\r\n        });\r\n\r\n        // In the new system, we only use the database ID\r\n        // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n        // The permission checks later will handle access control\r\n\r\n        if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n          // Check if user has explicit permission for this document\r\n          const permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: id,\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['READ', 'WRITE', 'ADMIN'] }, // User needs at least READ permission\r\n            },\r\n          });\r\n\r\n          // Allow access if user has explicit READ/WRITE/ADMIN permission OR if user uploaded the document\r\n          if (!permission && document.uploadedById !== user.id) {\r\n            return null; // User doesn't have access\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        id: document.id,\r\n        title: document.title,\r\n        description: document.description,\r\n        category: document.category,\r\n        tags: Array.isArray(document.tags) ? document.tags as string[] : [],\r\n        uploadedBy: document.uploadedByUser?.name || document.uploadedBy,\r\n        uploadedById: document.uploadedById,\r\n        uploadedAt: new Date(document.uploadedAt),\r\n        fileUrl: document.fileUrl,\r\n        fileName: document.fileName,\r\n        fileType: document.fileType,\r\n        fileSize: document.fileSize,\r\n        downloadsCount: document.downloadsCount || 0,\r\n        viewsCount: document.viewsCount || 0,\r\n        version: document.version || 1,\r\n        versionNotes: document.versionNotes || undefined, // Convert null to undefined\r\n        status: document.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n        createdAt: new Date(document.createdAt),\r\n        updatedAt: new Date(document.updatedAt),\r\n        unitId: document.unitId || undefined, // Convert null to undefined\r\n        year: document.year ?? undefined,\r\n        quarter: document.quarter ?? undefined,\r\n        isQproDocument: document.isQproDocument ?? false,\r\n        unit: document.documentUnit ? {\r\n          id: document.documentUnit.id,\r\n          name: document.documentUnit.name,\r\n          code: document.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: document.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: document.documentUnit.createdAt,\r\n          updatedAt: document.documentUnit.updatedAt,\r\n        } : undefined,\r\n        // Colivara fields\r\n        colivaraDocumentId: document.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: document.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: document.colivaraProcessedAt ? new Date(document.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: document.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocumentById:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new document\r\n   * Enhanced with unit assignment and QPRO support (year, quarter)\r\n   */\r\n  async createDocument(\r\n    title: string,\r\n    description: string,\r\n    category: string,\r\n    tags: string[],\r\n    uploadedBy: string,\r\n    fileUrl: string,\r\n    fileName: string,\r\n    fileType: string,\r\n    fileSize: number,\r\n    userId: string,\r\n    unitId?: string, // NEW: Unit assignment\r\n    base64Content?: string, // NEW: Base64 content for Colivara processing\r\n    blobName?: string, // NEW: Azure Blob Storage blob name\r\n    options?: {\r\n      year?: number; // Reporting year for QPRO documents (2025-2029)\r\n      quarter?: number; // Reporting quarter for QPRO documents (1-4)\r\n      isQproDocument?: boolean; // Flag for QPRO documents\r\n    }\r\n  ): Promise<Document> {\r\n    try {\r\n      console.log('Creating document in database...', {\r\n        title,\r\n        description,\r\n        category,\r\n        tags,\r\n        uploadedBy,\r\n        fileUrl,\r\n        fileName,\r\n        fileType,\r\n        fileSize,\r\n        userId\r\n      });\r\n      \r\n      // First, check if userId is defined\r\n      if (!userId) {\r\n        console.error('No userId provided to createDocument function');\r\n        throw new Error('User ID is required to upload documents');\r\n      }\r\n\r\n      console.log('Attempting to find user with ID:', userId);\r\n      \r\n      // First, try to find user by the provided userId (which might be the database ID)\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n\r\n      // In the new system, we only use the database ID\r\n      // If not found by database ID, we return null\r\n      if (!user) {\r\n        console.error('User not found with provided ID:', userId);\r\n        throw new Error('Only admins and faculty can upload documents');\r\n      }\r\n      \r\n      console.log('User lookup result:', { user: !!user, role: user?.role, id: user?.id });\r\n\r\n      if (!user || !['ADMIN', 'FACULTY'].includes(user.role)) {\r\n        console.error('User does not have required role to upload documents:', user?.role);\r\n        throw new Error('Only admins and faculty can upload documents');\r\n      }\r\n\r\n      const document = await prisma.document.create({\r\n        data: {\r\n          title,\r\n          description: description || \"\", // Ensure description is not null\r\n          category: category || \"Uncategorized\", // Ensure category is not null\r\n          tags: tags || [], // Ensure tags is always an array, even if undefined\r\n          uploadedBy: user.name,\r\n          uploadedById: user.id, // Use the database user ID, not the Supabase auth ID\r\n          fileUrl,\r\n          blobName: blobName || undefined, // NEW: Store blob name if provided\r\n          fileName,\r\n          fileType,\r\n          fileSize,\r\n          unitId: unitId || null, // NEW: Assign unitId if provided\r\n          year: options?.year || null, // NEW: Reporting year for QPRO documents\r\n          quarter: options?.quarter || null, // NEW: Reporting quarter for QPRO documents\r\n          isQproDocument: options?.isQproDocument || false, // NEW: Flag for QPRO documents\r\n          status: 'ACTIVE',\r\n          colivaraProcessingStatus: 'PENDING', // Set initial processing status to PENDING\r\n        },\r\n      });\r\n      \r\n      console.log('Document created:', document.id);\r\n\r\n      // Grant the uploader full permissions\r\n      await prisma.documentPermission.create({\r\n        data: {\r\n          documentId: document.id,\r\n          userId: user.id, // Use the database user ID for permissions\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n      \r\n      console.log('Document permissions granted');\r\n\r\n      // Get the updated document to ensure we have the latest unitId value after creation\r\n      const finalDocument = await prisma.document.findUnique({\r\n        where: { id: document.id },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n      \r\n      if (!finalDocument) {\r\n        throw new Error(`Document with id ${document.id} not found after creation`);\r\n      }\r\n\r\n      // Trigger Colivara processing asynchronously without blocking document creation\r\n      try {\r\n        colivaraService.processNewDocument(finalDocument as Document, fileUrl, base64Content);\r\n      } catch (processingError) {\r\n        console.error(`Error triggering Colivara processing for document ${document.id}:`, processingError);\r\n        // Don't throw error as we don't want to fail the document creation due to processing issues\r\n      }\r\n      \r\n      return {\r\n        id: finalDocument.id,\r\n        title: finalDocument.title,\r\n        description: finalDocument.description,\r\n        category: finalDocument.category,\r\n        tags: Array.isArray(finalDocument.tags) ? finalDocument.tags as string[] : [],\r\n        uploadedBy: finalDocument.uploadedByUser?.name || finalDocument.uploadedBy,\r\n        uploadedById: finalDocument.uploadedById,\r\n        uploadedAt: new Date(finalDocument.uploadedAt),\r\n        fileUrl: finalDocument.fileUrl,\r\n        fileName: finalDocument.fileName,\r\n        fileType: finalDocument.fileType,\r\n        fileSize: finalDocument.fileSize,\r\n        downloadsCount: finalDocument.downloadsCount || 0,\r\n        viewsCount: finalDocument.viewsCount || 0,\r\n        version: finalDocument.version || 1,\r\n        versionNotes: finalDocument.versionNotes ?? undefined, // Convert null to undefined\r\n        status: finalDocument.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n        createdAt: new Date(finalDocument.createdAt),\r\n        updatedAt: new Date(finalDocument.updatedAt),\r\n        unitId: finalDocument.unitId ?? undefined,\r\n        year: finalDocument.year ?? undefined,\r\n        quarter: finalDocument.quarter ?? undefined,\r\n        isQproDocument: finalDocument.isQproDocument ?? false,\r\n        unit: finalDocument.documentUnit ? {\r\n          id: finalDocument.documentUnit.id,\r\n          name: finalDocument.documentUnit.name,\r\n          code: finalDocument.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: finalDocument.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: finalDocument.documentUnit.createdAt,\r\n          updatedAt: finalDocument.documentUnit.updatedAt,\r\n        } : undefined,\r\n        // Colivara fields\r\n        colivaraDocumentId: finalDocument.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: finalDocument.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: finalDocument.colivaraProcessedAt ? new Date(finalDocument.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: finalDocument.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in createDocument:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a document\r\n   * Enhanced with unit assignment\r\n   */\r\n  async updateDocument(\r\n    id: string,\r\n    title?: string,\r\n    description?: string,\r\n    category?: string,\r\n    tags?: string[],\r\n    unitId?: string, // NEW: Unit assignment\r\n    userId?: string,\r\n    fileUrl?: string, // NEW: File URL for Colivara reprocessing\r\n    base64Content?: string // NEW: Base64 content for Colivara processing\r\n  ): Promise<Document | null> {\r\n    try {\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!document) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has permission to update the document\r\n      let permission = null;\r\n      let user = null;\r\n\r\n      if (userId) {\r\n        // First, try to find the user by the provided userId (which might be the database ID)\r\n        user = await prisma.user.findUnique({\r\n          where: { id: userId },\r\n        });\r\n\r\n        // In the new system, we only use the database ID\r\n        // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n        // The permission checks later will handle access control\r\n\r\n        if (user) {\r\n          permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: id,\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['WRITE', 'ADMIN'] },\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      if (userId && !permission && user?.role !== 'ADMIN' && document.uploadedById !== user?.id) {\r\n        throw new Error('User does not have permission to update this document');\r\n      }\r\n\r\n      // Update document fields that Prisma client recognizes\r\n      const updatedDocument = await prisma.document.update({\r\n        where: { id },\r\n        data: {\r\n          ...(title && { title }),\r\n          ...(description !== undefined && { description: description || \"\" }),\r\n          ...(category !== undefined && { category: category || \"Uncategorized\" }),\r\n          ...(tags !== undefined && { tags: tags || [] }),\r\n          ...(unitId !== undefined && { unitId: unitId }), // Include unitId in the update if provided\r\n          updatedAt: new Date(),\r\n        },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      // Get the updated document\r\n      const finalDocument = updatedDocument;\r\n      \r\n      if (!finalDocument) {\r\n        throw new Error(`Document with id ${id} not found after update`);\r\n      }\r\n\r\n      // Check if file URL has changed to determine if we need to reprocess with Colivara\r\n      // In this implementation, we pass fileUrl as an optional parameter to determine if reprocessing is needed\r\n      if (fileUrl) {\r\n        try {\r\n          colivaraService.handleDocumentUpdate(id, finalDocument as Document, fileUrl, base64Content);\r\n        } catch (processingError) {\r\n          console.error(`Error triggering Colivara reprocessing for document ${id}:`, processingError);\r\n          // Don't throw error as we don't want to fail the document update due to processing issues\r\n        }\r\n      }\r\n      \r\n      return {\r\n        id: finalDocument.id,\r\n        title: finalDocument.title,\r\n        description: finalDocument.description,\r\n        category: finalDocument.category,\r\n        tags: Array.isArray(finalDocument.tags) ? finalDocument.tags as string[] : [],\r\n        uploadedBy: finalDocument.uploadedByUser?.name || finalDocument.uploadedBy,\r\n        uploadedById: finalDocument.uploadedById,\r\n        uploadedAt: new Date(finalDocument.uploadedAt),\r\n        fileUrl: finalDocument.fileUrl,\r\n        fileName: finalDocument.fileName,\r\n        fileType: finalDocument.fileType,\r\n        fileSize: finalDocument.fileSize,\r\n        downloadsCount: finalDocument.downloadsCount || 0,\r\n        viewsCount: finalDocument.viewsCount || 0,\r\n        version: finalDocument.version || 1,\r\n        versionNotes: finalDocument.versionNotes ?? undefined, // Convert null to undefined\r\n        status: finalDocument.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n        createdAt: new Date(finalDocument.createdAt),\r\n        updatedAt: new Date(finalDocument.updatedAt),\r\n        unitId: finalDocument.unitId ?? undefined,\r\n        unit: finalDocument.documentUnit ? {\r\n          id: finalDocument.documentUnit.id,\r\n          name: finalDocument.documentUnit.name,\r\n          code: finalDocument.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: finalDocument.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: finalDocument.documentUnit.createdAt,\r\n          updatedAt: finalDocument.documentUnit.updatedAt,\r\n        } : undefined,\r\n        // Colivara fields\r\n        colivaraDocumentId: finalDocument.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: finalDocument.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: finalDocument.colivaraProcessedAt ? new Date(finalDocument.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: finalDocument.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in updateDocument:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get documents by unit\r\n   */\r\n  async getDocumentsByUnit(\r\n    unitId: string,\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    userId?: string\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    return this.getDocuments(page, limit, undefined, undefined, userId, undefined, 'desc', unitId);\r\n  }\r\n\r\n  /**\r\n   * Get documents by unit that were uploaded by admin users only\r\n   */\r\n  async getAdminDocumentsByUnit(\r\n    unitId: string,\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    userId?: string\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    const skip = (page - 1) * limit;\r\n    \r\n    // Build where clause based on permissions and filters\r\n    const whereClause: any = {\r\n      status: 'ACTIVE', // Only show active documents\r\n      unitId: unitId, // Filter by unit\r\n    };\r\n\r\n    // If user is not admin, only show documents they have access to\r\n    if (userId) {\r\n      // First, try to find the user by the provided userId (which might be the database ID)\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n\r\n      // In the new system, we only use the database ID\r\n      // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n      // The permission checks later will handle access control\r\n\r\n      if (user && user.role === 'ADMIN') {\r\n        // Admins can see all documents in the unit regardless of who uploaded them\r\n        // No additional filtering needed for admins\r\n      } else if (user && user.role !== 'FACULTY') {\r\n        // For non-admin and non-faculty users, we need to check document permissions\r\n        const permissionCondition = {\r\n          OR: [\r\n            { uploadedById: user.id }, // Allow access to user's own documents (using db ID)\r\n            { permissions: { some: { userId: user.id, permission: { in: ['READ', 'WRITE', 'ADMIN'] } } } }, // Documents with explicit permissions\r\n          ]\r\n        };\r\n\r\n        // If we already have conditions in whereClause, wrap everything in AND\r\n        if (Object.keys(whereClause).length > 1) { // More than just status\r\n          whereClause.AND = whereClause.AND || [];\r\n          whereClause.AND.push(permissionCondition);\r\n        } else {\r\n          // If no other conditions exist, just add the permission condition\r\n          Object.assign(whereClause, permissionCondition);\r\n        }\r\n      }\r\n    }\r\n\r\n    try {\r\n      const [documents, total] = await Promise.all([\r\n        prisma.document.findMany({\r\n          where: whereClause,\r\n          skip,\r\n          take: limit,\r\n          orderBy: { uploadedAt: 'desc' },\r\n          include: {\r\n            uploadedByUser: true,\r\n            documentUnit: true,\r\n          }\r\n        }),\r\n        prisma.document.count({ where: whereClause }),\r\n      ]);\r\n\r\n      return {\r\n        documents: documents.map((doc: any) => ({\r\n          ...doc,\r\n          tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n          unitId: doc.unitId ?? undefined,\r\n          versionNotes: doc.versionNotes ?? undefined, // Convert null to undefined\r\n          uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n          status: doc.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n          unit: doc.documentUnit ? {\r\n            id: doc.documentUnit.id,\r\n            name: doc.documentUnit.name,\r\n            code: doc.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n            description: doc.documentUnit.description || undefined, // Convert null to undefined\r\n            createdAt: doc.documentUnit.createdAt,\r\n            updatedAt: doc.documentUnit.updatedAt,\r\n          } : undefined,\r\n          uploadedAt: new Date(doc.uploadedAt),\r\n          createdAt: new Date(doc.createdAt),\r\n          updatedAt: new Date(doc.updatedAt),\r\n          // Colivara fields\r\n          colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n          colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n          colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n          colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n        })),\r\n        total,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getAdminDocumentsByUnit:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user's unit permissions\r\n   */\r\n  async getUserUnitPermissions(userId: string, unitId: string): Promise<any | null> {\r\n    // This method is actually part of the unit permission service, not document service\r\n    // Placeholder implementation - this should be moved to the unit permission service\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Search documents with unit filters\r\n   */\r\n  async searchDocuments(\r\n    query: string,\r\n    unitId?: string,\r\n    category?: string,\r\n    tags?: string[],\r\n    userId?: string,\r\n    page: number = 1,\r\n    limit: number = 10\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    return this.getDocuments(page, limit, category, query, userId, undefined, 'desc', unitId);\r\n  }\r\n}\r\n\r\nexport default new EnhancedDocumentService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/jwt-service.ts"],"sourcesContent":["// This service is for handling custom JWT tokens for database authentication\r\n\r\nexport interface TokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n  iat: number;\r\n  exp: number;\r\n}\r\n\r\nclass JWTService {\r\n  private readonly secret: string;\r\n\r\n  constructor() {\r\n    this.secret = process.env.JWT_SECRET || '6dFk5d0vbyLnZC0Amy83LtI47DsNr/KB4M+FgbUc6njd4cjk7XB2/8nTuhQDWW8OOgQ6fI74huxJE3a/RP2giw==';\r\n  }\r\n\r\n  /**\r\n   * Convert a string to a Uint8Array (which can be used with Web Crypto API)\r\n   */\r\n private stringToUint8Array(str: string): Uint8Array {\r\n    return new TextEncoder().encode(str);\r\n }\r\n\r\n /**\r\n  * Convert a Uint8Array to a base64url encoded string\r\n  */\r\n private uint8ArrayToBase64Url(uint8Array: Uint8Array): string {\r\n   let binary = '';\r\n   for (let i = 0; i < uint8Array.byteLength; i++) {\r\n     binary += String.fromCharCode(uint8Array[i]);\r\n   }\r\n   return btoa(binary)\r\n     .replace(/\\+/g, '-')\r\n     .replace(/\\//g, '_')\r\n     .replace(/=/g, '');\r\n }\r\n\r\n  /**\r\n   * Import the secret as a CryptoKey for use with Web Crypto API\r\n   */\r\n  private async importSecret(): Promise<CryptoKey> {\r\n    const encoder = new TextEncoder();\r\n    const keyBuffer = encoder.encode(this.secret);\r\n    \r\n    return await crypto.subtle.importKey(\r\n      'raw',\r\n      keyBuffer,\r\n      { name: 'HMAC', hash: 'SHA-256' },\r\n      false,\r\n      ['sign', 'verify']\r\n    );\r\n  }\r\n\r\n /**\r\n   * Generate a JWT token using Web Crypto API\r\n   */\r\n  async generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): Promise<string> {\r\n    try {\r\n      // Create the header\r\n      const header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n      };\r\n\r\n      // Add timestamp and expiration (1 hour from now)\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const expiration = timestamp + 3600; // 1 hour in seconds\r\n\r\n      // Create the payload with the provided data and timestamps\r\n      const fullPayload = {\r\n        ...payload,\r\n        iat: timestamp,\r\n        exp: expiration\r\n      };\r\n\r\n      // Encode header and payload to base64url\r\n      const encodedHeader = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(header))\r\n      );\r\n      const encodedPayload = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(fullPayload))\r\n      );\r\n\r\n      // Create the signing input\r\n      const signingInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Create signing input buffer in the proper format for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const signingInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Sign the token - use type assertion to handle TypeScript compatibility issues\r\n      const signatureBuffer = await crypto.subtle.sign(\r\n        'HMAC',\r\n        key,\r\n        signingInputBuffer as BufferSource\r\n      );\r\n\r\n      // Encode the signature - signatureBuffer is an ArrayBuffer, convert to base64url\r\n      const signatureUint8Array = new Uint8Array(signatureBuffer);\r\n      const encodedSignature = this.uint8ArrayToBase64Url(signatureUint8Array);\r\n\r\n      // Return the complete JWT token\r\n      return `${signingInput}.${encodedSignature}`;\r\n    } catch (error) {\r\n      console.error('JWT token generation failed:', error);\r\n      throw new Error('Failed to generate JWT token');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a JWT token using Web Crypto API\r\n   */\r\n  async verifyToken(token: string): Promise<TokenPayload | null> {\r\n    try {\r\n      // Check if token is valid before attempting to verify\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        console.error('Invalid token provided for verification');\r\n        return null;\r\n      }\r\n      \r\n      // Check if token has proper format (3 parts separated by dots)\r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const [encodedHeader, encodedPayload, encodedSignature] = tokenParts;\r\n\r\n      // Decode header\r\n      const decodedHeader = this.base64UrlDecode(encodedHeader);\r\n      if (!decodedHeader) {\r\n        console.error('Failed to decode token header');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const decodedPayloadStr = this.base64UrlDecode(encodedPayload);\r\n      if (!decodedPayloadStr) {\r\n        console.error('Failed to decode token payload');\r\n        return null;\r\n      }\r\n\r\n      // Parse payload\r\n      const payloadObj = JSON.parse(decodedPayloadStr) as TokenPayload;\r\n      \r\n      // Check if token is expired\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      if (payloadObj.exp && payloadObj.exp < currentTime) {\r\n        console.error('Token has expired');\r\n        return null;\r\n      }\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Verify the signature\r\n      const isValid = await this.verifySignature(\r\n        `${encodedHeader}.${encodedPayload}`,\r\n        encodedSignature,\r\n        key\r\n      );\r\n\r\n      if (!isValid) {\r\n        console.error('Token signature verification failed');\r\n        return null;\r\n      }\r\n\r\n      return payloadObj;\r\n    } catch (error: any) {\r\n      console.error('Token verification failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify the JWT signature using Web Crypto API\r\n   */\r\n  private async verifySignature(\r\n    signingInput: string,\r\n    signature: string,\r\n    key: CryptoKey\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Decode the signature from base64url to Uint8Array\r\n      const signatureBytes = this.base64UrlDecodeToUint8Array(signature);\r\n      if (!signatureBytes) {\r\n        return false;\r\n      }\r\n\r\n      // Create proper buffers for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const verificationInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Use ArrayBufferView for signatureBytes and input buffer\r\n      // Cast to appropriate types to handle TypeScript issues\r\n      const signatureView = new Uint8Array(signatureBytes.buffer, signatureBytes.byteOffset, signatureBytes.byteLength);\r\n      const inputView = new Uint8Array(verificationInputBuffer.buffer, verificationInputBuffer.byteOffset, verificationInputBuffer.byteLength);\r\n      \r\n      // Verify the signature - use type assertion to handle TypeScript compatibility issues\r\n      const isValid = await crypto.subtle.verify(\r\n        'HMAC',\r\n        key,\r\n        signatureView as BufferSource,\r\n        inputView as BufferSource\r\n      );\r\n\r\n      return isValid;\r\n    } catch (error) {\r\n      console.error('Signature verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Decode a JWT token without verification (for edge runtime compatibility)\r\n   * This only extracts the payload without validating the signature\r\n   * Use carefully - only for non-sensitive operations like checking expiration\r\n   */\r\n  decodeToken(token: string): TokenPayload | null {\r\n    try {\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        return null;\r\n      }\r\n      \r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const payload = tokenParts[1];\r\n      const decodedPayload = this.base64UrlDecode(payload);\r\n      if (!decodedPayload) {\r\n        return null;\r\n      }\r\n      \r\n      return JSON.parse(decodedPayload) as TokenPayload;\r\n    } catch (error: any) {\r\n      console.error('Token decoding failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token is expired without full verification\r\n   * This uses the decode method which doesn't require the secret\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      const decoded = this.decodeToken(token);\r\n      if (!decoded || !decoded.exp) {\r\n        return true; // If we can't decode or there's no expiration, consider it expired\r\n      }\r\n      // Compare expiration timestamp with current time (in seconds)\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      return decoded.exp < currentTime;\r\n    } catch (error) {\r\n      console.error('Error checking token expiration:', error);\r\n      return true; // If there's an error, assume token is expired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url encoded strings\r\n   */\r\n  private base64UrlDecode(str: string): string | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      return decodeURIComponent(escape(rawData));\r\n    } catch (error) {\r\n      console.error('Base64 URL decode error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url string to Uint8Array\r\n   */\r\n  private base64UrlDecodeToUint8Array(str: string): Uint8Array | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      \r\n      const buffer = new Uint8Array(rawData.length);\r\n      for (let i = 0; i < rawData.length; i++) {\r\n        buffer[i] = rawData.charCodeAt(i);\r\n      }\r\n      \r\n      return buffer;\r\n    } catch (error) {\r\n      console.error('Base64 URL decode to Uint8Array error:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new JWTService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2103, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/utils/rbac.ts"],"sourcesContent":["/**\r\n * Role-Based Access Control (RBAC) utilities for LSPU KMIS\r\n * Defines role hierarchies and permission checks\r\n */\r\n\r\nexport type UserRole = 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL';\r\n\r\n// Define role hierarchy - ADMIN has highest privileges, followed by FACULTY, STUDENT, then EXTERNAL\r\nconst ROLE_HIERARCHY: Record<UserRole, number> = {\r\n  'ADMIN': 4,\r\n  'FACULTY': 3,\r\n  'STUDENT': 2,\r\n  'EXTERNAL': 1\r\n};\r\n\r\n/**\r\n * Check if a user has a specific role\r\n */\r\nexport function hasRole(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return userRole === requiredRole;\r\n}\r\n\r\n/**\r\n * Check if a user has any of the specified roles\r\n */\r\nexport function hasAnyRole(userRole: UserRole, requiredRoles: UserRole[]): boolean {\r\n  return requiredRoles.includes(userRole);\r\n}\r\n\r\n/**\r\n * Check if a user's role has higher or equal hierarchy than required role\r\n */\r\nexport function hasRoleHierarchy(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];\r\n}\r\n\r\n/**\r\n * Check if user has admin privileges\r\n */\r\nexport function isAdmin(userRole: UserRole): boolean {\r\n  return userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has faculty privileges\r\n */\r\nexport function isFaculty(userRole: UserRole): boolean {\r\n  return userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has student privileges\r\n */\r\nexport function isStudent(userRole: UserRole): boolean {\r\n  return userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has external privileges\r\n */\r\nexport function isExternal(userRole: UserRole): boolean {\r\n  return userRole === 'EXTERNAL' || userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Get allowed actions based on user role\r\n */\r\nexport function getAllowedActions(userRole: UserRole): string[] {\r\n  switch (userRole) {\r\n    case 'ADMIN':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'DELETE_DOCUMENT',\r\n        'CREATE_USER',\r\n        'READ_USER',\r\n        'UPDATE_USER',\r\n        'DELETE_USER',\r\n        'CREATE_UNIT',\r\n        'READ_UNIT',\r\n        'UPDATE_UNIT',\r\n        'DELETE_UNIT',\r\n        'MANAGE_PERMISSIONS',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'FACULTY':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'STUDENT':\r\n      return [\r\n        'READ_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT'\r\n      ];\r\n    case 'EXTERNAL':\r\n      return [\r\n        'READ_DOCUMENT'\r\n      ];\r\n    default:\r\n      return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a user has permission to perform an action\r\n */\r\nexport function hasPermission(userRole: UserRole, action: string): boolean {\r\n  const allowedActions = getAllowedActions(userRole);\r\n  return allowedActions.includes(action);\r\n}\r\n\r\n/**\r\n * Get all roles that can perform a specific action\r\n */\r\nexport function getRolesForAction(action: string): UserRole[] {\r\n  const roles: UserRole[] = [];\r\n  (Object.keys(ROLE_HIERARCHY) as UserRole[]).forEach(role => {\r\n    if (hasPermission(role, action)) {\r\n      roles.push(role);\r\n    }\r\n  });\r\n  return roles;\r\n}"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;;;AAID,oGAAoG;AACpG,MAAM,iBAA2C;IAC/C,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY;AACd;AAKO,SAAS,QAAQ,QAAkB,EAAE,YAAsB;IAChE,OAAO,aAAa;AACtB;AAKO,SAAS,WAAW,QAAkB,EAAE,aAAyB;IACtE,OAAO,cAAc,QAAQ,CAAC;AAChC;AAKO,SAAS,iBAAiB,QAAkB,EAAE,YAAsB;IACzE,OAAO,cAAc,CAAC,SAAS,IAAI,cAAc,CAAC,aAAa;AACjE;AAKO,SAAS,QAAQ,QAAkB;IACxC,OAAO,aAAa;AACtB;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa;AAChD;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa,aAAa,aAAa;AAC1E;AAKO,SAAS,WAAW,QAAkB;IAC3C,OAAO,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa;AACrG;AAKO,SAAS,kBAAkB,QAAkB;IAClD,OAAQ;QACN,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;aACD;QACH;YACE,OAAO,EAAE;IACb;AACF;AAKO,SAAS,cAAc,QAAkB,EAAE,MAAc;IAC9D,MAAM,iBAAiB,kBAAkB;IACzC,OAAO,eAAe,QAAQ,CAAC;AACjC;AAKO,SAAS,kBAAkB,MAAc;IAC9C,MAAM,QAAoB,EAAE;IAC3B,OAAO,IAAI,CAAC,gBAA+B,OAAO,CAAC,CAAA;QAClD,IAAI,cAAc,MAAM,SAAS;YAC/B,MAAM,IAAI,CAAC;QACb;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 2215, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/middleware/auth-middleware.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { NextResponse } from 'next/server';\r\nimport jwtService from '@/lib/services/jwt-service';\r\nimport prisma from '@/lib/prisma';\r\nimport { hasAnyRole, type UserRole } from '@/lib/utils/rbac';\r\n\r\nexport async function requireAuth(request: NextRequest, roles?: string[]): Promise<{ user: any } | NextResponse> {\r\n  // Extract the token from the Authorization header or cookies\r\n  const authHeader = request.headers.get('authorization');\r\n  let token = null;\r\n  \r\n  if (authHeader && authHeader.startsWith('Bearer ')) {\r\n    token = authHeader.substring(7);\r\n  } else {\r\n    // Try to get token from cookies\r\n    const cookies = request.cookies;\r\n    token = cookies.get('access_token')?.value;\r\n  }\r\n\r\n  if (!token) {\r\n    // For API routes, return a 401 response instead of redirecting\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });\r\n    }\r\n    // For regular routes, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n  }\r\n\r\n  // Verify the JWT token\r\n  const decoded = await jwtService.verifyToken(token);\r\n  if (!decoded) {\r\n    console.error('Token verification failed:', token ? token.substring(0, 20) + '...' : 'null');\r\n    // Token is invalid, return appropriate response based on request type\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 });\r\n    } else {\r\n      // For regular routes, redirect to login\r\n      const response = NextResponse.redirect(new URL('/', request.url));\r\n      return response;\r\n    }\r\n }\r\n\r\n  console.log('Decoded token:', decoded);\r\n\r\n  // Check if decoded.userId is valid\r\n  if (!decoded.userId) {\r\n    console.error('Token does not contain userId:', decoded);\r\n    // Token doesn't contain a valid userId, return error\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid token: missing user ID' }, { status: 401 });\r\n    }\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Get user profile from database using the user ID from the token\r\n  const user = await prisma.user.findUnique({\r\n    where: {\r\n      id: decoded.userId,\r\n    },\r\n    select: {\r\n      id: true,\r\n      email: true,\r\n      name: true,\r\n      role: true,\r\n      unitId: true,\r\n    }\r\n  });\r\n\r\n  if (!user) {\r\n    console.error('User not found with ID from token:', decoded.userId);\r\n    // User doesn't exist in the database, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Check if user has required roles\r\n  if (roles && roles.length > 0 && !hasAnyRole(user.role as UserRole, roles as UserRole[])) {\r\n    // User doesn't have required role, return error for API routes\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'User does not have required role to perform this action' }, { status: 403 });\r\n    }\r\n    // For regular routes, redirect to unauthorized page\r\n    const response = NextResponse.redirect(new URL('/unauthorized', request.url));\r\n    return response;\r\n  }\r\n\r\n  return { user };\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEO,eAAe,YAAY,OAAoB,EAAE,KAAgB;IACtE,6DAA6D;IAC7D,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,QAAQ;IAEZ,IAAI,cAAc,WAAW,UAAU,CAAC,YAAY;QAClD,QAAQ,WAAW,SAAS,CAAC;IAC/B,OAAO;QACL,gCAAgC;QAChC,MAAM,UAAU,QAAQ,OAAO;QAC/B,QAAQ,QAAQ,GAAG,CAAC,iBAAiB;IACvC;IAEA,IAAI,CAAC,OAAO;QACV,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QACA,wCAAwC;QACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACT;IAEA,uBAAuB;IACvB,MAAM,UAAU,MAAM,8IAAU,CAAC,WAAW,CAAC;IAC7C,IAAI,CAAC,SAAS;QACZ,QAAQ,KAAK,CAAC,8BAA8B,QAAQ,MAAM,SAAS,CAAC,GAAG,MAAM,QAAQ;QACrF,sEAAsE;QACtE,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAChF,OAAO;YACL,wCAAwC;YACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;YAC/D,OAAO;QACT;IACH;IAEC,QAAQ,GAAG,CAAC,kBAAkB;IAE9B,mCAAmC;IACnC,IAAI,CAAC,QAAQ,MAAM,EAAE;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,qDAAqD;QACrD,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiC,GAAG;gBAAE,QAAQ;YAAI;QACtF;QACA,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,kEAAkE;IAClE,MAAM,OAAO,MAAM,0HAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YACL,IAAI,QAAQ,MAAM;QACpB;QACA,QAAQ;YACN,IAAI;YACJ,OAAO;YACP,MAAM;YACN,MAAM;YACN,QAAQ;QACV;IACF;IAEA,IAAI,CAAC,MAAM;QACT,QAAQ,KAAK,CAAC,sCAAsC,QAAQ,MAAM;QAClE,wDAAwD;QACxD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,mCAAmC;IACnC,IAAI,SAAS,MAAM,MAAM,GAAG,KAAK,CAAC,IAAA,oIAAU,EAAC,KAAK,IAAI,EAAc,QAAsB;QACxF,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0D,GAAG;gBAAE,QAAQ;YAAI;QAC/G;QACA,oDAAoD;QACpD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;QAC3E,OAAO;IACT;IAEA,OAAO;QAAE;IAAK;AAChB"}},
    {"offset": {"line": 2348, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/config-service.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\r\n\r\ninterface RateLimitConfig {\r\n  maxRequests: number;\r\n  windowMs: number; // in milliseconds\r\n}\r\n\r\ninterface SecurityConfig {\r\n  rateLimit: RateLimitConfig;\r\n  apiKeyRotationInterval: number; // in hours\r\n  requestTimeout: number; // in milliseconds\r\n}\r\n\r\nclass ConfigService {\r\n  private static instance: ConfigService;\r\n  private config: SecurityConfig;\r\n  private requestCounts: Map<string, { count: number; resetTime: number }> = new Map();\r\n  \r\n  private constructor() {\r\n    this.config = {\r\n      rateLimit: {\r\n        maxRequests: parseInt(process.env.AI_MAX_REQUESTS_PER_HOUR || '60', 10), // Default 60 requests per hour\r\n        windowMs: 60 * 60 * 1000, // 1 hour in milliseconds\r\n      },\r\n      apiKeyRotationInterval: parseInt(process.env.API_KEY_ROTATION_INTERVAL_HOURS || '24', 10), // Default 24 hours\r\n      requestTimeout: parseInt(process.env.AI_REQUEST_TIMEOUT || '30000', 10), // Default 30 seconds\r\n    };\r\n  }\r\n\r\n  public static getInstance(): ConfigService {\r\n    if (!ConfigService.instance) {\r\n      ConfigService.instance = new ConfigService();\r\n    }\r\n    return ConfigService.instance;\r\n  }\r\n\r\n  /**\r\n   * Check if a request from a given user/identifier is allowed based on rate limiting\r\n   */\r\n  public isRequestAllowed(identifier: string): boolean {\r\n    const now = Date.now();\r\n    const windowStart = now - this.config.rateLimit.windowMs;\r\n    \r\n    const record = this.requestCounts.get(identifier);\r\n    \r\n    if (!record) {\r\n      // First request from this identifier\r\n      this.requestCounts.set(identifier, {\r\n        count: 1,\r\n        resetTime: now + this.config.rateLimit.windowMs\r\n      });\r\n      return true;\r\n    }\r\n    \r\n    // Clean up old records\r\n    if (record.resetTime < now) {\r\n      this.requestCounts.set(identifier, {\r\n        count: 1,\r\n        resetTime: now + this.config.rateLimit.windowMs\r\n      });\r\n      return true;\r\n    }\r\n    \r\n    // Check if limit is exceeded\r\n    if (record.count >= this.config.rateLimit.maxRequests) {\r\n      return false;\r\n    }\r\n    \r\n    // Increment count\r\n    this.requestCounts.set(identifier, {\r\n      count: record.count + 1,\r\n      resetTime: record.resetTime\r\n    });\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get remaining requests for a given identifier\r\n   */\r\n  public getRemainingRequests(identifier: string): number {\r\n    const now = Date.now();\r\n    const record = this.requestCounts.get(identifier);\r\n    \r\n    if (!record || record.resetTime < now) {\r\n      return this.config.rateLimit.maxRequests;\r\n    }\r\n    \r\n    return Math.max(0, this.config.rateLimit.maxRequests - record.count);\r\n  }\r\n\r\n  /**\r\n   * Get rate limit reset time for a given identifier\r\n   */\r\n  public getResetTime(identifier: string): number {\r\n    const record = this.requestCounts.get(identifier);\r\n    return record ? record.resetTime : Date.now() + this.config.rateLimit.windowMs;\r\n  }\r\n\r\n  /**\r\n   * Get the current security configuration\r\n   */\r\n  public getSecurityConfig(): SecurityConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Validate API key format\r\n   */\r\n  public validateApiKey(apiKey: string): boolean {\r\n    // Basic validation - check if API key has content\r\n    return apiKey.trim().length > 0;\r\n  }\r\n\r\n  /**\r\n   * Health check for the AI API\r\n   */\r\n  public async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const apiKey = process.env.AI_API_KEY;\r\n      if (!apiKey) {\r\n        console.error('AI_API_KEY is not set');\r\n        return false;\r\n      }\r\n\r\n      // For now, we'll just check if the API key exists and has some content\r\n      // A more comprehensive health check would require knowing which service is using this config\r\n      if (!apiKey.trim()) {\r\n        console.error('AI_API_KEY is empty');\r\n        return false;\r\n      }\r\n\r\n      // This is a basic health check that just confirms the API key exists\r\n      // More specific health checks should be implemented in the respective services\r\n      return true;\r\n    } catch (error: any) {\r\n      console.error('AI API health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ConfigService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2463, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/monitoring-service.ts"],"sourcesContent":["interface PerformanceMetrics {\r\n  timestamp: Date;\r\n  endpoint: string;\r\n responseTime: number; // in milliseconds\r\n  userId?: string;\r\n  query?: string;\r\n  success: boolean;\r\n  error?: string;\r\n  model?: string;\r\n  inputTokens?: number;\r\n  outputTokens?: number;\r\n}\r\n\r\ninterface MonitoringConfig {\r\n  logPerformance: boolean;\r\n  logErrors: boolean;\r\n  logUsage: boolean;\r\n  performanceThreshold: number; // in milliseconds\r\n}\r\n\r\nclass MonitoringService {\r\n  private static instance: MonitoringService;\r\n  private config: MonitoringConfig;\r\n  private metrics: PerformanceMetrics[] = [];\r\n private readonly maxMetricsStored: number = 1000; // Keep last 1000 metrics\r\n\r\n  private constructor() {\r\n    this.config = {\r\n      logPerformance: process.env.LOG_PERFORMANCE === 'true' || true,\r\n      logErrors: process.env.LOG_ERRORS === 'true' || true,\r\n      logUsage: process.env.LOG_USAGE === 'true' || true,\r\n      performanceThreshold: parseInt(process.env.PERFORMANCE_THRESHOLD_MS || '5000', 10), // 5 seconds default\r\n    };\r\n  }\r\n\r\n  public static getInstance(): MonitoringService {\r\n    if (!MonitoringService.instance) {\r\n      MonitoringService.instance = new MonitoringService();\r\n    }\r\n    return MonitoringService.instance;\r\n  }\r\n\r\n  /**\r\n   * Log a performance metric\r\n   */\r\n  public logMetric(metric: Omit<PerformanceMetrics, 'timestamp'>): void {\r\n    if (!this.config.logPerformance && !this.config.logUsage) {\r\n      return; // Skip logging if not enabled\r\n    }\r\n\r\n    const fullMetric: PerformanceMetrics = {\r\n      ...metric,\r\n      timestamp: new Date(),\r\n    };\r\n\r\n    // Add to metrics array\r\n    this.metrics.push(fullMetric);\r\n\r\n    // Keep only the most recent metrics\r\n    if (this.metrics.length > this.maxMetricsStored) {\r\n      this.metrics = this.metrics.slice(-this.maxMetricsStored);\r\n    }\r\n\r\n    // Log to console based on configuration\r\n    if (metric.success) {\r\n      if (this.config.logPerformance) {\r\n        console.log(`[PERFORMANCE] ${metric.endpoint} took ${metric.responseTime}ms for user ${metric.userId || 'unknown'}`);\r\n      }\r\n    } else {\r\n      if (this.config.logErrors) {\r\n        console.error(`[ERROR] ${metric.endpoint} failed for user ${metric.userId || 'unknown'}: ${metric.error}`);\r\n      }\r\n    }\r\n\r\n    // Alert if response time exceeds threshold\r\n    if (metric.responseTime > this.config.performanceThreshold) {\r\n      console.warn(`[PERFORMANCE ALERT] ${metric.endpoint} exceeded threshold: ${metric.responseTime}ms > ${this.config.performanceThreshold}ms`);\r\n    }\r\n  }\r\n\r\n /**\r\n   * Track API usage\r\n   */\r\n  public trackUsage(userId: string, endpoint: string, model?: string): void {\r\n    if (!this.config.logUsage) {\r\n      return;\r\n    }\r\n\r\n    console.log(`[USAGE] User ${userId} accessed ${endpoint}${model ? ` using model ${model}` : ''} at ${new Date().toISOString()}`);\r\n  }\r\n\r\n  /**\r\n   * Track generation performance\r\n   */\r\n public trackGeneration(userId: string, query: string, responseTime: number, success: boolean, error?: string, model?: string): void {\r\n    this.logMetric({\r\n      endpoint: 'ai-generation',\r\n      responseTime,\r\n      userId,\r\n      query,\r\n      success,\r\n      error,\r\n      model\r\n    });\r\n  }\r\n\r\n /**\r\n   * Track search performance\r\n   */\r\n  public trackSearch(userId: string, query: string, responseTime: number, success: boolean, error?: string): void {\r\n    this.logMetric({\r\n      endpoint: 'search',\r\n      responseTime,\r\n      userId,\r\n      query,\r\n      success,\r\n      error\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get performance summary for an endpoint\r\n   */\r\n  public getPerformanceSummary(endpoint: string): {\r\n    avgResponseTime: number;\r\n    minResponseTime: number;\r\n    maxResponseTime: number;\r\n    totalRequests: number;\r\n    successfulRequests: number;\r\n    failedRequests: number;\r\n    errorRate: number;\r\n  } {\r\n    const endpointMetrics = this.metrics.filter(m => m.endpoint === endpoint);\r\n    \r\n    if (endpointMetrics.length === 0) {\r\n      return {\r\n        avgResponseTime: 0,\r\n        minResponseTime: 0,\r\n        maxResponseTime: 0,\r\n        totalRequests: 0,\r\n        successfulRequests: 0,\r\n        failedRequests: 0,\r\n        errorRate: 0\r\n      };\r\n    }\r\n\r\n    const responseTimes = endpointMetrics.map(m => m.responseTime);\r\n    const successful = endpointMetrics.filter(m => m.success).length;\r\n    const failed = endpointMetrics.filter(m => !m.success).length;\r\n    \r\n    const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;\r\n    const minResponseTime = Math.min(...responseTimes);\r\n    const maxResponseTime = Math.max(...responseTimes);\r\n    const totalRequests = endpointMetrics.length;\r\n    const errorRate = failed / totalRequests;\r\n\r\n    return {\r\n      avgResponseTime,\r\n      minResponseTime,\r\n      maxResponseTime,\r\n      totalRequests,\r\n      successfulRequests: successful,\r\n      failedRequests: failed,\r\n      errorRate\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all metrics (for debugging/monitoring purposes)\r\n   */\r\n  public getAllMetrics(): PerformanceMetrics[] {\r\n    return [...this.metrics]; // Return a copy to prevent external modification\r\n }\r\n\r\n  /**\r\n   * Clear all stored metrics\r\n   */\r\n  public clearMetrics(): void {\r\n    this.metrics = [];\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  public getConfig(): MonitoringConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  public updateConfig(newConfig: Partial<MonitoringConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n  }\r\n}\r\n\r\nexport default MonitoringService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2616, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/qwen-generation-service.ts"],"sourcesContent":["import OpenAI from 'openai';\r\nimport ConfigService from './config-service';\r\nimport MonitoringService from './monitoring-service';\r\n\r\n// Define the SearchResult interface to match what's expected\r\ninterface SearchResult {\r\n  documentId: string;\r\n title: string;\r\n content: string;\r\n score: number;\r\n pageNumbers: number[];\r\n  documentSection?: string;\r\n  confidenceScore?: number;\r\n  snippet: string;\r\n  document: any; // Replace with actual Document type if available\r\n  visualContent?: string; // Base64 encoded visual content\r\n  extractedText?: string; // Extracted text content\r\n  screenshots?: string[]; // Array of screenshot base64 strings\r\n  mimeType?: string; // MIME type for the screenshots (e.g., 'image/jpeg', 'image/png')\r\n}\r\n\r\ninterface QwenConfig {\r\n  apiKey: string;\r\n  model?: string;\r\n baseURL?: string; // For Qwen API endpoint\r\n  generationConfig?: {\r\n    temperature?: number;\r\n    maxOutputTokens?: number;\r\n    topP?: number;\r\n    topK?: number;\r\n  };\r\n}\r\n\r\ninterface GenerationOptions {\r\n  textOnly?: boolean;\r\n  maxResults?: number;\r\n  customPrompt?: string;\r\n}\r\n\r\nclass QwenGenerationService {\r\n  private openai: OpenAI;\r\n  private config: QwenConfig;\r\n  private configService: ConfigService;\r\n  private monitoringService: MonitoringService;\r\n\r\n  constructor(config?: Partial<QwenConfig>) {\r\n    const apiKey = process.env.QWEN_API_KEY || config?.apiKey || '';\r\n    if (!apiKey) {\r\n      throw new Error('Qwen API key is required for Qwen Generation Service');\r\n    }\r\n\r\n    this.config = {\r\n      apiKey,\r\n      model: config?.model || process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct',\r\n      baseURL: config?.baseURL || process.env.QWEN_BASE_URL || 'https://openrouter.ai/api/v1',\r\n      generationConfig: config?.generationConfig || {\r\n        temperature: 0.2,\r\n        maxOutputTokens: 8192,\r\n        topP: 0.95,\r\n        topK: 40,\r\n      },\r\n    };\r\n\r\n    // Enforce a safe cap for gpt-4o-mini / 4o models to avoid excessive outputs\r\n    try {\r\n      const GPT4O_MINI_MAX_OUTPUT = 4096;\r\n      if (this.config.model && this.config.model.includes('4o')) {\r\n        this.config.generationConfig = this.config.generationConfig || {};\r\n        this.config.generationConfig.maxOutputTokens = Math.min(this.config.generationConfig.maxOutputTokens || GPT4O_MINI_MAX_OUTPUT, GPT4O_MINI_MAX_OUTPUT);\r\n      }\r\n    } catch (e) {\r\n      // ignore errors here - defensive programming\r\n    }\r\n\r\n    this.openai = new OpenAI({\r\n      apiKey: this.config.apiKey,\r\n      baseURL: this.config.baseURL,\r\n    });\r\n\r\n    this.configService = ConfigService.getInstance();\r\n    this.monitoringService = MonitoringService.getInstance();\r\n  }\r\n\r\n  /**\r\n   * Generate a response based on search results and user query\r\n   * @param query User's search query\r\n   * @param searchResults Results from Colivara semantic search\r\n   * @param options Generation options\r\n   * @param userId User identifier for rate limiting\r\n   */\r\n async generateResponse(\r\n    query: string,\r\n    searchResults: SearchResult[],\r\n    options: GenerationOptions = {},\r\n    userId?: string\r\n ): Promise<string> {\r\n    const startTime = Date.now();\r\n    try {\r\n      // Use user ID for rate limiting, fallback to a general identifier if not provided\r\n      const identifier = userId || 'anonymous';\r\n      \r\n      // Check if request is allowed based on rate limiting\r\n      if (!this.configService.isRequestAllowed(identifier)) {\r\n        const remainingRequests = this.configService.getRemainingRequests(identifier);\r\n        const resetTime = this.configService.getResetTime(identifier);\r\n        const resetTimeFormatted = new Date(resetTime).toLocaleTimeString();\r\n        \r\n        const error = new Error(\r\n          `Rate limit exceeded. You can make ${remainingRequests} more requests after ${resetTimeFormatted}.`\r\n        );\r\n        \r\n        // Track the failed request\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          false,\r\n          error.message,\r\n          this.config.model\r\n        );\r\n        \r\n        throw error;\r\n      }\r\n\r\n      // Limit the number of results to process\r\n      const maxResults = options.maxResults || 6;\r\n      const limitedResults = searchResults.slice(0, maxResults);\r\n\r\n      if (limitedResults.length === 0) {\r\n        const response = \"I couldn't find any relevant documents to answer your query. Please try a different search term.\";\r\n        \r\n        // Track the successful request with no results\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          true,\r\n          undefined,\r\n          this.config.model\r\n        );\r\n        \r\n        return response;\r\n      }\r\n\r\n      // Check if the query is asking for comprehensive information (like lists of faculty/trainings)\r\n      const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                   query.toLowerCase().includes('all') ||\r\n                                   query.toLowerCase().includes('every') ||\r\n                                   query.toLowerCase().includes('faculty') ||\r\n                                   query.toLowerCase().includes('training') ||\r\n                                   query.toLowerCase().includes('seminar') ||\r\n                                   query.toLowerCase().includes('attended') ||\r\n                                   query.toLowerCase().includes('presentation') ||\r\n                                   query.toLowerCase().includes('research') ||\r\n                                   (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                   (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                   (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                   (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n      \r\n      // For comprehensive queries, ensure we use more results\r\n      const resultsForGeneration = isComprehensiveQuery ?\r\n        searchResults.slice(0, 6) : // Use up to 6 results for comprehensive queries\r\n        limitedResults; // Use the limited results for specific queries\r\n      \r\n      // Prepare the content for the model based on options\r\n      // Check if any results have visual content to determine if we should use multimodal processing\r\n      const hasVisualContent = resultsForGeneration.some(result => result.visualContent || (result.screenshots && result.screenshots.length > 0));\r\n      \r\n      // Also check if the model supports image inputs\r\n      const isImageSupported = this.config.model && (\r\n        this.config.model.includes('vl') ||\r\n        this.config.model.includes('vision') ||\r\n        this.config.model.includes('106') ||  // newer models often support images\r\n        this.config.model.includes('1106-preview') ||\r\n        this.config.model.includes('4-turbo') ||\r\n        this.config.model.includes('4o')\r\n      );\r\n      \r\n      let result: string;\r\n      if (options.textOnly || !hasVisualContent || !isImageSupported) {\r\n        result = await this.generateTextOnlyResponse(query, resultsForGeneration, options);\r\n      } else {\r\n        result = await this.generateMultimodalResponse(query, resultsForGeneration, options);\r\n      }\r\n      \r\n      // Track the successful request\r\n      this.monitoringService.trackGeneration(\r\n        userId || 'unknown',\r\n        query,\r\n        Date.now() - startTime,\r\n        true,\r\n        undefined,\r\n        this.config.model\r\n      );\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error generating response with Qwen:', error);\r\n      \r\n      // Track the failed request\r\n      this.monitoringService.trackGeneration(\r\n        userId || 'unknown',\r\n        query,\r\n        Date.now() - startTime,\r\n        false,\r\n        error instanceof Error ? error.message : 'Unknown error',\r\n        this.config.model\r\n      );\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a text-only response using search results\r\n   */\r\n private async generateTextOnlyResponse(\r\n    query: string,\r\n    searchResults: SearchResult[],\r\n    options: GenerationOptions\r\n  ): Promise<string> {\r\n    // Format the search results into a context string\r\n    const context = searchResults\r\n      .map((result, index) => {\r\n        const content = result.content || result.snippet || '';\r\n        const title = result.title || 'Untitled Document';\r\n        const pageNumbers = result.pageNumbers?.length ? ` (pages: ${result.pageNumbers.join(', ')})` : '';\r\n        const score = result.confidenceScore ? ` (relevance: ${(result.confidenceScore * 100).toFixed(1)}%)` : '';\r\n        const hasVisuals = result.screenshots && result.screenshots.length > 0;\r\n        \r\n        let resultText = `Document ${index + 1}: ${title}${pageNumbers}${score}\\n`;\r\n        \r\n        if (hasVisuals) {\r\n          resultText += `[VISUAL DATA: This document contains ${result.screenshots!.length} image(s). Read any tables, numbers, or text visually present in the images.]\\n`;\r\n        }\r\n        \r\n        resultText += `Content: ${content}\\n`;\r\n        \r\n        return resultText;\r\n      })\r\n      .join('\\n---\\n');\r\n\r\n    // Check if the query is asking for comprehensive information (like lists of faculty/trainings)\r\n    const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                 query.toLowerCase().includes('all') ||\r\n                                 query.toLowerCase().includes('every') ||\r\n                                 query.toLowerCase().includes('faculty') ||\r\n                                 query.toLowerCase().includes('training') ||\r\n                                 query.toLowerCase().includes('seminar') ||\r\n                                 query.toLowerCase().includes('attended') ||\r\n                                 query.toLowerCase().includes('presentation') ||\r\n                                 query.toLowerCase().includes('research') ||\r\n                                 (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                 (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                 (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                 (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n\r\n    // Create the prompt with specific instructions for comprehensive queries\r\n    const prompt = options.customPrompt || `Based on the following documents, provide a clear, direct answer to the user's query. If the documents don't contain the information needed to answer the query, state this clearly.\r\n\r\nDocuments:\r\n${context}\r\n\r\nUser Query: ${query}\r\n\r\n${isComprehensiveQuery ? `### SPECIAL INSTRUCTION FOR COMPREHENSIVE QUERIES: When the user asks for a list of items (such as faculty and their trainings/seminars), you MUST provide ALL the information found in the documents. Do not summarize or abbreviate. If multiple documents contain relevant information, combine and present ALL the data from all documents. Use a clear format like bullet points or structured lists to make the information easy to read. CRITICAL: If you state that you are providing a list, you MUST actually provide the complete list content. Do not just say \"Here is the list...\" without providing the actual items in the list. READ EVERY DOCUMENT CAREFULLY and extract ALL relevant information BEFORE forming your response. Do not stop at the first few items you find - continue reading through all documents to ensure you have collected all relevant information.` : ''}\r\n\r\nPlease provide a straightforward, direct answer to the query based on the provided documents. Focus on information that directly addresses the question. If the information is not available in the documents, say so clearly.`;\r\n\r\n    // Generate content using the model\r\n    const completion = await this.openai.chat.completions.create({\r\n      model: this.config.model!,\r\n      messages: [\r\n        {\r\n          role: 'user',\r\n          content: prompt\r\n        }\r\n      ],\r\n      temperature: this.config.generationConfig?.temperature,\r\n      max_tokens: this.config.generationConfig?.maxOutputTokens,\r\n      top_p: this.config.generationConfig?.topP,\r\n    });\r\n\r\n    return completion.choices[0].message.content || '';\r\n }\r\n\r\n  /**\r\n   * Generate a multimodal response using search results that may include visual content\r\n   */\r\n  private async generateMultimodalResponse(\r\n    query: string,\r\n    searchResults: SearchResult[],\r\n    options: GenerationOptions\r\n  ): Promise<string> {\r\n    // Check if the model supports image inputs by checking the model name\r\n    const isImageSupported = this.config.model && (\r\n      this.config.model.includes('vl') ||\r\n      this.config.model.includes('vision') ||\r\n      this.config.model.includes('106') ||  // newer models often support images\r\n      this.config.model.includes('1106-preview') ||\r\n      this.config.model.includes('4-turbo') ||\r\n      this.config.model.includes('4o')\r\n    );\r\n    \r\n    // If image input is not supported by this model, fall back to text-only\r\n    if (!isImageSupported) {\r\n      console.log(`Model ${this.config.model} does not support image input, falling back to text-only generation`);\r\n      return await this.generateTextOnlyResponse(query, searchResults, options);\r\n    }\r\n\r\n    // Check if the query is asking for comprehensive information (like lists of faculty/trainings)\r\n    const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                query.toLowerCase().includes('all') ||\r\n                                query.toLowerCase().includes('every') ||\r\n                                query.toLowerCase().includes('faculty') ||\r\n                                query.toLowerCase().includes('training') ||\r\n                                query.toLowerCase().includes('seminar') ||\r\n                                query.toLowerCase().includes('attended') ||\r\n                                query.toLowerCase().includes('presentation') ||\r\n                                query.toLowerCase().includes('research') ||\r\n                                (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n\r\n    // Format the search results into a context string with visual content\r\n    const multimodalContent: Array<any> = [];\r\n    \r\n    multimodalContent.push({\r\n      type: 'text',\r\n      text: `\r\nYou are an intelligent assistant capable of reading documents and extracting specific details.\r\nYour goal is to answer the user's question accurately based ONLY on the provided document images.\r\n\r\n### DATA EXTRACTION RULES:\r\n1. **Read the Visuals:** The documents may contain tables, lists, or spreadsheets. Scan them carefully row-by-row.\r\n2. **Be Thorough:** If the user asks for a list (e.g., \"all faculty\"), extract EVERY name you see in the document images. Do not summarize.\r\n3. ** OCR Handling:** If text is slightly blurry, use your best judgment to correct obvious spelling errors (e.g., interpret \"M@rk\" as \"Mark\").\r\n\r\n### OUTPUT FORMATTING:\r\nIf the data involves multiple items (like names and trainings), you must use a **Nested Bullet List** format:\r\n\r\n* **Name of Person**\r\n * Training Title A\r\n * Training Title B\r\n\r\nIf the answer is simple text, use a natural paragraph.\r\n\r\n${isComprehensiveQuery ? `### SPECIAL INSTRUCTION FOR COMPREHENSIVE QUERIES: When the user asks for a list of items (such as faculty and their trainings/seminars), you MUST provide ALL the information found in the documents. Do not summarize or abbreviate. If multiple documents contain relevant information, combine and present ALL the data from all documents. Use a clear format like bullet points or structured lists to make the information easy to read. CRITICAL: If you state that you are providing a list, you MUST actually provide the complete list content. Do not just say \"Here is the list...\" without providing the actual items in the list. READ EVERY DOCUMENT CAREFULLY and extract ALL relevant information BEFORE forming your response. Do not stop at the first few items you find - continue reading through all documents to ensure you have collected all relevant information.` : ''}\r\n-------------------------------------------------------\r\n`\r\n    });\r\n\r\n    // Process each result to provide to the model\r\n    for (const result of searchResults.slice(0, 6)) {\r\n      \r\n      const hasVisuals = result.screenshots && result.screenshots.length > 0;\r\n      const hasText = result.extractedText && result.extractedText.trim().length > 0;\r\n\r\n      // Divider\r\n      multimodalContent.push({\r\n        type: 'text',\r\n        text: `\\n\\n=== Document: \"${result.title}\" ===\\n`\r\n      });\r\n\r\n      // 1. Provide the Visuals (Universal for PDF, PNG, Excel, etc.)\r\n      if (hasVisuals && result.screenshots) {\r\n        for (const screenshot of result.screenshots) {\r\n            \r\n        // MAGIC FIX: Detect Type from the string signature\r\n        // Colivara converts PDFs to PNG screenshots, so we must detect 'iVBOR'\r\n        let realMimeType = 'image/jpeg';\r\n        if (typeof screenshot === 'string') {\r\n            if (screenshot.startsWith('iVBOR')) {\r\n                realMimeType = 'image/png'; // <--- This is the key fix for your PDFs\r\n            } else if (screenshot.startsWith('/9j/')) {\r\n                realMimeType = 'image/jpeg';\r\n            } else if (screenshot.startsWith('iVBO')) {\r\n                realMimeType = 'image/png';\r\n            }\r\n        }\r\n\r\n        console.log(`Sending to Qwen as: ${realMimeType}`); // Debug log\r\n\r\n        // Convert base64 image to data URL format\r\n        const dataUrl = `data:${realMimeType};base64,${screenshot}`;\r\n        \r\n        multimodalContent.push({\r\n          type: 'image_url',\r\n          image_url: {\r\n            url: dataUrl\r\n          }\r\n        });\r\n        }\r\n        // Prompt for Visuals\r\n        multimodalContent.push({\r\n          type: 'text',\r\n          text: `\\n[VISUAL CONTENT: The above image contains the document content. Extract relevant information to answer: \"${query}\"]\\n`\r\n        });\r\n      }\r\n\r\n      // 2. Provide the Text (Universal for PDF, Word, etc.)\r\n      if (hasText) {\r\n        multimodalContent.push({\r\n          type: 'text',\r\n          text: `\\n[TEXT CONTENT: ${result.extractedText}]\\n`\r\n        });\r\n      } else {\r\n        // 3. Handle \"Visual Only\" Files (Scans/Images)\r\n        multimodalContent.push({\r\n          type: 'text',\r\n          text: `\\n[NO TEXT EXTRACTED: Focus on visual content to answer: \"${query}\"]\\n`\r\n        });\r\n      }\r\n    }\r\n\r\n    // Add final instruction to ensure the model responds directly to the query\r\n    multimodalContent.push({\r\n      type: 'text',\r\n      text: `\\n\\n${isComprehensiveQuery ? `### SPECIAL INSTRUCTION FOR COMPREHENSIVE QUERIES: When the user asks for a list of items (such as faculty and their trainings/seminars), you MUST provide ALL the information found in the documents. Do not summarize or abbreviate. If multiple documents contain relevant information, combine and present ALL the data from all documents. Use a clear format like bullet points or structured lists to make the information easy to read. CRITICAL: If you state that you are providing a list, you MUST actually provide the complete list content. Do not just say \"Here is the list...\" without providing the actual items in the list. READ EVERY DOCUMENT CAREFULLY and extract ALL relevant information BEFORE forming your response. Do not stop at the first few items you find - continue reading through all documents to ensure you have collected all relevant information.` : ''}\\n\\nBased on the above documents, provide a clear, direct answer to this query: \"${query}\". Answer the question directly using specific information from the documents. If the documents don't contain the answer, say so clearly.`\r\n    });\r\n\r\n    try {\r\n      // Generate content using the model\r\n      const completion = await this.openai.chat.completions.create({\r\n        model: this.config.model!,\r\n        messages: [\r\n          {\r\n            role: 'user',\r\n            content: multimodalContent\r\n          }\r\n        ],\r\n        temperature: this.config.generationConfig?.temperature,\r\n        max_tokens: this.config.generationConfig?.maxOutputTokens,\r\n        top_p: this.config.generationConfig?.topP,\r\n      });\r\n\r\n      return completion.choices[0].message.content || '';\r\n    } catch (error: any) {\r\n      // If image input fails, fall back to text-only processing\r\n      if (error.status === 404 && error.message.includes('image input')) {\r\n        console.log('Image input not supported by model, falling back to text-only generation');\r\n        return await this.generateTextOnlyResponse(query, searchResults, options);\r\n      }\r\n      throw error;\r\n    }\r\n }\r\n\r\n  /**\r\n   * Generate insights from search results\r\n   * @param query User's search query\r\n   * @param searchResults Results from Colivara semantic search\r\n   * @param userId User identifier for rate limiting\r\n   */\r\n async generateInsights(\r\n    query: string,\r\n    searchResults: SearchResult[],\r\n    userId?: string\r\n  ): Promise<{\r\n    summary: string;\r\n    keyPoints: string[];\r\n    sources: Array<{ title: string; documentId: string; confidence: number }>;\r\n }> {\r\n    const startTime = Date.now();\r\n    try {\r\n      // Use user ID for rate limiting, fallback to a general identifier if not provided\r\n      const identifier = userId || 'anonymous';\r\n      \r\n      // Check if request is allowed based on rate limiting\r\n      if (!this.configService.isRequestAllowed(identifier)) {\r\n        const remainingRequests = this.configService.getRemainingRequests(identifier);\r\n        const resetTime = this.configService.getResetTime(identifier);\r\n        const resetTimeFormatted = new Date(resetTime).toLocaleTimeString();\r\n        \r\n        const error = new Error(\r\n          `Rate limit exceeded. You can make ${remainingRequests} more requests after ${resetTimeFormatted}.`\r\n        );\r\n        \r\n        // Track the failed request\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          false,\r\n          error.message,\r\n          this.config.model\r\n        );\r\n        \r\n        throw error;\r\n      }\r\n\r\n      const maxResults = 6;\r\n      const limitedResults = searchResults.slice(0, maxResults);\r\n\r\n      if (limitedResults.length === 0) {\r\n        const result = {\r\n          summary: \"No relevant documents found to generate insights.\",\r\n          keyPoints: [],\r\n          sources: [],\r\n        };\r\n        \r\n        // Track the successful request with no results\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          true,\r\n          undefined,\r\n          this.config.model\r\n        );\r\n        \r\n        return result;\r\n      }\r\n\r\n      // Format the search results into a context string with visual content for insights\r\n      const multimodalContent: Array<any> = [];\r\n      \r\n      multimodalContent.push({\r\n        type: 'text',\r\n        text: `\r\nYou are an intelligent assistant capable of reading documents and extracting specific details.\r\nYour goal is to answer the user's question accurately based ONLY on the provided document images.\r\n\r\n### DATA EXTRACTION RULES:\r\n1. **Read the Visuals:** The documents may contain tables, lists, or spreadsheets. Scan them carefully row-by-row.\r\n2. **Be Thorough:** If the user asks for a list (e.g., \"all faculty\"), extract EVERY name you see in the document images. Do not summarize.\r\n3. ** OCR Handling:** If text is slightly blurry, use your best judgment to correct obvious spelling errors (e.g., interpret \"M@rk\" as \"Mark\").\r\n\r\n### OUTPUT FORMATTING:\r\nIf the data involves multiple items (like names and trainings), you must use a **Nested Bullet List** format:\r\n\r\n* **Name of Person**\r\n  * Training Title A\r\n  * Training Title B\r\n\r\nIf the answer is simple text, use a natural paragraph.\r\n-------------------------------------------------------\r\n`\r\n      });\r\n      \r\n      // Process each result\r\n      for (const result of limitedResults) {\r\n        const hasVisuals = result.screenshots && result.screenshots.length > 0;\r\n        const hasText = result.extractedText && result.extractedText.trim().length > 0;\r\n        const title = result.title || 'Untitled Document';\r\n        const confidence = result.confidenceScore || 0;\r\n        \r\n        // Add document header\r\n        multimodalContent.push({\r\n          type: 'text',\r\n          text: `\\n\\n=== Document: \"${title}\" (relevance: ${(confidence * 100).toFixed(1)}%) ===\\n`\r\n        });\r\n\r\n        // 1. Provide the Visuals (Universal for PDF, PNG, Excel, etc.)\r\n        if (hasVisuals && result.screenshots) {\r\n          for (const screenshot of result.screenshots) {\r\n              \r\n          // MAGIC FIX: Detect Type from the string signature\r\n          let realMimeType = 'image/jpeg';\r\n          if (typeof screenshot === 'string') {\r\n              if (screenshot.startsWith('iVBOR')) {\r\n                  realMimeType = 'image/png';\r\n              } else if (screenshot.startsWith('/9j/')) {\r\n                  realMimeType = 'image/jpeg';\r\n              } else if (screenshot.startsWith('iVBO')) {\r\n                  realMimeType = 'image/png';\r\n              }\r\n          }\r\n\r\n          console.log(`Sending to Qwen as: ${realMimeType}`); // Debug log\r\n\r\n          // Convert base64 image to data URL format\r\n          const dataUrl = `data:${realMimeType};base64,${screenshot}`;\r\n          \r\n          multimodalContent.push({\r\n            type: 'image_url',\r\n            image_url: {\r\n              url: dataUrl\r\n            }\r\n          });\r\n          }\r\n          // Prompt for Visuals\r\n          multimodalContent.push({\r\n            type: 'text',\r\n            text: `\\n[VISUAL CONTENT: The above image contains document information. Extract data relevant to: \"${query}\"]\\n`\r\n          });\r\n        }\r\n\r\n        // 2. Provide the Text (Universal for PDF, Word, etc.)\r\n        if (hasText) {\r\n          multimodalContent.push({\r\n            type: 'text',\r\n            text: `\\n[TEXT CONTENT: ${result.extractedText}]\\n`\r\n          });\r\n        } else {\r\n          // 3. Handle \"Visual Only\" Files (Scans/Images)\r\n          multimodalContent.push({\r\n            type: 'text',\r\n            text: `\\n[NO TEXT EXTRACTED: Focus on visual content to answer: \"${query}\"]\\n`\r\n          });\r\n        }\r\n      }\r\n\r\n      // Check if the query is asking for comprehensive information (like lists of faculty/trainings)\r\n      const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                  query.toLowerCase().includes('all') ||\r\n                                  query.toLowerCase().includes('every') ||\r\n                                  query.toLowerCase().includes('faculty') ||\r\n                                  query.toLowerCase().includes('training') ||\r\n                                  query.toLowerCase().includes('seminar') ||\r\n                                  query.toLowerCase().includes('attended') ||\r\n                                  query.toLowerCase().includes('presentation') ||\r\n                                  query.toLowerCase().includes('research') ||\r\n                                  (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                  (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                  (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                  (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n\r\n      // Add special instruction for comprehensive queries\r\n      multimodalContent.push({\r\n        type: 'text',\r\n        text: `\\n\\n${isComprehensiveQuery ? `### SPECIAL INSTRUCTION FOR COMPREHENSIVE QUERIES: When the user asks for a list of items (such as faculty and their trainings/seminars), you MUST provide ALL the information found in the documents. Do not summarize or abbreviate. If multiple documents contain relevant information, combine and present ALL the data from all documents. Use a clear format like bullet points or structured lists to make the information easy to read. CRITICAL: If you state that you are providing a list, you MUST actually provide the complete list content. Do not just say \"Here is the list...\" without providing the actual items in the list. READ EVERY DOCUMENT CAREFULLY and extract ALL relevant information BEFORE forming your response. Do not stop at the first few items you find - continue reading through all documents to ensure you have collected all relevant information.` : ''}\\n\\nBased on the above documents, provide a clear, direct answer to \"${query}\". Format your response as JSON with the following structure: { \"summary\": \"Direct answer to the user's query based on document content\", \"keyPoints\": [\"Concise points that directly address the query\", \"Relevant information from documents\"], \"sources\": [ { \"title\": \"Document title\", \"documentId\": \"Document ID if available\", \"confidence\": \"Confidence score between 0 and 1\" } ] }`\r\n      });\r\n\r\n      const prompt = `Based on the following documents, please provide a summary, key points, and sources related to the query: ${query}\r\n\r\nDocuments:\r\n[MULTIMODAL CONTENT PROVIDED IN THE REQUEST]\r\n\r\nPlease format your response as JSON with the following structure:\r\n{\r\n \"summary\": \"Brief summary of the documents in relation to the query\",\r\n \"keyPoints\": [\"List of key points from the documents\", \"Each point should be concise and informative\"],\r\n \"sources\": [\r\n   {\r\n     \"title\": \"Document title\",\r\n     \"documentId\": \"Document ID if available\",\r\n     \"confidence\": \"Confidence score between 0 and 1\"\r\n   }\r\n ]\r\n}`;\r\n\r\n      // Check if the model supports image inputs by checking the model name\r\n      const isImageSupported = this.config.model && (\r\n        this.config.model.includes('vl') ||\r\n        this.config.model.includes('vision') ||\r\n        this.config.model.includes('106') ||  // newer models often support images\r\n        this.config.model.includes('1106-preview') ||\r\n        this.config.model.includes('4-turbo') ||\r\n        this.config.model.includes('4o')\r\n      );\r\n      \r\n      // If image input is not supported by this model, fall back to text-only\r\n      if (!isImageSupported) {\r\n        console.log(`Model ${this.config.model} does not support image input, falling back to text-only generation for insights`);\r\n        // Use text-only processing by calling generateTextOnlyResponse and formatting appropriately\r\n        const textResponse = await this.generateTextOnlyResponse(query, limitedResults, {});\r\n        // Return a structured response similar to what the JSON format would provide\r\n        const fallbackResult = {\r\n          summary: textResponse,\r\n          keyPoints: [textResponse.substring(0, 200)],\r\n          sources: limitedResults.map(result => ({\r\n            title: result.title || 'Untitled Document',\r\n            documentId: result.documentId || '',\r\n            confidence: result.confidenceScore || 0\r\n          }))\r\n        };\r\n        \r\n        // Track the successful request with fallback\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          true,\r\n          'Fallback to text-only due to image input not supported',\r\n          this.config.model\r\n        );\r\n        \r\n        return fallbackResult;\r\n      }\r\n\r\n      let completion;\r\n      try {\r\n        completion = await this.openai.chat.completions.create({\r\n          model: this.config.model!,\r\n          messages: [\r\n            {\r\n              role: 'user',\r\n              content: multimodalContent\r\n            }\r\n          ],\r\n          temperature: this.config.generationConfig?.temperature,\r\n          max_tokens: this.config.generationConfig?.maxOutputTokens,\r\n          top_p: this.config.generationConfig?.topP,\r\n          response_format: { type: \"json_object\" }\r\n        });\r\n      } catch (error: any) {\r\n        // If image input fails, fall back to text-only processing\r\n        if (error.status === 404 && error.message.includes('image input')) {\r\n          console.log('Image input not supported by model, falling back to text-only generation for insights');\r\n          // Use text-only processing by calling generateTextOnlyResponse and formatting appropriately\r\n          const textResponse = await this.generateTextOnlyResponse(query, limitedResults, {});\r\n          // Return a structured response similar to what the JSON format would provide\r\n          const fallbackResult = {\r\n            summary: textResponse,\r\n            keyPoints: [textResponse.substring(0, 200)],\r\n            sources: limitedResults.map(result => ({\r\n              title: result.title || 'Untitled Document',\r\n              documentId: result.documentId || '',\r\n              confidence: result.confidenceScore || 0\r\n            }))\r\n          };\r\n          \r\n          // Track the successful request with fallback\r\n          this.monitoringService.trackGeneration(\r\n            userId || 'unknown',\r\n            query,\r\n            Date.now() - startTime,\r\n            true,\r\n            'Fallback to text-only due to image input error',\r\n            this.config.model\r\n          );\r\n          \r\n          return fallbackResult;\r\n        }\r\n        throw error;\r\n      }\r\n\r\n      const text = completion.choices[0].message.content || '';\r\n      \r\n      // Parse the JSON response\r\n      try {\r\n        const parsed = JSON.parse(text);\r\n        \r\n        // Track the successful request\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          true,\r\n          undefined,\r\n          this.config.model\r\n        );\r\n        \r\n        return parsed;\r\n      } catch (parseError) {\r\n        console.error('Error parsing Qwen JSON response:', parseError);\r\n        // Fallback: return a basic structure\r\n        const fallbackResult = {\r\n          summary: text.substring(0, 500) + (text.length > 50 ? '...' : ''),\r\n          keyPoints: [text.substring(0, 200)],\r\n          sources: limitedResults.map(result => ({\r\n            title: result.title || 'Untitled Document',\r\n            documentId: result.documentId || '',\r\n            confidence: result.confidenceScore || 0\r\n          }))\r\n        };\r\n        \r\n        // Track the successful request with fallback\r\n        this.monitoringService.trackGeneration(\r\n          userId || 'unknown',\r\n          query,\r\n          Date.now() - startTime,\r\n          true,\r\n          'Fallback due to JSON parsing error',\r\n          this.config.model\r\n        );\r\n        \r\n        return fallbackResult;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error generating insights with Qwen:', error);\r\n      \r\n      // Track the failed request\r\n      this.monitoringService.trackGeneration(\r\n        userId || 'unknown',\r\n        query,\r\n        Date.now() - startTime,\r\n        false,\r\n        error instanceof Error ? error.message : 'Unknown error',\r\n        this.config.model\r\n      );\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Check if the service is properly initialized and API key is valid\r\n   */\r\n  async healthCheck(): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    try {\r\n      // Try to get model information as a basic health check\r\n      const completion = await this.openai.chat.completions.create({\r\n        model: this.config.model!,\r\n        messages: [\r\n          {\r\n            role: 'user',\r\n            content: 'Hello'\r\n          }\r\n        ],\r\n        temperature: 0,\r\n        max_tokens: 5,\r\n      });\r\n      \r\n      // Track the successful health check\r\n      this.monitoringService.logMetric({\r\n        endpoint: 'qwen-health-check',\r\n        responseTime: Date.now() - startTime,\r\n        success: true,\r\n        model: this.config.model\r\n      });\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Qwen service health check failed:', error);\r\n      \r\n      // Track the failed health check\r\n      this.monitoringService.logMetric({\r\n        endpoint: 'qwen-health-check',\r\n        responseTime: Date.now() - startTime,\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        model: this.config.model\r\n      });\r\n      \r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default QwenGenerationService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3163, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/utils/super-mapper.ts"],"sourcesContent":["/**\r\n * Super Mapper - A utility to handle document field mapping across different data sources\r\n * This solution addresses the need to look for document data under various possible field names\r\n */\r\n\r\ninterface DocumentFieldMapping {\r\n  // Title-related fields\r\n title?: string;\r\n  document_title?: string;\r\n  originalName?: string;\r\n  name?: string;\r\n  \r\n  // Description-related fields\r\n  description?: string;\r\n  content?: string;\r\n  text?: string;\r\n  summary?: string;\r\n  \r\n  // File-related fields\r\n  fileName?: string;\r\n  file_name?: string;\r\n  originalFileName?: string;\r\n  original_file_name?: string;\r\n  fileUrl?: string;\r\n  file_url?: string;\r\n  \r\n  // Other common fields\r\n  id?: string;\r\n  documentId?: string;\r\n  document_id?: string;\r\n  category?: string;\r\n  tags?: string[];\r\n  uploadedBy?: string;\r\n  uploaded_by?: string;\r\n  uploadedAt?: string | Date;\r\n uploaded_at?: string | Date;\r\n  fileType?: string;\r\n  file_type?: string;\r\n  fileSize?: number;\r\n  file_size?: number;\r\n}\r\n\r\n/**\r\n * Generic function to extract a value from an object trying multiple possible field names\r\n */\r\nfunction extractValue<T>(obj: any, possibleFieldNames: string[]): T | undefined {\r\n  for (const field of possibleFieldNames) {\r\n    if (obj && obj[field] !== undefined && obj[field] !== null) {\r\n      return obj[field];\r\n    }\r\n  }\r\n return undefined;\r\n}\r\n\r\n/**\r\n * Super Mapper class to handle document field mapping\r\n */\r\nclass SuperMapper {\r\n  /**\r\n   * Maps document data from various sources to a consistent format\r\n   * Tries multiple possible field names for each property\r\n   */\r\n  static mapDocumentData(rawData: any): DocumentFieldMapping {\r\n    if (!rawData) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      // Title mapping - try various possible field names for document title\r\n      title: extractValue<string>(rawData, [\r\n        'title', 'document_title', 'originalName', 'name', \r\n        'fileName', 'file_name', 'documentName', 'document_name'\r\n      ]),\r\n      \r\n      // Description mapping\r\n      description: extractValue<string>(rawData, [\r\n        'description', 'content', 'text', 'summary', \r\n        'desc', 'body', 'details'\r\n      ]),\r\n      \r\n      // File name mapping\r\n      fileName: extractValue<string>(rawData, [\r\n        'fileName', 'file_name', 'originalFileName', \r\n        'original_file_name', 'filename', 'name'\r\n      ]),\r\n      \r\n      // File URL mapping\r\n      fileUrl: extractValue<string>(rawData, [\r\n        'fileUrl', 'file_url', 'url', 'documentUrl', \r\n        'document_url', 'source', 'path'\r\n      ]),\r\n      \r\n      // ID mapping\r\n      id: extractValue<string>(rawData, [\r\n        'id', 'documentId', 'document_id', 'docId', \r\n        'doc_id', '_id', 'identifier'\r\n      ]),\r\n      \r\n      // Category mapping\r\n      category: extractValue<string>(rawData, [\r\n        'category', 'category_name', 'type', 'documentType', \r\n        'document_type', 'classification'\r\n      ]),\r\n      \r\n      // Tags mapping\r\n      tags: extractValue<string[]>(rawData, [\r\n        'tags', 'tag_list', 'tagList', 'keywords', \r\n        'keyword_list', 'keywordList'\r\n      ]),\r\n      \r\n      // Uploaded by mapping\r\n      uploadedBy: extractValue<string>(rawData, [\r\n        'uploadedBy', 'uploaded_by', 'uploadedByUser', \r\n        'uploaded_by_user', 'author', 'creator', 'uploader'\r\n      ]),\r\n      \r\n      // Upload date mapping\r\n      uploadedAt: extractValue<Date | string>(rawData, [\r\n        'uploadedAt', 'uploaded_at', 'uploadDate', \r\n        'upload_date', 'createdAt', 'created_at', 'date'\r\n      ]),\r\n      \r\n      // File type mapping\r\n      fileType: extractValue<string>(rawData, [\r\n        'fileType', 'file_type', 'mimeType', \r\n        'mime_type', 'type', 'extension'\r\n      ]),\r\n      \r\n      // File size mapping\r\n      fileSize: extractValue<number>(rawData, [\r\n        'fileSize', 'file_size', 'size', \r\n        'fileSizeBytes', 'file_size_bytes'\r\n      ]),\r\n    };\r\n }\r\n\r\n  /**\r\n   * Gets a specific field value trying multiple possible names\r\n   */\r\n  static getFieldValue(obj: any, fieldPath: string | string[]): any {\r\n    if (!obj) return undefined;\r\n    \r\n    // If fieldPath is a string, split it by dots to handle nested properties\r\n    const fields = Array.isArray(fieldPath) ? fieldPath : fieldPath.split('.');\r\n    \r\n    // If we have a single field name, try multiple possible variants\r\n    if (fields.length === 1) {\r\n      const fieldName = fields[0];\r\n      \r\n      // Define possible variations for common field names\r\n      const possibleNames: Record<string, string[]> = {\r\n        title: ['title', 'document_title', 'originalName', 'name', 'fileName', 'file_name', 'documentName'],\r\n        description: ['description', 'content', 'text', 'summary', 'desc', 'body'],\r\n        fileName: ['fileName', 'file_name', 'originalFileName', 'original_file_name', 'filename'],\r\n        fileUrl: ['fileUrl', 'file_url', 'url', 'documentUrl', 'document_url', 'source'],\r\n        id: ['id', 'documentId', 'document_id', 'docId', 'doc_id', '_id'],\r\n        category: ['category', 'category_name', 'type', 'documentType', 'document_type'],\r\n        tags: ['tags', 'tag_list', 'tagList', 'keywords', 'keyword_list', 'keywordList'],\r\n        uploadedBy: ['uploadedBy', 'uploaded_by', 'uploadedByUser', 'uploaded_by_user', 'author', 'creator'],\r\n        uploadedAt: ['uploadedAt', 'uploaded_at', 'uploadDate', 'upload_date', 'createdAt', 'created_at'],\r\n        fileType: ['fileType', 'file_type', 'mimeType', 'mime_type', 'type', 'extension'],\r\n        fileSize: ['fileSize', 'file_size', 'size', 'fileSizeBytes', 'file_size_bytes'],\r\n      };\r\n      \r\n      const possibleFieldNames = possibleNames[fieldName] || [fieldName];\r\n      return extractValue(obj, possibleFieldNames);\r\n    }\r\n    \r\n    // For nested properties, try to access the path directly first\r\n    let result = obj;\r\n    for (const field of fields) {\r\n      if (result && result[field] !== undefined) {\r\n        result = result[field];\r\n      } else {\r\n        result = undefined;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (result !== undefined) {\r\n      return result;\r\n    }\r\n    \r\n    // If direct access fails, try common variations of the first field\r\n    const firstField = fields[0];\r\n    const remainingPath = fields.slice(1).join('.');\r\n    \r\n    const possibleNames: Record<string, string[]> = {\r\n      metadata: ['metadata', 'meta', 'data', 'info', 'document_metadata'],\r\n      document: ['document', 'doc', 'result', 'item', 'data', 'record'],\r\n    };\r\n    \r\n    const possibleFieldNames = possibleNames[firstField] || [firstField];\r\n    \r\n    for (const possibleName of possibleFieldNames) {\r\n      const nestedObj = obj[possibleName];\r\n      if (nestedObj) {\r\n        // Recursively call for the remaining path\r\n        const nestedResult = this.getFieldValue(nestedObj, remainingPath);\r\n        if (nestedResult !== undefined) {\r\n          return nestedResult;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return undefined;\r\n }\r\n\r\n  /**\r\n   * Creates a mapped document object with standardized field names\r\n   */\r\n  static createStandardDocument(rawData: any): any {\r\n    const mappedData = this.mapDocumentData(rawData);\r\n    \r\n    // Create a standard document object using the mapped values\r\n    // Only apply defaults if no value was found from any of the possible field names\r\n    return {\r\n      ...rawData, // Include original data to preserve existing properties\r\n      id: mappedData.id || rawData.id || rawData.documentId || (rawData.document ? rawData.document.id : undefined),\r\n      title: mappedData.title || rawData.title || rawData.originalName || rawData.name || 'Untitled Document',\r\n      description: mappedData.description || rawData.description || rawData.content || rawData.text || rawData.summary || '',\r\n      fileName: mappedData.fileName || rawData.fileName || rawData.originalFileName || rawData.name || 'unknown.pdf',\r\n      fileUrl: mappedData.fileUrl || rawData.fileUrl || rawData.url || rawData.documentUrl || rawData.source,\r\n      category: mappedData.category || rawData.category || rawData.type || rawData.documentType || 'Uncategorized',\r\n      tags: mappedData.tags || rawData.tags || rawData.keywords || [],\r\n      uploadedBy: mappedData.uploadedBy || rawData.uploadedBy || rawData.author || rawData.creator || rawData.uploader || 'Unknown',\r\n      uploadedAt: mappedData.uploadedAt ? new Date(mappedData.uploadedAt as string) :\r\n                  rawData.uploadedAt ? new Date(rawData.uploadedAt) :\r\n                  rawData.uploadDate ? new Date(rawData.uploadDate) :\r\n                  rawData.createdAt ? new Date(rawData.createdAt) :\r\n                  new Date(),\r\n      fileType: mappedData.fileType || rawData.fileType || rawData.mimeType || rawData.type || 'unknown',\r\n      fileSize: mappedData.fileSize || rawData.fileSize || rawData.size || 0,\r\n    };\r\n  }\r\n}\r\n\r\nexport default SuperMapper;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3476, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/utils/document-utils.ts"],"sourcesContent":["/**\r\n * Utility functions for handling document titles and names\r\n */\r\n\r\n/**\r\n * Cleans a document title by removing the alphanumeric prefix that is added during Colivara processing\r\n * @param title The original document title that may contain an alphanumeric prefix\r\n * @returns The cleaned document title with the prefix removed\r\n * \r\n * Example: \r\n * Input: \"cmicq4gtx0001lvg4tzbcpqgz_QPRO - 3RD QUARTER - JULY TO SEPTEMBER 2025.pdf\"\r\n * Output: \"QPRO - 3RD QUARTER - JULY TO SEPTEMBER 2025.pdf\"\r\n */\r\nexport function cleanDocumentTitle(title: string): string {\r\n  if (!title) {\r\n    return title;\r\n  }\r\n\r\n  // Pattern to match the alphanumeric prefix followed by an underscore\r\n  // This matches the pattern: alphanumeric_string_original_filename\r\n  // The prefix is typically a longer random alphanumeric string (like a UUID), followed by an underscore\r\n  // Then followed by the actual filename that starts with a non-underscore character\r\n  const prefixPattern = /^[a-zA-Z0-9]{10,}_([^_].*)$/;\r\n  \r\n  const match = title.match(prefixPattern);\r\n  \r\n  if (match) {\r\n    // Return the part after the underscore\r\n    return match[1];\r\n  }\r\n  \r\n  // If no match, return the original title\r\n return title;\r\n}\r\n\r\n/**\r\n * Cleans multiple document titles\r\n * @param titles Array of document titles to clean\r\n * @returns Array of cleaned document titles\r\n */\r\nexport function cleanDocumentTitles(titles: string[]): string[] {\r\n  return titles.map(title => cleanDocumentTitle(title));\r\n}"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;;;;;;CAQC;;;;;;AACM,SAAS,mBAAmB,KAAa;IAC9C,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,qEAAqE;IACrE,kEAAkE;IAClE,uGAAuG;IACvG,mFAAmF;IACnF,MAAM,gBAAgB;IAEtB,MAAM,QAAQ,MAAM,KAAK,CAAC;IAE1B,IAAI,OAAO;QACT,uCAAuC;QACvC,OAAO,KAAK,CAAC,EAAE;IACjB;IAEA,yCAAyC;IAC1C,OAAO;AACR;AAOO,SAAS,oBAAoB,MAAgB;IAClD,OAAO,OAAO,GAAG,CAAC,CAAA,QAAS,mBAAmB;AAChD"}},
    {"offset": {"line": 3516, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/redis-service.ts"],"sourcesContent":["import { Redis } from '@upstash/redis';\r\n\r\nclass RedisService {\r\n  public redis: Redis;\r\n\r\n  constructor() {\r\n    this.redis = new Redis({\r\n      url: process.env.UPSTASH_REDIS_REST_URL!,\r\n      token: process.env.UPSTASH_REDIS_REST_TOKEN!,\r\n    });\r\n  }\r\n\r\n  // Generic methods for common operations\r\n  async get<T>(key: string): Promise<T | null> {\r\n    try {\r\n      const value = await this.redis.get(key);\r\n      return value as T | null;\r\n    } catch (error) {\r\n      console.error(`Error getting key ${key}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, value: any, ttl?: number): Promise<boolean> {\r\n    try {\r\n      if (ttl) {\r\n        await this.redis.setex(key, ttl, value);\r\n      } else {\r\n        await this.redis.set(key, value);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Error setting key ${key}:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async del(key: string): Promise<boolean> {\r\n    try {\r\n      await this.redis.del(key);\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Error deleting key ${key}:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async exists(key: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.redis.exists(key);\r\n      return result === 1;\r\n    } catch (error) {\r\n      console.error(`Error checking key ${key}:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async expire(key: string, ttl: number): Promise<boolean> {\r\n    try {\r\n      await this.redis.expire(key, ttl);\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Error setting expiration for key ${key}:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async keys(pattern: string): Promise<string[]> {\r\n    try {\r\n      return await this.redis.keys(pattern);\r\n    } catch (error) {\r\n      console.error(`Error getting keys with pattern ${pattern}:`, error);\r\n      return [];\r\n    }\r\n  }\r\n}\r\n\r\nexport const redisService = new RedisService();\r\nexport default RedisService;"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM;IACG,MAAa;IAEpB,aAAc;QACZ,IAAI,CAAC,KAAK,GAAG,IAAI,wKAAK,CAAC;YACrB,KAAK,QAAQ,GAAG,CAAC,sBAAsB;YACvC,OAAO,QAAQ,GAAG,CAAC,wBAAwB;QAC7C;IACF;IAEA,wCAAwC;IACxC,MAAM,IAAO,GAAW,EAAqB;QAC3C,IAAI;YACF,MAAM,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;YACnC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC,EAAE;YAC3C,OAAO;QACT;IACF;IAEA,MAAM,IAAI,GAAW,EAAE,KAAU,EAAE,GAAY,EAAoB;QACjE,IAAI;YACF,IAAI,KAAK;gBACP,MAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK;YACnC,OAAO;gBACL,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK;YAC5B;YACA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC,EAAE;YAC3C,OAAO;QACT;IACF;IAEA,MAAM,IAAI,GAAW,EAAoB;QACvC,IAAI;YACF,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;YACrB,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC,EAAE;YAC5C,OAAO;QACT;IACF;IAEA,MAAM,OAAO,GAAW,EAAoB;QAC1C,IAAI;YACF,MAAM,SAAS,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;YACvC,OAAO,WAAW;QACpB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC,EAAE;YAC5C,OAAO;QACT;IACF;IAEA,MAAM,OAAO,GAAW,EAAE,GAAW,EAAoB;QACvD,IAAI;YACF,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK;YAC7B,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,iCAAiC,EAAE,IAAI,CAAC,CAAC,EAAE;YAC1D,OAAO;QACT;IACF;IAEA,MAAM,KAAK,OAAe,EAAqB;QAC7C,IAAI;YACF,OAAO,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAC/B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,gCAAgC,EAAE,QAAQ,CAAC,CAAC,EAAE;YAC7D,OAAO,EAAE;QACX;IACF;AACF;AAEO,MAAM,eAAe,IAAI;uCACjB"}},
    {"offset": {"line": 3597, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/search-cache-service.ts"],"sourcesContent":["import { Document } from '@/lib/api/types';\r\nimport { redisService } from './redis-service';\r\n\r\ninterface SearchResult {\r\n  documentId: string;\r\n  title: string;\r\n  content: string;\r\n  score: number;\r\n  pageNumbers: number[];\r\n  documentSection?: string;\r\n confidenceScore?: number;\r\n  snippet: string;\r\n document: Document;\r\n  visualContent?: string; // Base64 encoded visual content\r\n  extractedText?: string; // Extracted text content\r\n  screenshots?: string[]; // Array of screenshot base64 strings\r\n}\r\n\r\ninterface SearchResults {\r\n  results: SearchResult[];\r\n  total: number;\r\n query: string;\r\n processingTime: number;\r\n}\r\n\r\n// Cache configuration - TTL in seconds for Redis\r\nconst DEFAULT_CACHE_TTL = 30 * 60; // 30 minutes in seconds\r\nconst MAX_CACHE_SIZE = 50; // Maximum number of cached search results\r\n\r\n// Interface for cache metrics\r\ninterface CacheMetrics {\r\n  hits: number;\r\n  misses: number;\r\n totalRequests: number;\r\n  averageResponseTime: number;\r\n  hitRate: number;\r\n}\r\n\r\ninterface CachedSearchResult {\r\n  query: string;\r\n  unitId?: string;\r\n  category?: string;\r\n  filters?: any;\r\n  results: SearchResults;\r\n  timestamp: number;\r\n  ttl: number;\r\n}\r\n\r\nclass SearchCacheService {\r\n  private readonly maxCacheSize: number;\r\n  private metrics: CacheMetrics = {\r\n    hits: 0,\r\n    misses: 0,\r\n    totalRequests: 0,\r\n    averageResponseTime: 0,\r\n    hitRate: 0\r\n  };\r\n\r\n  constructor(maxSize: number = MAX_CACHE_SIZE) {\r\n    this.maxCacheSize = maxSize;\r\n  }\r\n\r\n /**\r\n   * Generate a cache key based on search parameters\r\n   */\r\n  private generateCacheKey(query: string, unitId?: string, category?: string, filters?: any): string {\r\n    // Ensure query is a string and handle null/undefined\r\n    const safeQuery = (query || '').toLowerCase().trim();\r\n    // Convert \"undefined\" string to proper undefined/null for consistent cache keys\r\n    const safeUnitId = (unitId === 'undefined' || unitId === undefined || unitId === null) ? 'all' : unitId;\r\n    const safeCategory = (category === 'undefined' || category === undefined || category === null) ? 'all' : category;\r\n    // Ensure filters is a valid object and stringify it safely\r\n    let filtersString = '{}';\r\n    try {\r\n      // Convert \"undefined\" string to empty object for consistent cache keys\r\n      const safeFilters = (filters === 'undefined' || filters === undefined || filters === null) ? {} : filters;\r\n      filtersString = JSON.stringify(safeFilters);\r\n    } catch (error) {\r\n      console.error('Error stringifying filters for cache key:', error);\r\n      filtersString = '{}'; // Fallback to empty object\r\n    }\r\n    \r\n    const params = [safeQuery, safeUnitId, safeCategory, filtersString];\r\n    // Create a hash-based cache key to avoid special character issues\r\n    const keyString = params.join('|');\r\n    \r\n    // Create a simple hash function to generate a consistent key\r\n    let hash = 0;\r\n    for (let i = 0; i < keyString.length; i++) {\r\n      const char = keyString.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    \r\n    // Create a readable key with the hash to ensure uniqueness\r\n    const readablePrefix = safeQuery.substring(0, 20).replace(/[^a-zA-Z0-9]/g, '_');\r\n    return `search:${readablePrefix}_${Math.abs(hash).toString(36)}`;\r\n  }\r\n\r\n  /**\r\n   * Check if a cached result exists and is still valid\r\n   */\r\n async getCachedResult(query: string, unitId?: string, category?: string, filters?: any): Promise<SearchResults | null> {\r\n    this.metrics.totalRequests++;\r\n    // Normalize parameters to handle \"undefined\" strings consistently\r\n    const normalizedUnitId = (unitId === 'undefined') ? undefined : unitId;\r\n    const normalizedCategory = (category === 'undefined') ? undefined : category;\r\n    const normalizedFilters = (filters === 'undefined') ? undefined : filters;\r\n    const cacheKey = this.generateCacheKey(query, normalizedUnitId, normalizedCategory, normalizedFilters);\r\n    \r\n    const cachedResult = await redisService.get<CachedSearchResult>(cacheKey);\r\n\r\n    if (!cachedResult) {\r\n      this.metrics.misses++;\r\n      this.updateHitRate();\r\n      return null;\r\n    }\r\n\r\n    // Check if cache is expired (note: Redis handles TTL automatically, but we still check timestamp for consistency)\r\n    if (Date.now() - cachedResult.timestamp > cachedResult.ttl) {\r\n      await redisService.del(cacheKey);\r\n      this.metrics.misses++;\r\n      this.updateHitRate();\r\n      return null;\r\n    }\r\n\r\n    this.metrics.hits++;\r\n    this.updateHitRate();\r\n    return cachedResult.results;\r\n  }\r\n\r\n  /**\r\n   * Store search results in cache\r\n   */\r\n async setCachedResult(\r\n    query: string,\r\n    results: SearchResults,\r\n    unitId?: string,\r\n    category?: string,\r\n    filters?: any,\r\n    ttl: number = DEFAULT_CACHE_TTL\r\n ): Promise<void> {\r\n    // Normalize parameters to handle \"undefined\" strings consistently\r\n    const normalizedUnitId = (unitId === 'undefined') ? undefined : unitId;\r\n    const normalizedCategory = (category === 'undefined') ? undefined : category;\r\n    const normalizedFilters = (filters === 'undefined') ? undefined : filters;\r\n    const cacheKey = this.generateCacheKey(query, normalizedUnitId, normalizedCategory, normalizedFilters);\r\n\r\n    const cachedResult: CachedSearchResult = {\r\n      query,\r\n      unitId: normalizedUnitId,\r\n      category: normalizedCategory,\r\n      filters: normalizedFilters,\r\n      results,\r\n      timestamp: Date.now(),\r\n      ttl: ttl * 1000 // Convert to milliseconds for timestamp comparison\r\n    };\r\n\r\n    // Store in Redis with TTL\r\n    await redisService.set(cacheKey, cachedResult, ttl);\r\n  }\r\n\r\n  /**\r\n   * Remove a specific cached result\r\n   */\r\n async removeCachedResult(query: string, unitId?: string, category?: string, filters?: any): Promise<void> {\r\n    // Normalize parameters to handle \"undefined\" strings consistently\r\n    const normalizedUnitId = (unitId === 'undefined') ? undefined : unitId;\r\n    const normalizedCategory = (category === 'undefined') ? undefined : category;\r\n    const normalizedFilters = (filters === 'undefined') ? undefined : filters;\r\n    const cacheKey = this.generateCacheKey(query, normalizedUnitId, normalizedCategory, normalizedFilters);\r\n    await redisService.del(cacheKey);\r\n  }\r\n\r\n  /**\r\n   * Clear all cached search results\r\n   */\r\n  async clearCache(): Promise<void> {\r\n    const keys = await redisService.keys('search:*');\r\n    if (keys.length > 0) {\r\n      await redisService.redis.del(...keys);\r\n    }\r\n }\r\n\r\n  /**\r\n   * Invalidate cache entries that might be affected by document changes\r\n   */\r\n  async invalidateCacheForDocument(documentId: string): Promise<void> {\r\n    // This is more complex with Redis - we'd need to maintain a reverse mapping\r\n    // For now, we'll clear all search cache when a document is updated\r\n    await this.clearCache();\r\n  }\r\n\r\n /**\r\n   * Invalidate cache entries that match a specific query pattern\r\n   */\r\n  async invalidateCacheByQuery(queryPattern: string): Promise<void> {\r\n    const pattern = `*${queryPattern.toLowerCase()}*`;\r\n    const keys = await redisService.keys(pattern);\r\n    if (keys.length > 0) {\r\n      await redisService.redis.del(...keys);\r\n    }\r\n }\r\n\r\n  /**\r\n   * Invalidate cache entries by unit ID\r\n   */\r\n  async invalidateCacheByUnit(unitId: string): Promise<void> {\r\n    // For a more sophisticated implementation, you'd need to maintain tags for cache invalidation\r\n    // For now, we'll clear all search cache when a unit is updated\r\n    await this.clearCache();\r\n }\r\n\r\n  /**\r\n   * Invalidate cache entries by category\r\n   */\r\n  async invalidateCacheByCategory(category: string): Promise<void> {\r\n    // For a more sophisticated implementation, you'd need to maintain tags for cache invalidation\r\n    // For now, we'll clear all search cache when a category is updated\r\n    await this.clearCache();\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  async getCacheStats(): Promise<{ size: number; keys: string[] }> {\r\n    const keys = await redisService.keys('search:*');\r\n    return {\r\n      size: keys.length,\r\n      keys\r\n    };\r\n  }\r\n\r\n /**\r\n   * Pre-warm the cache with frequently searched queries\r\n   */\r\n  async prewarmCache(queries: { query: string; results: SearchResults; unitId?: string; category?: string; filters?: any }[]): Promise<void> {\r\n    for (const { query, results, unitId, category, filters } of queries) {\r\n      // Normalize parameters to handle \"undefined\" strings consistently\r\n      const normalizedUnitId = (unitId === 'undefined') ? undefined : unitId;\r\n      const normalizedCategory = (category === 'undefined') ? undefined : category;\r\n      const normalizedFilters = (filters === 'undefined') ? undefined : filters;\r\n      await this.setCachedResult(query, results, normalizedUnitId, normalizedCategory, normalizedFilters);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the most frequently searched queries from cache usage\r\n   */\r\n  getFrequentQueries(limit: number = 10): string[] {\r\n    // This would normally track usage statistics over time\r\n    // For now, we'll return an empty array - in a real implementation,\r\n    // you'd track query usage and return the most frequent ones\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Update the cache hit rate metric\r\n   */\r\n  private updateHitRate(): void {\r\n    if (this.metrics.totalRequests > 0) {\r\n      this.metrics.hitRate = this.metrics.hits / this.metrics.totalRequests;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache metrics\r\n   */\r\n  getCacheMetrics(): CacheMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  /**\r\n   * Reset cache metrics\r\n   */\r\n  resetMetrics(): void {\r\n    this.metrics = {\r\n      hits: 0,\r\n      misses: 0,\r\n      totalRequests: 0,\r\n      averageResponseTime: 0,\r\n      hitRate: 0\r\n    };\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const searchCacheService = new SearchCacheService();\r\nexport { SearchCacheService };"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3811, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/app/api/search/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { NextResponse } from 'next/server';\r\nimport enhancedDocumentService from '@/lib/services/enhanced-document-service';\r\nimport { requireAuth } from '@/lib/middleware/auth-middleware';\r\nimport ColivaraService from '@/lib/services/colivara-service';\r\nimport QwenGenerationService from '@/lib/services/qwen-generation-service';\r\nimport { Document } from '@/lib/api/types';\r\nimport SuperMapper from '@/lib/utils/super-mapper';\r\nimport prisma from '@/lib/prisma';\r\nimport { cleanDocumentTitle } from '@/lib/utils/document-utils';\r\nimport { searchCacheService } from '@/lib/services/search-cache-service';\r\n\r\n// Define the source type for the Qwen response\r\ninterface Source {\r\n  title: string;\r\n  documentId: string;\r\n  confidence: number;\r\n}\r\n\r\n// Helper function to generate consistent cache keys\r\nfunction generateCacheKey(query: string, unitId?: string, category?: string, filters?: any) {\r\n  // Convert \"undefined\" string to proper undefined/null for consistent cache keys\r\n  const safeUnitId = (unitId === 'undefined' || unitId === undefined || unitId === null) ? 'all' : unitId;\r\n  const safeCategory = (category === 'undefined' || category === undefined || category === null) ? 'all' : category;\r\n  const safeFilters = (filters === 'undefined' || filters === undefined || filters === null) ? {} : filters;\r\n  return btoa([\r\n    query.toLowerCase().trim(),\r\n    safeUnitId,\r\n    safeCategory,\r\n    JSON.stringify(safeFilters)\r\n  ].join('|')).replace(/[^a-zA-Z0-9]/g, '_');\r\n}\r\n\r\nconst qwenService = new QwenGenerationService({ model: process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct' });\r\n\r\nconst colivaraService = new ColivaraService();\r\n\r\n// Helper function to deduplicate search results based on document ID\r\nfunction deduplicateResults(results: any[]): any[] {\r\n  const seenIds = new Set<string>();\r\n  const uniqueResults: any[] = [];\r\n  \r\n  for (const result of results) {\r\n    // Use the document ID for deduplication - try multiple possible locations\r\n    const docId = result.id ||\r\n                  result.documentId ||\r\n                  (result.document && result.document.id) ||\r\n                  (result.metadata && result.metadata.documentId) ||\r\n                  (result.document && result.document.metadata.documentId) ||\r\n                  undefined;\r\n    \r\n    if (docId && !seenIds.has(docId)) {\r\n      seenIds.add(docId);\r\n      uniqueResults.push(result);\r\n    } else if (!docId) {\r\n      // If no ID is available, add it anyway (though this shouldn't happen with proper data)\r\n      console.warn('Result without valid document ID in deduplicateResults:', result);\r\n      uniqueResults.push(result);\r\n    }\r\n   }\r\n  \r\n  return uniqueResults;\r\n}\r\n\r\n// Group similar search results by document ID to consolidate duplicates\r\nfunction groupResults(results: any[]): any[] {\r\n  const groupedMap = new Map<string, any>();\r\n  \r\n  for (const result of results) {\r\n    // Use the document ID as the grouping key - try multiple possible locations\r\n    const docId = result.id ||\r\n                  result.documentId ||\r\n                  (result.document && result.document.id) ||\r\n                  (result.metadata && result.metadata.documentId) ||\r\n                  (result.document && result.document.metadata.documentId) ||\r\n                  undefined;\r\n    \r\n    if (docId) {\r\n      if (groupedMap.has(docId)) {\r\n        // If we already have a result for this document, we'll keep the one with higher score\r\n        const existingResult = groupedMap.get(docId);\r\n        const currentScore = result.score || result.confidenceScore || 0;\r\n        const existingScore = existingResult.score || existingResult.confidenceScore || 0;\r\n        \r\n        // Keep the result with higher score\r\n        if (currentScore > existingScore) {\r\n          groupedMap.set(docId, result);\r\n        }\r\n      } else {\r\n        groupedMap.set(docId, result);\r\n      }\r\n    } else {\r\n      // If no ID, add it directly (shouldn't happen in normal cases after our filtering)\r\n      console.warn('Result without valid document ID:', result);\r\n      groupedMap.set(`fallback_${results.indexOf(result)}`, result);\r\n    }\r\n   }\r\n  \r\n  return Array.from(groupedMap.values());\r\n}\r\n\r\n// Mapper function to convert Colivara search results to the standard format expected by the frontend\r\nasync function mapColivaraResultsToDocuments(colivaraResults: any[]) {\r\n  // Create a set of document IDs from the search results to fetch from the database, ensuring they are valid strings\r\n  // Extract document IDs from the Colivara results - the ID should come from the metadata of the Colivara document\r\n  const allIds = colivaraResults\r\n    .map((result: any) => {\r\n      // Try multiple possible locations for the document ID\r\n      return result.documentId ||\r\n             result.id ||\r\n             (result.document && result.document.id) ||\r\n             (result.metadata && result.metadata.documentId) || // Check in metadata for the original document ID\r\n             (result.document && result.document.metadata && result.document.metadata.documentId) || // Nested check\r\n             undefined;\r\n    });\r\n  \r\n  // Log problematic IDs for debugging\r\n  const problematicIds = allIds.filter((id: any) => typeof id !== 'string' || id === undefined || id === null || id.trim() === '' || id.length === 0);\r\n  if (problematicIds.length > 0) {\r\n    console.warn('Found problematic document IDs in mapColivaraResultsToDocuments:', problematicIds);\r\n    console.warn('Sample of problematic results:', colivaraResults.slice(0, 5).map((r: any) => ({\r\n      documentId: r.documentId,\r\n      id: r.id,\r\n      metadata: r.metadata,\r\n      document: r.document,\r\n      hasDocument: !!r.document,\r\n      documentIdFromDoc: r.document?.id,\r\n      documentIdFromMetadata: r.metadata?.documentId\r\n    })));\r\n  }\r\n  \r\n  const documentIds = allIds\r\n    .filter((id: any) => {\r\n      // Only include IDs that are valid strings\r\n      return typeof id === 'string' && id.trim() !== '' && id.length > 0;\r\n    });\r\n  \r\n  // Remove duplicates from documentIds\r\n  const uniqueDocumentIds = [...new Set(documentIds)];\r\n  \r\n  // Fetch actual document data from the database to ensure correct titles and descriptions\r\n  let dbDocMap = new Map();\r\n  if (uniqueDocumentIds.length > 0) {\r\n    const dbDocuments = await prisma.document.findMany({\r\n      where: {\r\n        id: { in: uniqueDocumentIds },\r\n        status: 'ACTIVE' // Only include active documents\r\n      },\r\n      include: {\r\n        uploadedByUser: true,\r\n        documentUnit: true,\r\n      }\r\n    });\r\n    \r\n    // Create a map for quick lookup of database document data\r\n    dbDocMap = new Map(dbDocuments.map((doc: any) => [doc.id, doc]));\r\n  }\r\n  \r\n // Process results and map them to proper document format\r\n  const mappedResults = [];\r\n  for (const result of colivaraResults) {\r\n    // Get the document ID from the result - try multiple possible locations\r\n    const rawId = result.documentId ||\r\n                  result.id ||\r\n                  (result.document && result.document.id) ||\r\n                  (result.metadata && result.metadata.documentId) ||\r\n                  (result.document && result.document.metadata && result.document.metadata.documentId) ||\r\n                  undefined;\r\n    \r\n    // Only process if we have a valid document ID\r\n    if (typeof rawId === 'string' && rawId.trim() !== '' && rawId.length > 0) {\r\n      // Get the corresponding database document if it exists\r\n      const dbDoc = dbDocMap.get(rawId);\r\n      \r\n      // If the document exists in the database, use its data as the primary source\r\n      if (dbDoc) {\r\n        // Use database document as primary source but override with search-specific data\r\n        const mappedDocument = {\r\n          ...dbDoc,\r\n          tags: Array.isArray(dbDoc.tags) ? dbDoc.tags as string[] : [],\r\n          unitId: dbDoc.unitId ?? undefined,\r\n          versionNotes: dbDoc.versionNotes ?? undefined,\r\n          uploadedBy: dbDoc.uploadedByUser?.name || dbDoc.uploadedBy,\r\n          status: dbDoc.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW',\r\n          unit: dbDoc.documentUnit ? {\r\n            id: dbDoc.documentUnit.id,\r\n            name: dbDoc.documentUnit.name,\r\n            code: dbDoc.documentUnit.code,\r\n            description: dbDoc.documentUnit.description || undefined,\r\n            createdAt: dbDoc.documentUnit.createdAt,\r\n            updatedAt: dbDoc.documentUnit.updatedAt,\r\n          } : undefined,\r\n          uploadedAt: new Date(dbDoc.uploadedAt),\r\n          createdAt: new Date(dbDoc.createdAt),\r\n          updatedAt: new Date(dbDoc.updatedAt),\r\n          // Colivara fields\r\n          colivaraDocumentId: dbDoc.colivaraDocumentId ?? undefined,\r\n          colivaraProcessingStatus: dbDoc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n          colivaraProcessedAt: dbDoc.colivaraProcessedAt ? new Date(dbDoc.colivaraProcessedAt) : undefined,\r\n          colivaraChecksum: dbDoc.colivaraChecksum ?? undefined,\r\n        };\r\n        \r\n        // Override with search-specific data if available in the result\r\n        mappedResults.push({\r\n          ...mappedDocument,\r\n          title: cleanDocumentTitle(dbDoc.title || result.title || result.originalName || result.document_name || (result.document && result.document.title) || dbDoc.fileName || 'Untitled Document'), // Prioritize database document title over Colivara result\r\n          // For content, use robust fallback logic\r\n          content: (() => {\r\n            const rawContent = result.content || result.text || result.extractedText || dbDoc.description || '';\r\n            const hasRealText = typeof rawContent === 'string' && rawContent.trim().length > 0;\r\n            \r\n            if (hasRealText) {\r\n              return rawContent;\r\n            } else {\r\n              return 'Visual Content'; // This fixes \"undefined\" in content field\r\n            }\r\n          })(),\r\n          // For snippet, try Colivara result first, then fallback to database description\r\n          snippet: (() => {\r\n            // Robust Text Fallback - check if content exists and is a string with length\r\n            const rawContent = result.content || result.text || result.extractedText || dbDoc.description || '';\r\n            const hasRealText = typeof rawContent === 'string' && rawContent.trim().length > 0;\r\n            \r\n            if (hasRealText) {\r\n              return rawContent.substring(0, 200) + '...';\r\n            } else {\r\n              return dbDoc.description || 'Visual Document (Chart/Table/Image)'; // Use database description if available\r\n            }\r\n          })(),\r\n          // Add search-specific fields\r\n          score: (() => {\r\n            const rawScore = result.score || result.confidenceScore;\r\n            return (typeof rawScore === 'number') ? rawScore : 0.85; // Default to high relevance if Colivara found it\r\n          })(),\r\n          pageNumbers: result.pageNumbers || [],\r\n          documentSection: result.documentSection || '',\r\n          confidenceScore: (() => {\r\n            const rawScore = result.confidenceScore || result.score;\r\n            return (typeof rawScore === 'number') ? rawScore : 0.85; // Default to high relevance if Colivara found it\r\n          })(),\r\n          visualContent: result.visualContent, // Add visual content if available\r\n          extractedText: result.extractedText, // Add extracted text if available\r\n        });\r\n      } else {\r\n        // If no database document exists (shouldn't happen after zombie filtering), log a warning\r\n        console.warn(`Document with ID ${rawId} not found in database but returned by Colivara search`);\r\n      }\r\n    } else {\r\n      // If no valid document ID found, log for debugging but skip this result\r\n      console.warn('Skipping result with no valid document ID:', {\r\n        documentId: result.documentId,\r\n        id: result.id,\r\n        metadata: result.metadata,\r\n        document: result.document,\r\n      });\r\n    }\r\n  }\r\n  \r\n  return mappedResults;\r\n}\r\n\r\n// Function to remove zombie documents (documents that exist in Colivara but not in Prisma)\r\nasync function filterZombieDocuments(results: any[]): Promise<any[]> {\r\n  // Create a set of document IDs from the search results, ensuring they are valid strings\r\n // Extract document IDs from the Colivara results - the ID should come from the metadata of the Colivara document\r\n const allIds = results.map((result: any) => {\r\n    // Try multiple possible locations for the document ID\r\n    return result.documentId ||\r\n           result.id ||\r\n           (result.document && result.document.id) ||\r\n           (result.metadata && result.metadata.documentId) || // Check in metadata for the original document ID\r\n           (result.document && result.document.metadata && result.document.metadata.documentId) || // Nested check\r\n           undefined;\r\n  });\r\n  \r\n  // Log problematic IDs for debugging\r\n  const problematicIds = allIds.filter((id: any) => typeof id !== 'string' || id === undefined || id === null || id.trim() === '' || id.length === 0);\r\n  if (problematicIds.length > 0) {\r\n    console.warn('Found problematic document IDs in search results:', problematicIds);\r\n    console.warn('Sample of search results:', results.slice(0, 3).map((r: any) => ({\r\n      documentId: r.documentId,\r\n      id: r.id,\r\n      metadata: r.metadata,\r\n      hasDocument: !!r.document,\r\n      documentIdFromDoc: r.document?.id,\r\n      documentIdFromMetadata: r.metadata?.documentId\r\n    })));\r\n  }\r\n  \r\n  const documentIds = allIds\r\n    .filter((id: any) => {\r\n      // Only include IDs that are valid strings\r\n      return typeof id === 'string' && id.trim() !== '' && id.length > 0;\r\n    });\r\n  \r\n  // Remove duplicates from documentIds\r\n  const uniqueDocumentIds = [...new Set(documentIds)];\r\n  \r\n  if (uniqueDocumentIds.length === 0) {\r\n    console.warn('No valid document IDs found in search results');\r\n    return results;\r\n  }\r\n  \r\n  // Query Prisma to get the actual documents that exist in the database\r\n  const existingDocs = await prisma.document.findMany({\r\n    where: {\r\n      id: { in: uniqueDocumentIds },\r\n      status: 'ACTIVE' // Only include active documents\r\n    },\r\n    select: { id: true }\r\n });\r\n  \r\n  // Create a Set of existing document IDs for fast lookup\r\n  const existingDocIds = new Set(existingDocs.map((doc: any) => doc.id));\r\n  \r\n  // Filter out results that don't exist in the database (zombie documents)\r\n  return results.filter((result: any) => {\r\n    // Try multiple possible locations for the document ID\r\n    const docId = result.documentId ||\r\n                  result.id ||\r\n                  (result.document && result.document.id) ||\r\n                  (result.metadata && result.metadata.documentId) ||\r\n                  (result.document && result.document.metadata && result.document.metadata.documentId) ||\r\n                  undefined;\r\n    return typeof docId === 'string' && docId.trim() !== '' && existingDocIds.has(docId);\r\n  });\r\n}\r\n\r\n// Function to enhance results with visual content for multimodal processing\r\nasync function enhanceResultsWithVisualContent(results: any[], query: string, userId: string): Promise<any[]> {\r\n  // For each result, try to add visual content if it's missing but available from Colivara\r\n  const enhancedResults = [];\r\n  \r\n  for (const result of results) {\r\n    // If the result already has visual content, return as is\r\n    if (result.screenshots && result.screenshots.length > 0) {\r\n      enhancedResults.push(result);\r\n      continue;\r\n    }\r\n    \r\n    // Otherwise, try to fetch visual content from Colivara for this specific document\r\n    try {\r\n      // Try to get visual content for this document from Colivara if available\r\n      // This is a simplified approach - in reality, you'd need to call Colivara to get the visual content\r\n      const enhancedResult = { ...result };\r\n      \r\n      // Add any missing visual content fields that might be needed for multimodal processing\r\n      if (!enhancedResult.screenshots) {\r\n        enhancedResult.screenshots = [];\r\n      }\r\n      if (!enhancedResult.visualContent) {\r\n        enhancedResult.visualContent = result.visualContent || null;\r\n      }\r\n      if (!enhancedResult.extractedText) {\r\n        enhancedResult.extractedText = result.extractedText || '';\r\n      }\r\n      \r\n      enhancedResults.push(enhancedResult);\r\n    } catch (error) {\r\n      console.error(`Error enhancing result with visual content for document ${result.documentId}:`, error);\r\n      // Return the original result if enhancement fails\r\n      enhancedResults.push(result);\r\n    }\r\n  }\r\n  \r\n  return enhancedResults;\r\n}\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // Verify authentication\r\n    const authResult = await requireAuth(request);\r\n    if ('status' in authResult) { // Check if it's a NextResponse (error case)\r\n      return authResult;\r\n    }\r\n    \r\n    const { user } = authResult;\r\n\r\n    // Extract query parameters\r\n    const { searchParams } = new URL(request.url);\r\n    const query = searchParams.get('q') || searchParams.get('query') || '';\r\n    const page = Math.max(1, parseInt(searchParams.get('page') || '1'));\r\n    const limit = Math.min(50, Math.max(1, parseInt(searchParams.get('limit') || '10'))); // Limit to 50 max\r\n    const unitId = searchParams.get('unit') || undefined;\r\n    const category = searchParams.get('category') || undefined;\r\n    const useSemantic = searchParams.get('semantic') === 'true' || true; // Default to true for semantic search\r\n    \r\n    if (!query) {\r\n      return NextResponse.json(\r\n        { error: 'Query parameter is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const userId = user.id;\r\n\r\n    // Extract additional parameters for generation\r\n    const generateResponse = searchParams.get('generate') === 'true';\r\n    const generationType = searchParams.get('generationType') || 'text-only'; // 'text-only' or 'multimodal'\r\n    \r\n    // Check cache first before making expensive API calls\r\n    // For GET requests, there are no filters from request body, so pass an empty object to ensure consistent cache keys\r\n    // Using {} instead of undefined ensures cache key consistency between GET and POST requests\r\n    // Normalize \"undefined\" strings to proper undefined values\r\n    const normalizedUnitId = (unitId === 'undefined') ? undefined : unitId;\r\n    const normalizedCategory = (category === 'undefined') ? undefined : category;\r\n    console.log(`Checking cache for query: \"${query}\", unitId: \"${normalizedUnitId}\", category: \"${normalizedCategory}\"`);\r\n    const cachedResult = await searchCacheService.getCachedResult(query, normalizedUnitId, normalizedCategory, {});\r\n    if (cachedResult) {\r\n      console.log(`Cache hit for query: ${query}`);\r\n      console.log(`Cache key used: ${generateCacheKey(query, unitId, category, {})}`);\r\n      \r\n      // Enhance cached results with visual content if needed for multimodal processing\r\n      let enhancedCachedResults = cachedResult.results;\r\n      if (generateResponse) {\r\n        enhancedCachedResults = await enhanceResultsWithVisualContent(cachedResult.results, query, userId);\r\n      }\r\n      \r\n      // Create a new cached result object with enhanced results\r\n      const enhancedCachedResult = {\r\n        ...cachedResult,\r\n        results: enhancedCachedResults\r\n      };\r\n      \r\n      // If we're generating a response, we still need to call the generation service\r\n      // because the generated content might not be cached or might have expired\r\n      if (generateResponse) {\r\n        try {\r\n          const qwenService = new QwenGenerationService({ model: process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct' });\r\n          \r\n          // For comprehensive queries (like \"what trainings/seminars did...\"), use more results\r\n          const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                      query.toLowerCase().includes('all') ||\r\n                                      query.toLowerCase().includes('every') ||\r\n                                      query.toLowerCase().includes('faculty') ||\r\n                                      query.toLowerCase().includes('training') ||\r\n                                      query.toLowerCase().includes('seminar') ||\r\n                                      query.toLowerCase().includes('attended') ||\r\n                                      query.toLowerCase().includes('presentation') ||\r\n                                      query.toLowerCase().includes('research') ||\r\n                                      (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                      (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                      (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                      (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n          \r\n          // Use more results for comprehensive queries, but make sure we don't exceed what we have\r\n          const resultsForGeneration = isComprehensiveQuery ?\r\n            enhancedCachedResult.results.slice(0, Math.min(6, enhancedCachedResult.results.length)) : // Use up to 6 results for comprehensive queries\r\n            enhancedCachedResult.results.slice(0, 1);  // Use only top result for specific queries\r\n          \r\n          const qwenResult = await qwenService.generateInsights(\r\n            query,\r\n            resultsForGeneration,\r\n            userId\r\n          );\r\n          \r\n          // Add generated response to cached results\r\n          const responseWithGeneration = {\r\n            ...enhancedCachedResult,\r\n            generatedResponse: qwenResult.summary,\r\n            generationType: generationType,\r\n            sources: qwenResult.sources,\r\n          };\r\n          \r\n          // Include the document URL for the relevant document in the response\r\n          if (enhancedCachedResult.results.length > 0 && responseWithGeneration.sources.length > 0) {\r\n            // Find the document that corresponds to the source and add its URL\r\n            const relevantDoc = enhancedCachedResult.results.find(doc => doc.documentId === responseWithGeneration.sources[0].documentId);\r\n            if (relevantDoc) {\r\n              // Access documentUrl from the relevantDoc if it exists\r\n              const docWithUrl = relevantDoc as any;\r\n              if (docWithUrl.documentUrl) {\r\n                (responseWithGeneration as any).relevantDocumentUrl = docWithUrl.documentUrl;\r\n              }\r\n            }\r\n          }\r\n          \r\n          return NextResponse.json(responseWithGeneration);\r\n        } catch (generationError) {\r\n          console.error('Qwen generation failed:', generationError);\r\n          // Return cached results even if generation fails\r\n          return NextResponse.json(enhancedCachedResult);\r\n        }\r\n      }\r\n      \r\n      // Return cached result directly if no generation needed\r\n      return NextResponse.json(enhancedCachedResult);\r\n    }\r\n    \r\n    console.log(`Cache miss for query: ${query}, making API calls...`);\r\n    console.log(`Cache key that was not found: ${generateCacheKey(query, unitId, category, {})}`);\r\n    \r\n    if (useSemantic) {\r\n      // Use Colivara hybrid search\r\n      try {\r\n        const colivaraResults = await colivaraService.performHybridSearch(\r\n          query,\r\n          { unitId, category },\r\n          userId\r\n        );\r\n        \r\n        // --- ADD THIS ---\r\n        console.log(\" SEARCH RESULTS LOG:\", JSON.stringify(colivaraResults, null, 2));\r\n        // ----------------\r\n        \r\n        // Filter out zombie documents (deleted from Prisma but still in Colivara) first\r\n        const filteredResults = await filterZombieDocuments(colivaraResults.results);\r\n        \r\n        // Map Colivara results to standard document format using database data\r\n        let mappedResults = await mapColivaraResultsToDocuments(filteredResults);\r\n        \r\n        // Group and deduplicate results to avoid showing the same document multiple times\r\n        mappedResults = groupResults(mappedResults);\r\n        \r\n        // Create response object\r\n        let responseResults = mappedResults;\r\n        \r\n        // If generateResponse is true, limit results to the most relevant document\r\n        if (generateResponse && mappedResults && mappedResults.length > 0) {\r\n          // Use only the top result for display when generating AI response\r\n          responseResults = mappedResults.slice(0, 1);\r\n        }\r\n\r\n        const response: any = {\r\n          results: responseResults,\r\n          total: responseResults.length, // Use actual count after potential filtering\r\n          page,\r\n          limit,\r\n          totalPages: Math.ceil(mappedResults.length / limit), // Keep original total for pagination reference\r\n          query: colivaraResults.query,\r\n          processingTime: colivaraResults.processingTime,\r\n          searchType: 'hybrid',\r\n        };\r\n\r\n        // If generateResponse is true, use Qwen to generate a response based on the search results\r\n        if (generateResponse && mappedResults && mappedResults.length > 0) {\r\n          // First, get valid document IDs to filter zombie documents\r\n          const validDocumentIds = new Set(\r\n            filteredResults.map((result: any) => {\r\n              return result.documentId ||\r\n                     result.id ||\r\n                     (result.document && result.document.id) ||\r\n                     (result.metadata && result.metadata.documentId) ||\r\n                     (result.document && result.document.metadata.documentId) ||\r\n                     undefined;\r\n            }).filter((id: any) => typeof id === 'string' && id.trim() !== '' && id.length > 0)\r\n          );\r\n \r\n          // 1. MAP (Universal) - This creates the multimodal content needed for Qwen\r\n          // First, collect all Colivara document IDs to map to database IDs in a single query\r\n          const colivaraDocIds = colivaraResults.results\r\n            .filter((item: any) => {\r\n              // Only include items that have a valid document ID that exists in our filtered results\r\n              const docId = item.documentId ||\r\n                           item.id ||\r\n                           (item.document && item.document.id) ||\r\n                           (item.metadata && item.metadata.documentId) ||\r\n                           (item.document && item.document.metadata && item.document.metadata.documentId) ||\r\n                           undefined;\r\n              return typeof docId === 'string' && docId.trim() !== '' && validDocumentIds.has(docId);\r\n            })\r\n            .map((item: any) => {\r\n              // Get the Colivara document ID\r\n              const docData = item.document || item;\r\n              const metadata = docData.metadata || item.metadata || {};\r\n              \r\n              // Validate that the document ID is in proper CUID format before using it\r\n              const documentId = item.documentId || docData.document_id || docData.id?.toString() || \"\";\r\n              const isValidDocumentId = documentId && documentId !== 'undefined' && !documentId.includes('undefined') && /^[a-z0-9]+$/i.test(documentId) && documentId.length >= 20 && documentId.length <= 30;\r\n              \r\n              // Extract the original database document ID from metadata if available\r\n              const originalDocumentId = metadata.documentId || (docData.metadata && docData.metadata.documentId) || item.metadata?.documentId;\r\n              const hasValidOriginalId = originalDocumentId && typeof originalDocumentId === 'string' && /^[a-z0-9]+$/i.test(originalDocumentId) && originalDocumentId.length >= 20 && originalDocumentId.length <= 30;\r\n              \r\n              return {\r\n                colivaraDocumentId: isValidDocumentId ? documentId : \"\",\r\n                originalDocumentId: hasValidOriginalId ? originalDocumentId : undefined, // Store the original database ID if available\r\n                item: item, // Keep reference to the original item\r\n                index: colivaraResults.results.indexOf(item) // Keep track of the index\r\n              };\r\n            })\r\n            .filter((mapping: any) => mapping.colivaraDocumentId); // Only keep items with valid Colivara IDs\r\n          \r\n          // Query the database to map Colivara document IDs to database document IDs\r\n          const colivaraIdsToMap = colivaraDocIds\r\n            .filter((mapping: any) => !mapping.originalDocumentId) // Only map if we don't already have the original DB ID\r\n            .map((mapping: any) => mapping.colivaraDocumentId);\r\n            \r\n          let colivaraToDbMap = new Map(); // Initialize as empty map\r\n          \r\n          if (colivaraIdsToMap.length > 0) {\r\n            try {\r\n              // Query the database to find documents that have these colivaraDocumentIds\r\n              const dbDocuments = await prisma.document.findMany({\r\n                where: {\r\n                  colivaraDocumentId: { in: colivaraIdsToMap }\r\n                },\r\n                select: {\r\n                  id: true,\r\n                  colivaraDocumentId: true\r\n                }\r\n              });\r\n              \r\n              // Create a map from Colivara ID to database ID\r\n              colivaraToDbMap = new Map(dbDocuments.map(doc => [doc.colivaraDocumentId, doc.id]));\r\n            } catch (error) {\r\n              console.error('Error querying database for colivara document IDs:', error);\r\n            }\r\n          }\r\n          \r\n          // Now map the results with proper document IDs\r\n          const rawMapped = colivaraResults.results\r\n            .filter((item: any) => {\r\n              // Only include items that have a valid document ID that exists in our filtered results\r\n              const docId = item.documentId ||\r\n                           item.id ||\r\n                           (item.document && item.document.id) ||\r\n                           (item.metadata && item.metadata.documentId) ||\r\n                           (item.document && item.document.metadata && item.document.metadata.documentId) ||\r\n                           undefined;\r\n              return typeof docId === 'string' && docId.trim() !== '' && validDocumentIds.has(docId);\r\n            })\r\n            .map((item: any, index: number) => {\r\n              const docData = item.document || item;\r\n              const metadata = docData.metadata || item.metadata || {};\r\n              \r\n              // 1. Get Raw Image - Try multiple possible locations for image data\r\n              let rawImage = docData.img_base64 ||\r\n                            item.img_base64 ||\r\n                            docData.image ||\r\n                            metadata.image ||\r\n                            item.visualContent ||\r\n                            (item.document && item.document.visualContent) ||\r\n                            (item.extracted_content && item.extracted_content.image) ||\r\n                            null;\r\n \r\n              // 1. Clean the string if it has data URL prefix\r\n              if (rawImage && typeof rawImage === 'string') {\r\n                  rawImage = rawImage.replace(/^data:image\\/[a-z]+;base64,/, \"\");\r\n              }\r\n \r\n              // 2. DETECT MIME TYPE FROM DATA (The Fix)\r\n              // Don't rely on the filename. Look at the first few characters of the code.\r\n              let mimeType = 'image/jpeg'; // Default\r\n              if (rawImage && typeof rawImage === 'string') {\r\n                  if (rawImage.startsWith('iVBOR')) {\r\n                      mimeType = 'image/png';\r\n                  } else if (rawImage.startsWith('/9j/')) {\r\n                      mimeType = 'image/jpeg';\r\n                  }\r\n              }\r\n \r\n              // Helper to find text - Try multiple possible locations for extracted text\r\n              const txt = docData.text ||\r\n                         item.content ||\r\n                         metadata.text ||\r\n                         item.extractedText ||\r\n                         (item.document && item.document.extractedText) ||\r\n                         (item.extracted_content && item.extracted_content.text) ||\r\n                         (item.extracted_content && item.extracted_content.content) ||\r\n                         metadata.extracted_text ||\r\n                         \"\";\r\n \r\n              // SCORE FIX: If Colivara returns 0 but it's the top result, imply relevance based on rank\r\n              let score = docData.raw_score || docData.score || item.score || 0;\r\n              if (score === 0 && index === 0) score = 0.99; // Top result is logically relevant\r\n              if (score === 0 && index === 1) score = 0.80;\r\n \r\n              // IMAGE DEBUG: Log image size and header\r\n              if (rawImage && typeof rawImage === 'string') {\r\n                  console.log(` IMAGE DEBUG [${metadata.originalName || metadata.title || docData.document_name || \"Untitled\"}]: Size = ${rawImage.length} characters`);\r\n                  console.log(`   Header check: ${rawImage.substring(0, 30)}...`);\r\n              } else {\r\n                  console.log(` NO IMAGE found for ${metadata.originalName || metadata.title || docData.document_name || \"Untitled\"}`);\r\n              }\r\n \r\n              // Validate that the document ID is in proper CUID format before using it\r\n              const documentId = item.documentId || docData.document_id || docData.id?.toString() || \"\";\r\n              const isValidDocumentId = documentId && documentId !== 'undefined' && !documentId.includes('undefined') && /^[a-z0-9]+$/i.test(documentId) && documentId.length >= 20 && documentId.length <= 30;\r\n              \r\n              // Extract the original database document ID from metadata if available\r\n              const originalDocumentId = metadata.documentId || (docData.metadata && docData.metadata.documentId) || item.metadata?.documentId;\r\n              const hasValidOriginalId = originalDocumentId && typeof originalDocumentId === 'string' && /^[a-z0-9]+$/i.test(originalDocumentId) && originalDocumentId.length >= 20 && originalDocumentId.length <= 30;\r\n              \r\n              // Try to get the database document ID by looking up the Colivara ID in our map\r\n              let finalDocumentId = hasValidOriginalId ? originalDocumentId : undefined;\r\n              \r\n              if (!finalDocumentId && isValidDocumentId && colivaraToDbMap.has(documentId)) {\r\n                finalDocumentId = colivaraToDbMap.get(documentId);\r\n              }\r\n              \r\n              // Use the final document ID (database ID) for the URL, fallback to Colivara ID if not found\r\n              const previewDocumentId = finalDocumentId || (isValidDocumentId ? documentId : undefined);\r\n              \r\n              return {\r\n                documentId: isValidDocumentId ? documentId : \"\",\r\n                originalDocumentId: finalDocumentId, // Store the database document ID if available\r\n                title: cleanDocumentTitle(metadata.originalName || metadata.title || docData.document_name || (docData.title && cleanDocumentTitle(docData.title)) || (item.title && cleanDocumentTitle(item.title)) || \"Untitled\"),\r\n                content: txt || \"Visual content only\", // Required field for SearchResult\r\n                \r\n                // UI Snippet: Show what we actually found\r\n                snippet: txt ? txt.substring(0, 150) + \"...\" : \"Visual Document (Table/Chart/Scan)\",\r\n                \r\n                score: score,\r\n                pageNumbers: [], // Required field for SearchResult\r\n                document: {}, // Required field for SearchResult\r\n                screenshots: rawImage ? [rawImage] : [],\r\n                mimeType: mimeType, // Pass the TRUE type\r\n                extractedText: txt,\r\n                // Include document URL for redirect functionality - use the database document ID if available\r\n                documentUrl: finalDocumentId ? `/repository/preview/${finalDocumentId}` : undefined\r\n              };\r\n            });\r\n\r\n          // 2. DEDUPLICATE (Kill the Zombies)\r\n          const uniqueMap = new Map();\r\n          const cleanResults = [];\r\n\r\n          for (const doc of rawMapped) {\r\n              // Use documentId or Title as unique key to prevent duplicates\r\n              const key = doc.documentId || doc.title;\r\n              if (!uniqueMap.has(key)) {\r\n                  uniqueMap.set(key, true);\r\n                  cleanResults.push(doc);\r\n              }\r\n          }\r\n          \r\n          try {\r\n            // Use generateInsights to get both the response and the sources used\r\n            // For queries asking for comprehensive lists (like faculty and their trainings), use more results\r\n            const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                        query.toLowerCase().includes('all') ||\r\n                                        query.toLowerCase().includes('every') ||\r\n                                        query.toLowerCase().includes('faculty') ||\r\n                                        query.toLowerCase().includes('training') ||\r\n                                        query.toLowerCase().includes('seminar') ||\r\n                                        query.toLowerCase().includes('attended') ||\r\n                                        query.toLowerCase().includes('presentation') ||\r\n                                        query.toLowerCase().includes('research') ||\r\n                                        (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                        (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                        (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                        (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n            \r\n            // Use more results for comprehensive queries, but make sure we don't exceed what we have\r\n            const resultsForGeneration = isComprehensiveQuery ?\r\n              cleanResults.slice(0, Math.min(6, cleanResults.length)) : // Use up to 6 results for comprehensive queries\r\n              cleanResults.slice(0, 1);  // Use only top result for specific queries\r\n            \r\n            const qwenResult = await qwenService.generateInsights(\r\n              query,\r\n              resultsForGeneration\r\n            );\r\n            \r\n            response.generatedResponse = qwenResult.summary;\r\n            response.generationType = generationType;\r\n            \r\n            // Include all relevant sources for comprehensive queries, otherwise just the top one\r\n            // Clean the title in the source and ensure we have the database document ID\r\n            const cleanedSources = qwenResult.sources && qwenResult.sources.length > 0 ?\r\n              qwenResult.sources.map(source => {\r\n                // Try to get the database document ID from the resultsForGeneration\r\n                const originalResult = resultsForGeneration.find(result =>\r\n                  result.documentId === source.documentId || result.originalDocumentId === source.documentId\r\n                );\r\n                \r\n                // Use the database document ID if available, otherwise fallback to the source.documentId\r\n                const databaseDocumentId = originalResult?.originalDocumentId || source.documentId;\r\n                \r\n                return {\r\n                  ...source,\r\n                  title: cleanDocumentTitle(source.title),\r\n                  documentId: databaseDocumentId // Use the database document ID for clicking\r\n                };\r\n              }) : [];\r\n            \r\n            response.sources = cleanedSources;\r\n            \r\n            // Include the document URL for the relevant document in the response\r\n            if (cleanResults.length > 0 && response.sources.length > 0) {\r\n              // Find the document that corresponds to the source and add its URL\r\n              const relevantDoc = cleanResults.find(doc => doc.documentId === response.sources[0].documentId);\r\n              if (relevantDoc && relevantDoc.documentUrl) {\r\n                response.relevantDocumentUrl = relevantDoc.documentUrl;\r\n              } else {\r\n                // Fallback: try to find document by originalDocumentId if documentId doesn't match\r\n                const relevantDocFallback = cleanResults.find(doc => doc.originalDocumentId === response.sources[0].documentId);\r\n                if (relevantDocFallback && relevantDocFallback.documentUrl) {\r\n                  response.relevantDocumentUrl = relevantDocFallback.documentUrl;\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Update the response results to include the visual content for caching\r\n            // This ensures that when the response is cached, it includes the visual content needed for multimodal processing\r\n            if (cleanResults.length > 0) {\r\n              // Map the cleanResults (with visual content) to the response results\r\n              response.results = cleanResults.slice(0, 1); // Use only top result for display when generating AI response\r\n            }\r\n          } catch (generationError) {\r\n            console.error('Qwen generation failed:', generationError);\r\n            // Don't fail the entire request if generation fails, just return search results\r\n          }\r\n        }\r\n\r\n        // Store results in cache before returning - use empty object for consistency with cache retrieval\r\n        // Before caching, ensure the response results include visual content if it exists\r\n        await searchCacheService.setCachedResult(query, response, normalizedUnitId, normalizedCategory, {});\r\n        return NextResponse.json(response);\r\n      } catch (colivaraError) {\r\n        console.error('Colivara search failed, falling back to traditional search:', colivaraError);\r\n        // Fall back to traditional search if Colivara fails\r\n        // Use traditional search\r\n        console.log(`Colivara search failed for query: ${query}, falling back to traditional search`);\r\n        const traditionalResults = await enhancedDocumentService.searchDocuments(\r\n          query,\r\n          unitId,\r\n          category,\r\n          undefined, // tags\r\n          userId,\r\n          page,\r\n          limit\r\n        );\r\n        \r\n        // Format traditional results to match expected response structure\r\n        // Map traditional results to the same format as Colivara results using SuperMapper\r\n        const formattedResults = traditionalResults.documents.map(doc => ({\r\n          documentId: doc.id,\r\n          title: cleanDocumentTitle(doc.title || doc.fileName || 'Untitled Document'),\r\n          content: doc.description || '',\r\n          score: 0.5, // Default score for traditional search\r\n          pageNumbers: [],\r\n          documentSection: 'description',\r\n          confidenceScore: 0.5,\r\n          snippet: doc.description ? doc.description.substring(0, 200) + '...' : 'No preview available',\r\n          document: SuperMapper.createStandardDocument(doc) // Process through SuperMapper\r\n        }));\r\n\r\n        // Group and deduplicate results to avoid showing the same document multiple times\r\n        const groupedResults = groupResults(formattedResults);\r\n\r\n        // Create response object\r\n        const response: any = {\r\n          results: groupedResults,\r\n          total: groupedResults.length, // Use actual deduplicated count\r\n          page,\r\n          limit,\r\n          totalPages: Math.ceil(groupedResults.length / limit),\r\n          query,\r\n          processingTime: 0, // We don't track processing time for traditional search here\r\n          searchType: 'traditional',\r\n        };\r\n\r\n        // If generateResponse is true, use Qwen to generate a response based on the search results\r\n        if (generateResponse && groupedResults && groupedResults.length > 0) {\r\n          try {\r\n            // For traditional search, handle comprehensive queries similarly\r\n            const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                        query.toLowerCase().includes('all') ||\r\n                                        query.toLowerCase().includes('every') ||\r\n                                        query.toLowerCase().includes('faculty') ||\r\n                                        query.toLowerCase().includes('training') ||\r\n                                        query.toLowerCase().includes('seminar') ||\r\n                                        query.toLowerCase().includes('attended') ||\r\n                                        query.toLowerCase().includes('presentation') ||\r\n                                        query.toLowerCase().includes('research') ||\r\n                                        (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                        (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                        (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                        (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n            \r\n            // Use more results for comprehensive queries, but make sure we don't exceed what we have\r\n            const resultsForGeneration = isComprehensiveQuery ?\r\n              groupedResults.slice(0, Math.min(6, groupedResults.length)) : // Use up to 6 results for comprehensive queries\r\n              groupedResults.slice(0, 1);  // Use only top result for specific queries\r\n            \r\n            // Use generateInsights to get both the response and the sources used\r\n            const qwenService = new QwenGenerationService({ model: process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct' });\r\n            const qwenResult = await qwenService.generateInsights(\r\n              query,\r\n              resultsForGeneration,\r\n              userId\r\n            );\r\n            \r\n            response.generatedResponse = qwenResult.summary;\r\n            response.generationType = generationType;\r\n            \r\n            // Include all relevant sources for comprehensive queries, otherwise just the top one\r\n            const cleanedSources = qwenResult.sources && qwenResult.sources.length > 0 ?\r\n              qwenResult.sources.map(source => ({\r\n                ...source,\r\n                title: cleanDocumentTitle(source.title)\r\n              })) : [];\r\n            \r\n            response.sources = cleanedSources;\r\n          } catch (generationError) {\r\n            console.error('Qwen generation failed:', generationError);\r\n            // Don't fail the entire request if generation fails, just return search results\r\n          }\r\n        }\r\n        \r\n        // Store results in cache before returning - use empty object for consistency with cache retrieval\r\n        // Before caching, ensure the response results include visual content if it exists\r\n        await searchCacheService.setCachedResult(query, response, normalizedUnitId, normalizedCategory, {});\r\n        return NextResponse.json(response);\r\n      }\r\n    } else {\r\n      // Use traditional search\r\n      const traditionalResults = await enhancedDocumentService.searchDocuments(\r\n        query,\r\n        unitId,\r\n        category,\r\n        undefined, // tags\r\n        userId,\r\n        page,\r\n        limit\r\n      );\r\n      \r\n      // Format traditional results to match expected response structure\r\n      // Map traditional results to the same format as Colivara results using SuperMapper\r\n      const formattedResults = traditionalResults.documents.map(doc => ({\r\n        documentId: doc.id,\r\n        title: doc.title,\r\n        content: doc.description,\r\n        score: 0.5, // Default score for traditional search\r\n        pageNumbers: [],\r\n        documentSection: 'description',\r\n        confidenceScore: 0.5,\r\n        snippet: doc.description.substring(0, 200) + '...',\r\n        document: SuperMapper.createStandardDocument(doc) // Process through SuperMapper\r\n      }));\r\n\r\n      // Group and deduplicate results to avoid showing the same document multiple times\r\n      const groupedResults = groupResults(formattedResults);\r\n\r\n      // Create response object\r\n      const response: any = {\r\n        results: groupedResults,\r\n        total: groupedResults.length, // Use actual deduplicated count\r\n        page,\r\n        limit,\r\n        totalPages: Math.ceil(groupedResults.length / limit),\r\n        query,\r\n        processingTime: 0, // We don't track processing time for traditional search here\r\n        searchType: 'traditional',\r\n      };\r\n\r\n      // If generateResponse is true, use Qwen to generate a response based on the search results\r\n      if (generateResponse && groupedResults && groupedResults.length > 0) {\r\n        try {\r\n          // For traditional search, handle comprehensive queries similarly\r\n          const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                    query.toLowerCase().includes('all') ||\r\n                                    query.toLowerCase().includes('every') ||\r\n                                    query.toLowerCase().includes('faculty') ||\r\n                                    query.toLowerCase().includes('training') ||\r\n                                    query.toLowerCase().includes('seminar') ||\r\n                                    query.toLowerCase().includes('attended') ||\r\n                                    query.toLowerCase().includes('presentation') ||\r\n                                    query.toLowerCase().includes('research') ||\r\n                                    (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                    (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                    (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                    (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n        \r\n          // Use more results for comprehensive queries, but make sure we don't exceed what we have\r\n          const resultsForGeneration = isComprehensiveQuery ?\r\n            groupedResults.slice(0, Math.min(6, groupedResults.length)) : // Use up to 6 results for comprehensive queries\r\n            groupedResults.slice(0, 1);  // Use only top result for specific queries\r\n        \r\n          // Use generateInsights to get both the response and the sources used\r\n          const qwenService = new QwenGenerationService({ model: process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct' });\r\n          const qwenResult = await qwenService.generateInsights(\r\n            query,\r\n            resultsForGeneration,\r\n            userId\r\n          );\r\n          \r\n          response.generatedResponse = qwenResult.summary;\r\n          response.generationType = generationType;\r\n          \r\n          // Include all relevant sources for comprehensive queries, otherwise just the top one\r\n          const cleanedSources = qwenResult.sources && qwenResult.sources.length > 0 ?\r\n            qwenResult.sources.map(source => ({\r\n              ...source,\r\n              title: cleanDocumentTitle(source.title)\r\n            })) : [];\r\n        \r\n          response.sources = cleanedSources;\r\n        } catch (generationError) {\r\n          console.error('Qwen generation failed:', generationError);\r\n          // Don't fail the entire request if generation fails, just return search results\r\n        }\r\n      }\r\n\r\n      // Store results in cache before returning - use empty object for consistency with cache retrieval\r\n      // Before caching, ensure the response results include visual content if it exists\r\n      await searchCacheService.setCachedResult(query, response, normalizedUnitId, normalizedCategory, {});\r\n      return NextResponse.json(response);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error in search API:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error during search' },\r\n      { status: 500 }\r\n    );\r\n }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    // Verify authentication\r\n    const authResult = await requireAuth(request);\r\n    if ('status' in authResult) { // Check if it's a NextResponse (error case)\r\n      return authResult;\r\n    }\r\n    \r\n    const { user } = authResult;\r\n\r\n    // Parse request body\r\n    const body = await request.json();\r\n    const { query, unitId, category, filters, page = 1, limit = 10, useSemantic = true, generateResponse = false, generationType = 'text-only' } = body;\r\n\r\n    if (!query) {\r\n      return NextResponse.json(\r\n        { error: 'Query parameter is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const userId = user.id;\r\n\r\n    // Check cache first before making expensive API calls\r\n    // Using filters object directly for POST requests to maintain consistency with request parameters\r\n    // Normalize \"undefined\" strings to proper undefined values\r\n    const normalizedUnitId = (unitId === 'undefined') ? undefined : unitId;\r\n    const normalizedCategory = (category === 'undefined') ? undefined : category;\r\n    const normalizedFilters = (filters === 'undefined') ? {} : filters;\r\n    console.log(`Checking cache for POST query: \"${query}\", unitId: \"${normalizedUnitId}\", category: \"${normalizedCategory}\", filters:`, normalizedFilters);\r\n    const cachedResult = await searchCacheService.getCachedResult(query, normalizedUnitId, normalizedCategory, normalizedFilters);\r\n    if (cachedResult) {\r\n      console.log(`Cache hit for POST query: ${query}`);\r\n      console.log(`Cache key used: ${generateCacheKey(query, unitId, category, filters)}`);\r\n      \r\n      // Enhance cached results with visual content if needed for multimodal processing\r\n      let enhancedCachedResults = cachedResult.results;\r\n      if (generateResponse) {\r\n        enhancedCachedResults = await enhanceResultsWithVisualContent(cachedResult.results, query, userId);\r\n      }\r\n      \r\n      // Create a new cached result object with enhanced results\r\n      const enhancedCachedResult = {\r\n        ...cachedResult,\r\n        results: enhancedCachedResults\r\n      };\r\n      \r\n      // If we're generating a response, we still need to call the generation service\r\n      // because the generated content might not be cached or might have expired\r\n      if (generateResponse) {\r\n        try {\r\n          const qwenService = new QwenGenerationService({ model: process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct' });\r\n          \r\n          // For comprehensive queries (like \"what trainings/seminars did...\"), use more results\r\n          const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                      query.toLowerCase().includes('all') ||\r\n                                      query.toLowerCase().includes('every') ||\r\n                                      query.toLowerCase().includes('faculty') ||\r\n                                      query.toLowerCase().includes('training') ||\r\n                                      query.toLowerCase().includes('seminar') ||\r\n                                      query.toLowerCase().includes('attended') ||\r\n                                      query.toLowerCase().includes('presentation') ||\r\n                                      query.toLowerCase().includes('research') ||\r\n                                      (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                      (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                      (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                      (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n          \r\n          // Use more results for comprehensive queries, but make sure we don't exceed what we have\r\n          const resultsForGeneration = isComprehensiveQuery ?\r\n            enhancedCachedResult.results.slice(0, Math.min(6, enhancedCachedResult.results.length)) : // Use up to 6 results for comprehensive queries\r\n            enhancedCachedResult.results.slice(0, 1);  // Use only top result for specific queries\r\n          \r\n          const qwenResult = await qwenService.generateInsights(\r\n            query,\r\n            resultsForGeneration,\r\n            userId\r\n          );\r\n          \r\n          // Add generated response to cached results\r\n          const responseWithGeneration = {\r\n            ...enhancedCachedResult,\r\n            generatedResponse: qwenResult.summary,\r\n            generationType: generationType,\r\n            sources: qwenResult.sources,\r\n          };\r\n          \r\n          // Include the document URL for the relevant document in the response\r\n          if (enhancedCachedResult.results.length > 0 && responseWithGeneration.sources.length > 0) {\r\n            // Find the document that corresponds to the source and add its URL\r\n            const relevantDoc = enhancedCachedResult.results.find(doc => doc.documentId === responseWithGeneration.sources[0].documentId);\r\n            if (relevantDoc) {\r\n              // Access documentUrl from the relevantDoc if it exists\r\n              const docWithUrl = relevantDoc as any;\r\n              if (docWithUrl.documentUrl) {\r\n                (responseWithGeneration as any).relevantDocumentUrl = docWithUrl.documentUrl;\r\n              }\r\n            }\r\n          }\r\n          \r\n          return NextResponse.json(responseWithGeneration);\r\n        } catch (generationError) {\r\n          console.error('Qwen generation failed:', generationError);\r\n          // Return cached results even if generation fails\r\n          return NextResponse.json(enhancedCachedResult);\r\n        }\r\n      }\r\n      \r\n      // Return cached result directly if no generation needed\r\n      return NextResponse.json(enhancedCachedResult);\r\n    }\r\n    \r\n    console.log(`Cache miss for POST query: ${query}, making API calls...`);\r\n    console.log(`Cache key that was not found: ${generateCacheKey(query, unitId, category, filters)}`);\r\n\r\n    let searchResults;\r\n    let searchType = '';\r\n    let processingTime = 0;\r\n    \r\n    if (useSemantic) {\r\n      // Use Colivara hybrid search\r\n      try {\r\n        const colivaraResults = await colivaraService.performHybridSearch(\r\n          query,\r\n          {\r\n            unitId: normalizedUnitId,\r\n            category: normalizedCategory,\r\n            ...normalizedFilters\r\n          },\r\n          userId\r\n        );\r\n        \r\n        // --- ADD THIS ---\r\n        console.log(\" SEARCH RESULTS LOG:\", JSON.stringify(colivaraResults, null, 2));\r\n        // ----------------\r\n        \r\n        searchType = 'hybrid';\r\n        processingTime = colivaraResults.processingTime;\r\n        \r\n        // Filter out zombie documents (deleted from Prisma but still in Colivara) first\r\n        const filteredResults = await filterZombieDocuments(colivaraResults.results);\r\n        \r\n        // Map Colivara results to standard document format using database data\r\n        let mappedResults = await mapColivaraResultsToDocuments(filteredResults);\r\n        \r\n        // Group and deduplicate results to avoid showing the same document multiple times\r\n        mappedResults = groupResults(mappedResults);\r\n        \r\n        // First, get valid document IDs to filter zombie documents\r\n        const validDocumentIds = new Set(\r\n          filteredResults.map((result: any) => {\r\n            return result.documentId ||\r\n                   result.id ||\r\n                   (result.document && result.document.id) ||\r\n                   (result.metadata && result.metadata.documentId) ||\r\n                   (result.document && result.document.metadata.documentId) ||\r\n                   undefined;\r\n          }).filter((id: any) => typeof id === 'string' && id.trim() !== '' && id.length > 0)\r\n        );\r\n\r\n        // 1. MAP (Universal) - First, collect all Colivara document IDs to map to database IDs in a single query\r\n        const colivaraDocIds = colivaraResults.results\r\n          .filter((item: any) => {\r\n            // Only include items that have a valid document ID that exists in our filtered results\r\n            const docId = item.documentId ||\r\n                         item.id ||\r\n                         (item.document && item.document.id) ||\r\n                         (item.metadata && item.metadata.documentId) ||\r\n                         (item.document && item.document.metadata && item.document.metadata.documentId) ||\r\n                         undefined;\r\n            return typeof docId === 'string' && docId.trim() !== '' && validDocumentIds.has(docId);\r\n          })\r\n          .map((item: any) => {\r\n            // Get the Colivara document ID\r\n            const docData = item.document || item;\r\n            const metadata = docData.metadata || item.metadata || {};\r\n            \r\n            // Validate that the document ID is in proper CUID format before using it\r\n            const documentId = item.documentId || docData.document_id || docData.id?.toString() || \"\";\r\n            const isValidDocumentId = documentId && documentId !== 'undefined' && !documentId.includes('undefined') && /^[a-z0-9]+$/i.test(documentId) && documentId.length >= 20 && documentId.length <= 30;\r\n            \r\n            // Extract the original database document ID from metadata if available\r\n            const originalDocumentId = metadata.documentId || (docData.metadata && docData.metadata.documentId) || item.metadata?.documentId;\r\n            const hasValidOriginalId = originalDocumentId && typeof originalDocumentId === 'string' && /^[a-z0-9]+$/i.test(originalDocumentId) && originalDocumentId.length >= 20 && originalDocumentId.length <= 30;\r\n            \r\n            return {\r\n              colivaraDocumentId: isValidDocumentId ? documentId : \"\",\r\n              originalDocumentId: hasValidOriginalId ? originalDocumentId : undefined, // Store the original database ID if available\r\n              item: item, // Keep reference to the original item\r\n              index: colivaraResults.results.indexOf(item) // Keep track of the index\r\n            };\r\n          })\r\n          .filter((mapping: any) => mapping.colivaraDocumentId); // Only keep items with valid Colivara IDs\r\n        \r\n        // Query the database to map Colivara document IDs to database document IDs\r\n        const colivaraIdsToMap = colivaraDocIds\r\n          .filter((mapping: any) => !mapping.originalDocumentId) // Only map if we don't already have the original DB ID\r\n          .map((mapping: any) => mapping.colivaraDocumentId);\r\n          \r\n        let colivaraToDbMap = new Map(); // Initialize as empty map\r\n        \r\n        if (colivaraIdsToMap.length > 0) {\r\n          try {\r\n            // Query the database to find documents that have these colivaraDocumentIds\r\n            const dbDocuments = await prisma.document.findMany({\r\n              where: {\r\n                colivaraDocumentId: { in: colivaraIdsToMap }\r\n              },\r\n              select: {\r\n                id: true,\r\n                colivaraDocumentId: true\r\n              }\r\n            });\r\n            \r\n            // Create a map from Colivara ID to database ID\r\n            colivaraToDbMap = new Map(dbDocuments.map(doc => [doc.colivaraDocumentId, doc.id]));\r\n          } catch (error) {\r\n            console.error('Error querying database for colivara document IDs:', error);\r\n          }\r\n        }\r\n        \r\n        // Now map the results with proper document IDs\r\n        const rawMapped = colivaraResults.results\r\n          .filter((item: any) => {\r\n            // Only include items that have a valid document ID that exists in our filtered results\r\n            const docId = item.documentId ||\r\n                         item.id ||\r\n                         (item.document && item.document.id) ||\r\n                         (item.metadata && item.metadata.documentId) ||\r\n                         (item.document && item.document.metadata && item.document.metadata.documentId) ||\r\n                         undefined;\r\n            return typeof docId === 'string' && docId.trim() !== '' && validDocumentIds.has(docId);\r\n          })\r\n          .map((item: any, index: number) => {\r\n            const docData = item.document || item;\r\n            const metadata = docData.metadata || item.metadata || {};\r\n            \r\n            // 1. Get Raw Image - Try multiple possible locations for image data\r\n            let rawImage = docData.img_base64 ||\r\n                          item.img_base64 ||\r\n                          docData.image ||\r\n                          metadata.image ||\r\n                          item.visualContent ||\r\n                          (item.document && item.document.visualContent) ||\r\n                          (item.extracted_content && item.extracted_content.image) ||\r\n                          null;\r\n\r\n            // 1. Clean the string if it has data URL prefix\r\n            if (rawImage && typeof rawImage === 'string') {\r\n                rawImage = rawImage.replace(/^data:image\\/[a-z]+;base64,/, \"\");\r\n            }\r\n\r\n            // 2. DETECT MIME TYPE FROM DATA (The Fix)\r\n            // Don't rely on the filename. Look at the first few characters of the code.\r\n            let mimeType = 'image/jpeg'; // Default\r\n            if (rawImage && typeof rawImage === 'string') {\r\n                if (rawImage.startsWith('iVBOR')) {\r\n                    mimeType = 'image/png';\r\n                } else if (rawImage.startsWith('/9j/')) {\r\n                    mimeType = 'image/jpeg';\r\n                }\r\n            }\r\n            \r\n            // Helper to find text - Try multiple possible locations for extracted text\r\n            const txt = docData.text ||\r\n                       item.content ||\r\n                       metadata.text ||\r\n                       item.extractedText ||\r\n                       (item.document && item.document.extractedText) ||\r\n                       (item.extracted_content && item.extracted_content.text) ||\r\n                       (item.extracted_content && item.extracted_content.content) ||\r\n                       metadata.extracted_text ||\r\n                       \"\";\r\n            \r\n            // SCORE FIX: If Colivara returns 0 but it's the top result, imply relevance based on rank\r\n            let score = docData.raw_score || docData.score || item.score || 0;\r\n            if (score === 0 && index === 0) score = 0.99; // Top result is logically relevant\r\n            if (score === 0 && index === 1) score = 0.80;\r\n            \r\n            // 2. DETECT MIME TYPE FROM DATA (The Fix)\r\n            // Don't rely on the filename. Look at the first few characters of the code.\r\n            let detectedMimeType = 'image/jpeg'; // Default\r\n            if (rawImage && typeof rawImage === 'string') {\r\n                if (rawImage.startsWith('iVBOR')) {\r\n                    detectedMimeType = 'image/png';\r\n                } else if (rawImage.startsWith('/9j/')) {\r\n                    detectedMimeType = 'image/jpeg';\r\n                }\r\n            }\r\n            \r\n            // IMAGE DEBUG: Log image size and header\r\n            if (rawImage && typeof rawImage === 'string') {\r\n                console.log(` IMAGE DEBUG [${metadata.originalName || metadata.title || docData.document_name || \"Untitled\"}]: Size = ${rawImage.length} characters`);\r\n                console.log(`   Header check: ${rawImage.substring(0, 30)}...`);\r\n            } else {\r\n                console.log(` NO IMAGE found for ${metadata.originalName || metadata.title || docData.document_name || \"Untitled\"}`);\r\n            }\r\n            \r\n            // Validate that the document ID is in proper CUID format before using it\r\n            const documentId = item.documentId || docData.document_id || docData.id?.toString() || \"\";\r\n            const isValidDocumentId = documentId && documentId !== 'undefined' && !documentId.includes('undefined') && /^[a-z0-9]+$/i.test(documentId) && documentId.length >= 20 && documentId.length <= 30;\r\n            \r\n            // Extract the original database document ID from metadata if available\r\n            const originalDocumentId = metadata.documentId || (docData.metadata && docData.metadata.documentId) || item.metadata?.documentId;\r\n            const hasValidOriginalId = originalDocumentId && typeof originalDocumentId === 'string' && /^[a-z0-9]+$/i.test(originalDocumentId) && originalDocumentId.length >= 20 && originalDocumentId.length <= 30;\r\n            \r\n            // Try to get the database document ID by looking up the Colivara ID in our map\r\n            let finalDocumentId = hasValidOriginalId ? originalDocumentId : undefined;\r\n            \r\n            if (!finalDocumentId && isValidDocumentId && colivaraToDbMap.has(documentId)) {\r\n              finalDocumentId = colivaraToDbMap.get(documentId);\r\n            }\r\n            \r\n            // Use the final document ID (database ID) for the URL, fallback to Colivara ID if not found\r\n            const previewDocumentId = finalDocumentId || (isValidDocumentId ? documentId : undefined);\r\n            \r\n            return {\r\n              documentId: isValidDocumentId ? documentId : \"\",\r\n              originalDocumentId: finalDocumentId, // Store the database document ID if available\r\n              title: cleanDocumentTitle(metadata.originalName || metadata.title || docData.document_name || (docData.title && cleanDocumentTitle(docData.title)) || (item.title && cleanDocumentTitle(item.title)) || \"Untitled\"),\r\n              content: txt || \"Visual content only\", // Required field for SearchResult\r\n              \r\n              // UI Snippet: Show what we actually found\r\n              snippet: txt ? txt.substring(0, 150) + \"...\" : \"Visual Document (Table/Chart/Scan)\",\r\n              \r\n              score: score,\r\n              pageNumbers: [], // Required field for SearchResult\r\n              document: {}, // Required field for SearchResult\r\n              screenshots: rawImage ? [rawImage] : [],\r\n              mimeType: detectedMimeType, // Pass the TRUE type\r\n              extractedText: txt,\r\n              // Include document URL for redirect functionality - use the database document ID if available\r\n              documentUrl: finalDocumentId ? `/repository/preview/${finalDocumentId}` : undefined\r\n            };\r\n          });\r\n\r\n        // 2. DEDUPLICATE (Kill the Zombies)\r\n        const uniqueMap = new Map();\r\n        const cleanResults = [];\r\n\r\n        for (const doc of rawMapped) {\r\n            // Use documentId or Title as unique key to prevent duplicates\r\n            const key = doc.documentId || doc.title;\r\n            if (!uniqueMap.has(key)) {\r\n                uniqueMap.set(key, true);\r\n                cleanResults.push(doc);\r\n            }\r\n        }\r\n        \r\n        // For comprehensive queries (like \"what trainings/seminars did...\"), use more results\r\n        const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                    query.toLowerCase().includes('all') ||\r\n                                    query.toLowerCase().includes('every') ||\r\n                                    query.toLowerCase().includes('faculty') ||\r\n                                    query.toLowerCase().includes('training') ||\r\n                                    query.toLowerCase().includes('seminar') ||\r\n                                    query.toLowerCase().includes('attended') ||\r\n                                    query.toLowerCase().includes('presentation') ||\r\n                                    query.toLowerCase().includes('research') ||\r\n                                    (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                    (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                    (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                    (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n        \r\n        searchResults = isComprehensiveQuery ? cleanResults.slice(0, 6) : cleanResults.slice(0, 1); // Use more results for comprehensive queries\r\n        \r\n        // Update the response results to include the visual content for caching\r\n        // This ensures that when the response is cached, it includes the visual content needed for multimodal processing\r\n        if (cleanResults.length > 0) {\r\n          // Map the cleanResults (with visual content) to the searchResults\r\n          searchResults = isComprehensiveQuery ? cleanResults.slice(0, 6) : cleanResults.slice(0, 1);\r\n        }\r\n      } catch (colivaraError) {\r\n        console.error('Colivara search failed, falling back to traditional search:', colivaraError);\r\n        // Fall back to traditional search if Colivara fails\r\n        searchType = 'traditional';\r\n        // Use traditional search\r\n        const traditionalResults = await enhancedDocumentService.searchDocuments(\r\n          query,\r\n          normalizedUnitId,\r\n          normalizedCategory,\r\n          undefined, // tags\r\n          userId,\r\n          page,\r\n          limit\r\n        );\r\n        \r\n        // Format traditional results to match expected response structure\r\n        // Map traditional results to the same format as Colivara results using SuperMapper\r\n        const formattedResults = traditionalResults.documents.map(doc => ({\r\n          documentId: doc.id,\r\n          title: cleanDocumentTitle(doc.title || doc.fileName || 'Untitled Document'),\r\n          content: doc.description || '',\r\n          score: 0.5, // Default score for traditional search\r\n          pageNumbers: [],\r\n          documentSection: 'description',\r\n          confidenceScore: 0.5,\r\n          snippet: doc.description ? doc.description.substring(0, 200) + '...' : 'No preview available',\r\n          document: SuperMapper.createStandardDocument(doc) // Process through SuperMapper\r\n        }));\r\n\r\n        // Group and deduplicate results to avoid showing the same document multiple times\r\n        const groupedResults = groupResults(formattedResults);\r\n        searchResults = groupedResults;\r\n      }\r\n    } else {\r\n      // Use traditional search\r\n      searchType = 'traditional';\r\n      const traditionalResults = await enhancedDocumentService.searchDocuments(\r\n        query,\r\n        normalizedUnitId,\r\n        normalizedCategory,\r\n        undefined, // tags\r\n        userId,\r\n        page,\r\n        limit\r\n      );\r\n      \r\n      // Format traditional results to match expected response structure\r\n      // Map traditional results to the same format as Colivara results using SuperMapper\r\n      const formattedResults = traditionalResults.documents.map(doc => ({\r\n        documentId: doc.id,\r\n        title: cleanDocumentTitle(doc.title || doc.fileName || 'Untitled Document'),\r\n        content: doc.description || '',\r\n        score: 0.5, // Default score for traditional search\r\n        pageNumbers: [],\r\n        documentSection: 'description',\r\n        confidenceScore: 0.5,\r\n        snippet: doc.description ? doc.description.substring(0, 200) + '...' : 'No preview available',\r\n        document: SuperMapper.createStandardDocument(doc) // Process through SuperMapper\r\n      }));\r\n\r\n      // Group and deduplicate results to avoid showing the same document multiple times\r\n      const groupedResults = groupResults(formattedResults);\r\n      searchResults = groupedResults;\r\n    }\r\n\r\n    // If generateResponse is true, use Qwen to generate a response based on the search results\r\n    let generatedResponse = null;\r\n    let sources: Source[] = [];\r\n    let relevantDocumentUrl = null;\r\n    if (generateResponse && searchResults && searchResults.length > 0) {\r\n      try {\r\n        // For queries asking for comprehensive lists (like faculty and their trainings), use more results\r\n        const isComprehensiveQuery = query.toLowerCase().includes('list') ||\r\n                                    query.toLowerCase().includes('all') ||\r\n                                    query.toLowerCase().includes('every') ||\r\n                                    query.toLowerCase().includes('faculty') ||\r\n                                    query.toLowerCase().includes('training') ||\r\n                                    query.toLowerCase().includes('seminar') ||\r\n                                    query.toLowerCase().includes('attended') ||\r\n                                    query.toLowerCase().includes('presentation') ||\r\n                                    query.toLowerCase().includes('research') ||\r\n                                    (query.toLowerCase().includes('what') && query.toLowerCase().includes('training')) ||\r\n                                    (query.toLowerCase().includes('what') && query.toLowerCase().includes('seminar')) ||\r\n                                    (query.toLowerCase().includes('which') && query.toLowerCase().includes('training')) ||\r\n                                    (query.toLowerCase().includes('which') && query.toLowerCase().includes('seminar'));\r\n        \r\n        const resultsForGeneration = isComprehensiveQuery ?\r\n          searchResults.slice(0, Math.min(6, searchResults.length)) : // Use up to 6 results for comprehensive queries\r\n          searchResults.slice(0, 1);  // Use only top result for specific queries\r\n          \r\n        // Use generateInsights to get both the response and the sources used\r\n        const qwenService = new QwenGenerationService({ model: process.env.QWEN_MODEL || 'qwen/qwen-2.5-vl-72b-instruct' });\r\n        const qwenResult = await qwenService.generateInsights(\r\n          query,\r\n          resultsForGeneration,\r\n          userId\r\n        );\r\n        \r\n        generatedResponse = qwenResult.summary;\r\n        \r\n        // Include all relevant sources for comprehensive queries, otherwise just the top one\r\n        // Clean the title in the source and ensure we have the database document ID\r\n        const cleanedSources = qwenResult.sources && qwenResult.sources.length > 0 ?\r\n          qwenResult.sources.map(source => {\r\n            // Try to get the database document ID from the resultsForGeneration\r\n            const originalResult = resultsForGeneration.find(result =>\r\n              result.documentId === source.documentId || result.originalDocumentId === source.documentId\r\n            );\r\n            \r\n            // Use the database document ID if available, otherwise fallback to the source.documentId\r\n            const databaseDocumentId = originalResult?.originalDocumentId || source.documentId;\r\n            \r\n            return {\r\n              ...source,\r\n              title: cleanDocumentTitle(source.title),\r\n              documentId: databaseDocumentId // Use the database document ID for clicking\r\n            };\r\n          }) : [];\r\n            \r\n        sources = cleanedSources;\r\n          \r\n        // Include the document URL for the relevant document in the response\r\n        if (searchResults.length > 0 && sources.length > 0) {\r\n          // Find the document that corresponds to the source and add its URL\r\n          const relevantDoc = searchResults.find(doc => doc.documentId === sources[0].documentId);\r\n          if (relevantDoc && relevantDoc.documentUrl) {\r\n            relevantDocumentUrl = relevantDoc.documentUrl;\r\n          } else {\r\n            // Fallback: try to find document by originalDocumentId if documentId doesn't match\r\n            const relevantDocFallback = searchResults.find(doc => doc.originalDocumentId === sources[0].documentId);\r\n            if (relevantDocFallback && relevantDocFallback.documentUrl) {\r\n              relevantDocumentUrl = relevantDocFallback.documentUrl;\r\n            }\r\n          }\r\n        }\r\n      } catch (generationError) {\r\n        console.error('Qwen generation failed:', generationError);\r\n        // Don't fail the entire request if generation fails, just return search results\r\n        generatedResponse = null;\r\n      }\r\n    }\r\n\r\n    // Return search results with optional generated response\r\n    let responseResults = searchResults;\r\n    \r\n    // If generateResponse is true, limit results to the most relevant document\r\n    if (generateResponse && searchResults && searchResults.length > 0) {\r\n      // Use only the top result for display when generating AI response\r\n      responseResults = searchResults.slice(0, 1);\r\n    }\r\n\r\n    const response: any = {\r\n      results: responseResults,\r\n      total: responseResults.length, // Use actual count after potential filtering\r\n      page,\r\n      limit,\r\n      totalPages: Math.ceil(searchResults.length / limit), // Keep original total for pagination reference\r\n      query,\r\n      processingTime,\r\n      searchType,\r\n    };\r\n\r\n    // Include generated response and sources if available\r\n    if (generatedResponse) {\r\n      response.generatedResponse = generatedResponse;\r\n      response.generationType = generationType;\r\n      response.sources = sources;\r\n      \r\n      // Include the document URL for the relevant document in the response\r\n      if (relevantDocumentUrl) {\r\n        response.relevantDocumentUrl = relevantDocumentUrl;\r\n      }\r\n    }\r\n\r\n    // Store results in cache before returning\r\n    // Before caching, ensure the response results include visual content if it exists\r\n    await searchCacheService.setCachedResult(query, response, normalizedUnitId, normalizedCategory, normalizedFilters);\r\n    return NextResponse.json(response);\r\n  } catch (error) {\r\n    console.error('Error in search API:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error during search' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}"],"names":[],"mappings":"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"}}]
}