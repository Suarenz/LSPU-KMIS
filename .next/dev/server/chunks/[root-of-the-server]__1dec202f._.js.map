{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/jwt-service.ts"],"sourcesContent":["// This service is for handling custom JWT tokens for database authentication\r\n\r\nexport interface TokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n  iat: number;\r\n  exp: number;\r\n}\r\n\r\nclass JWTService {\r\n  private readonly secret: string;\r\n\r\n  constructor() {\r\n    this.secret = process.env.JWT_SECRET || '6dFk5d0vbyLnZC0Amy83LtI47DsNr/KB4M+FgbUc6njd4cjk7XB2/8nTuhQDWW8OOgQ6fI74huxJE3a/RP2giw==';\r\n  }\r\n\r\n  /**\r\n   * Convert a string to a Uint8Array (which can be used with Web Crypto API)\r\n   */\r\n private stringToUint8Array(str: string): Uint8Array {\r\n    return new TextEncoder().encode(str);\r\n }\r\n\r\n /**\r\n  * Convert a Uint8Array to a base64url encoded string\r\n  */\r\n private uint8ArrayToBase64Url(uint8Array: Uint8Array): string {\r\n   let binary = '';\r\n   for (let i = 0; i < uint8Array.byteLength; i++) {\r\n     binary += String.fromCharCode(uint8Array[i]);\r\n   }\r\n   return btoa(binary)\r\n     .replace(/\\+/g, '-')\r\n     .replace(/\\//g, '_')\r\n     .replace(/=/g, '');\r\n }\r\n\r\n  /**\r\n   * Import the secret as a CryptoKey for use with Web Crypto API\r\n   */\r\n  private async importSecret(): Promise<CryptoKey> {\r\n    const encoder = new TextEncoder();\r\n    const keyBuffer = encoder.encode(this.secret);\r\n    \r\n    return await crypto.subtle.importKey(\r\n      'raw',\r\n      keyBuffer,\r\n      { name: 'HMAC', hash: 'SHA-256' },\r\n      false,\r\n      ['sign', 'verify']\r\n    );\r\n  }\r\n\r\n /**\r\n   * Generate a JWT token using Web Crypto API\r\n   */\r\n  async generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): Promise<string> {\r\n    try {\r\n      // Create the header\r\n      const header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n      };\r\n\r\n      // Add timestamp and expiration (1 hour from now)\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const expiration = timestamp + 3600; // 1 hour in seconds\r\n\r\n      // Create the payload with the provided data and timestamps\r\n      const fullPayload = {\r\n        ...payload,\r\n        iat: timestamp,\r\n        exp: expiration\r\n      };\r\n\r\n      // Encode header and payload to base64url\r\n      const encodedHeader = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(header))\r\n      );\r\n      const encodedPayload = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(fullPayload))\r\n      );\r\n\r\n      // Create the signing input\r\n      const signingInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Create signing input buffer in the proper format for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const signingInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Sign the token - use type assertion to handle TypeScript compatibility issues\r\n      const signatureBuffer = await crypto.subtle.sign(\r\n        'HMAC',\r\n        key,\r\n        signingInputBuffer as BufferSource\r\n      );\r\n\r\n      // Encode the signature - signatureBuffer is an ArrayBuffer, convert to base64url\r\n      const signatureUint8Array = new Uint8Array(signatureBuffer);\r\n      const encodedSignature = this.uint8ArrayToBase64Url(signatureUint8Array);\r\n\r\n      // Return the complete JWT token\r\n      return `${signingInput}.${encodedSignature}`;\r\n    } catch (error) {\r\n      console.error('JWT token generation failed:', error);\r\n      throw new Error('Failed to generate JWT token');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a JWT token using Web Crypto API\r\n   */\r\n  async verifyToken(token: string): Promise<TokenPayload | null> {\r\n    try {\r\n      // Check if token is valid before attempting to verify\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        console.error('Invalid token provided for verification');\r\n        return null;\r\n      }\r\n      \r\n      // Check if token has proper format (3 parts separated by dots)\r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const [encodedHeader, encodedPayload, encodedSignature] = tokenParts;\r\n\r\n      // Decode header\r\n      const decodedHeader = this.base64UrlDecode(encodedHeader);\r\n      if (!decodedHeader) {\r\n        console.error('Failed to decode token header');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const decodedPayloadStr = this.base64UrlDecode(encodedPayload);\r\n      if (!decodedPayloadStr) {\r\n        console.error('Failed to decode token payload');\r\n        return null;\r\n      }\r\n\r\n      // Parse payload\r\n      const payloadObj = JSON.parse(decodedPayloadStr) as TokenPayload;\r\n      \r\n      // Check if token is expired\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      if (payloadObj.exp && payloadObj.exp < currentTime) {\r\n        console.error('Token has expired');\r\n        return null;\r\n      }\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Verify the signature\r\n      const isValid = await this.verifySignature(\r\n        `${encodedHeader}.${encodedPayload}`,\r\n        encodedSignature,\r\n        key\r\n      );\r\n\r\n      if (!isValid) {\r\n        console.error('Token signature verification failed');\r\n        return null;\r\n      }\r\n\r\n      return payloadObj;\r\n    } catch (error: any) {\r\n      console.error('Token verification failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify the JWT signature using Web Crypto API\r\n   */\r\n  private async verifySignature(\r\n    signingInput: string,\r\n    signature: string,\r\n    key: CryptoKey\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Decode the signature from base64url to Uint8Array\r\n      const signatureBytes = this.base64UrlDecodeToUint8Array(signature);\r\n      if (!signatureBytes) {\r\n        return false;\r\n      }\r\n\r\n      // Create proper buffers for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const verificationInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Use ArrayBufferView for signatureBytes and input buffer\r\n      // Cast to appropriate types to handle TypeScript issues\r\n      const signatureView = new Uint8Array(signatureBytes.buffer, signatureBytes.byteOffset, signatureBytes.byteLength);\r\n      const inputView = new Uint8Array(verificationInputBuffer.buffer, verificationInputBuffer.byteOffset, verificationInputBuffer.byteLength);\r\n      \r\n      // Verify the signature - use type assertion to handle TypeScript compatibility issues\r\n      const isValid = await crypto.subtle.verify(\r\n        'HMAC',\r\n        key,\r\n        signatureView as BufferSource,\r\n        inputView as BufferSource\r\n      );\r\n\r\n      return isValid;\r\n    } catch (error) {\r\n      console.error('Signature verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Decode a JWT token without verification (for edge runtime compatibility)\r\n   * This only extracts the payload without validating the signature\r\n   * Use carefully - only for non-sensitive operations like checking expiration\r\n   */\r\n  decodeToken(token: string): TokenPayload | null {\r\n    try {\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        return null;\r\n      }\r\n      \r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const payload = tokenParts[1];\r\n      const decodedPayload = this.base64UrlDecode(payload);\r\n      if (!decodedPayload) {\r\n        return null;\r\n      }\r\n      \r\n      return JSON.parse(decodedPayload) as TokenPayload;\r\n    } catch (error: any) {\r\n      console.error('Token decoding failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token is expired without full verification\r\n   * This uses the decode method which doesn't require the secret\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      const decoded = this.decodeToken(token);\r\n      if (!decoded || !decoded.exp) {\r\n        return true; // If we can't decode or there's no expiration, consider it expired\r\n      }\r\n      // Compare expiration timestamp with current time (in seconds)\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      return decoded.exp < currentTime;\r\n    } catch (error) {\r\n      console.error('Error checking token expiration:', error);\r\n      return true; // If there's an error, assume token is expired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url encoded strings\r\n   */\r\n  private base64UrlDecode(str: string): string | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      return decodeURIComponent(escape(rawData));\r\n    } catch (error) {\r\n      console.error('Base64 URL decode error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url string to Uint8Array\r\n   */\r\n  private base64UrlDecodeToUint8Array(str: string): Uint8Array | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      \r\n      const buffer = new Uint8Array(rawData.length);\r\n      for (let i = 0; i < rawData.length; i++) {\r\n        buffer[i] = rawData.charCodeAt(i);\r\n      }\r\n      \r\n      return buffer;\r\n    } catch (error) {\r\n      console.error('Base64 URL decode to Uint8Array error:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new JWTService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\n// Create Prisma client instance\r\nconst createPrismaClient = () => {\r\n  return new PrismaClient({\r\n    log: ['query', 'info', 'warn', 'error'], // Enable detailed logging\r\n  })\r\n}\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined\r\n}\r\n\r\n// Use the global instance in development to prevent exceeding connection limits\r\nconst client = globalThis.prisma || createPrismaClient()\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = client\r\n\r\nexport default client"],"names":[],"mappings":";;;;AAAA;;AAEA,gCAAgC;AAChC,MAAM,qBAAqB;IACzB,OAAO,IAAI,6IAAY,CAAC;QACtB,KAAK;YAAC;YAAS;YAAQ;YAAQ;SAAQ;IACzC;AACF;AAOA,gFAAgF;AAChF,MAAM,SAAS,WAAW,MAAM,IAAI;AACpC,wCAA2C,WAAW,MAAM,GAAG;uCAEhD"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/utils/rbac.ts"],"sourcesContent":["/**\r\n * Role-Based Access Control (RBAC) utilities for LSPU KMIS\r\n * Defines role hierarchies and permission checks\r\n */\r\n\r\nexport type UserRole = 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL';\r\n\r\n// Define role hierarchy - ADMIN has highest privileges, followed by FACULTY, STUDENT, then EXTERNAL\r\nconst ROLE_HIERARCHY: Record<UserRole, number> = {\r\n  'ADMIN': 4,\r\n  'FACULTY': 3,\r\n  'STUDENT': 2,\r\n  'EXTERNAL': 1\r\n};\r\n\r\n/**\r\n * Check if a user has a specific role\r\n */\r\nexport function hasRole(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return userRole === requiredRole;\r\n}\r\n\r\n/**\r\n * Check if a user has any of the specified roles\r\n */\r\nexport function hasAnyRole(userRole: UserRole, requiredRoles: UserRole[]): boolean {\r\n  return requiredRoles.includes(userRole);\r\n}\r\n\r\n/**\r\n * Check if a user's role has higher or equal hierarchy than required role\r\n */\r\nexport function hasRoleHierarchy(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];\r\n}\r\n\r\n/**\r\n * Check if user has admin privileges\r\n */\r\nexport function isAdmin(userRole: UserRole): boolean {\r\n  return userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has faculty privileges\r\n */\r\nexport function isFaculty(userRole: UserRole): boolean {\r\n  return userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has student privileges\r\n */\r\nexport function isStudent(userRole: UserRole): boolean {\r\n  return userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has external privileges\r\n */\r\nexport function isExternal(userRole: UserRole): boolean {\r\n  return userRole === 'EXTERNAL' || userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Get allowed actions based on user role\r\n */\r\nexport function getAllowedActions(userRole: UserRole): string[] {\r\n  switch (userRole) {\r\n    case 'ADMIN':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'DELETE_DOCUMENT',\r\n        'CREATE_USER',\r\n        'READ_USER',\r\n        'UPDATE_USER',\r\n        'DELETE_USER',\r\n        'CREATE_UNIT',\r\n        'READ_UNIT',\r\n        'UPDATE_UNIT',\r\n        'DELETE_UNIT',\r\n        'MANAGE_PERMISSIONS',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'FACULTY':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'STUDENT':\r\n      return [\r\n        'READ_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT'\r\n      ];\r\n    case 'EXTERNAL':\r\n      return [\r\n        'READ_DOCUMENT'\r\n      ];\r\n    default:\r\n      return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a user has permission to perform an action\r\n */\r\nexport function hasPermission(userRole: UserRole, action: string): boolean {\r\n  const allowedActions = getAllowedActions(userRole);\r\n  return allowedActions.includes(action);\r\n}\r\n\r\n/**\r\n * Get all roles that can perform a specific action\r\n */\r\nexport function getRolesForAction(action: string): UserRole[] {\r\n  const roles: UserRole[] = [];\r\n  (Object.keys(ROLE_HIERARCHY) as UserRole[]).forEach(role => {\r\n    if (hasPermission(role, action)) {\r\n      roles.push(role);\r\n    }\r\n  });\r\n  return roles;\r\n}"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;;;AAID,oGAAoG;AACpG,MAAM,iBAA2C;IAC/C,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY;AACd;AAKO,SAAS,QAAQ,QAAkB,EAAE,YAAsB;IAChE,OAAO,aAAa;AACtB;AAKO,SAAS,WAAW,QAAkB,EAAE,aAAyB;IACtE,OAAO,cAAc,QAAQ,CAAC;AAChC;AAKO,SAAS,iBAAiB,QAAkB,EAAE,YAAsB;IACzE,OAAO,cAAc,CAAC,SAAS,IAAI,cAAc,CAAC,aAAa;AACjE;AAKO,SAAS,QAAQ,QAAkB;IACxC,OAAO,aAAa;AACtB;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa;AAChD;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa,aAAa,aAAa;AAC1E;AAKO,SAAS,WAAW,QAAkB;IAC3C,OAAO,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa;AACrG;AAKO,SAAS,kBAAkB,QAAkB;IAClD,OAAQ;QACN,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;aACD;QACH;YACE,OAAO,EAAE;IACb;AACF;AAKO,SAAS,cAAc,QAAkB,EAAE,MAAc;IAC9D,MAAM,iBAAiB,kBAAkB;IACzC,OAAO,eAAe,QAAQ,CAAC;AACjC;AAKO,SAAS,kBAAkB,MAAc;IAC9C,MAAM,QAAoB,EAAE;IAC3B,OAAO,IAAI,CAAC,gBAA+B,OAAO,CAAC,CAAA;QAClD,IAAI,cAAc,MAAM,SAAS;YAC/B,MAAM,IAAI,CAAC;QACb;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/middleware/auth-middleware.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { NextResponse } from 'next/server';\r\nimport jwtService from '@/lib/services/jwt-service';\r\nimport prisma from '@/lib/prisma';\r\nimport { hasAnyRole, type UserRole } from '@/lib/utils/rbac';\r\n\r\nexport async function requireAuth(request: NextRequest, roles?: string[]): Promise<{ user: any } | NextResponse> {\r\n  // Extract the token from the Authorization header or cookies\r\n  const authHeader = request.headers.get('authorization');\r\n  let token = null;\r\n  \r\n  if (authHeader && authHeader.startsWith('Bearer ')) {\r\n    token = authHeader.substring(7);\r\n  } else {\r\n    // Try to get token from cookies\r\n    const cookies = request.cookies;\r\n    token = cookies.get('access_token')?.value;\r\n  }\r\n\r\n  if (!token) {\r\n    // For API routes, return a 401 response instead of redirecting\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });\r\n    }\r\n    // For regular routes, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n  }\r\n\r\n  // Verify the JWT token\r\n  const decoded = await jwtService.verifyToken(token);\r\n  if (!decoded) {\r\n    console.error('Token verification failed:', token ? token.substring(0, 20) + '...' : 'null');\r\n    // Token is invalid, return appropriate response based on request type\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 });\r\n    } else {\r\n      // For regular routes, redirect to login\r\n      const response = NextResponse.redirect(new URL('/', request.url));\r\n      return response;\r\n    }\r\n }\r\n\r\n  console.log('Decoded token:', decoded);\r\n\r\n  // Check if decoded.userId is valid\r\n  if (!decoded.userId) {\r\n    console.error('Token does not contain userId:', decoded);\r\n    // Token doesn't contain a valid userId, return error\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid token: missing user ID' }, { status: 401 });\r\n    }\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Get user profile from database using the user ID from the token\r\n  const user = await prisma.user.findUnique({\r\n    where: {\r\n      id: decoded.userId,\r\n    },\r\n    select: {\r\n      id: true,\r\n      email: true,\r\n      name: true,\r\n      role: true,\r\n      unitId: true,\r\n    }\r\n  });\r\n\r\n  if (!user) {\r\n    console.error('User not found with ID from token:', decoded.userId);\r\n    // User doesn't exist in the database, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Check if user has required roles\r\n  if (roles && roles.length > 0 && !hasAnyRole(user.role as UserRole, roles as UserRole[])) {\r\n    // User doesn't have required role, return error for API routes\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'User does not have required role to perform this action' }, { status: 403 });\r\n    }\r\n    // For regular routes, redirect to unauthorized page\r\n    const response = NextResponse.redirect(new URL('/unauthorized', request.url));\r\n    return response;\r\n  }\r\n\r\n  return { user };\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEO,eAAe,YAAY,OAAoB,EAAE,KAAgB;IACtE,6DAA6D;IAC7D,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,QAAQ;IAEZ,IAAI,cAAc,WAAW,UAAU,CAAC,YAAY;QAClD,QAAQ,WAAW,SAAS,CAAC;IAC/B,OAAO;QACL,gCAAgC;QAChC,MAAM,UAAU,QAAQ,OAAO;QAC/B,QAAQ,QAAQ,GAAG,CAAC,iBAAiB;IACvC;IAEA,IAAI,CAAC,OAAO;QACV,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QACA,wCAAwC;QACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACT;IAEA,uBAAuB;IACvB,MAAM,UAAU,MAAM,8IAAU,CAAC,WAAW,CAAC;IAC7C,IAAI,CAAC,SAAS;QACZ,QAAQ,KAAK,CAAC,8BAA8B,QAAQ,MAAM,SAAS,CAAC,GAAG,MAAM,QAAQ;QACrF,sEAAsE;QACtE,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAChF,OAAO;YACL,wCAAwC;YACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;YAC/D,OAAO;QACT;IACH;IAEC,QAAQ,GAAG,CAAC,kBAAkB;IAE9B,mCAAmC;IACnC,IAAI,CAAC,QAAQ,MAAM,EAAE;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,qDAAqD;QACrD,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiC,GAAG;gBAAE,QAAQ;YAAI;QACtF;QACA,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,kEAAkE;IAClE,MAAM,OAAO,MAAM,0HAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YACL,IAAI,QAAQ,MAAM;QACpB;QACA,QAAQ;YACN,IAAI;YACJ,OAAO;YACP,MAAM;YACN,MAAM;YACN,QAAQ;QACV;IACF;IAEA,IAAI,CAAC,MAAM;QACT,QAAQ,KAAK,CAAC,sCAAsC,QAAQ,MAAM;QAClE,wDAAwD;QACxD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,mCAAmC;IACnC,IAAI,SAAS,MAAM,MAAM,GAAG,KAAK,CAAC,IAAA,oIAAU,EAAC,KAAK,IAAI,EAAc,QAAsB;QACxF,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0D,GAAG;gBAAE,QAAQ;YAAI;QAC/G;QACA,oDAAoD;QACpD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;QAC3E,OAAO;IACT;IAEA,OAAO;QAAE;IAAK;AAChB"}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/file-storage-service.ts"],"sourcesContent":["import { BlobServiceClient, generateBlobSASQueryParameters, BlobSASPermissions } from '@azure/storage-blob';\r\nimport { randomUUID } from 'crypto';\r\nimport { createHash } from 'crypto';\r\n\r\nclass FileStorageService {\r\n  private readonly blobServiceClient: BlobServiceClient;\r\n  private readonly containerName: string = 'repository-files';\r\n\r\n  constructor() {\r\n    const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;\r\n    if (!connectionString) {\r\n      throw new Error('Azure Storage connection string is not configured');\r\n    }\r\n    this.blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);\r\n  }\r\n\r\n  async saveFile(file: File, originalFileName: string): Promise<{url: string, blobName: string, metadata: any}> {\r\n    console.log('Starting file upload process to Azure Blob Storage...');\r\n    \r\n    // Validate file type\r\n    const allowedTypes = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'txt', 'jpg', 'jpeg', 'png'];\r\n    const fileExt = this.getFileExtension(originalFileName).toLowerCase();\r\n    \r\n    if (!allowedTypes.includes(fileExt)) {\r\n      throw new Error(`File type ${fileExt} is not allowed. Allowed types: ${allowedTypes.join(', ')}`);\r\n    }\r\n\r\n    // Validate file size (e.g., max 50MB)\r\n    const maxSize = 50 * 1024 * 1024; // 50MB in bytes\r\n    if (file.size > maxSize) {\r\n      throw new Error(`File size exceeds maximum allowed size of ${maxSize} bytes`);\r\n    }\r\n\r\n    // Generate a unique filename to prevent conflicts\r\n    const uniqueFileName = `${randomUUID()}.${fileExt}`;\r\n    console.log('Generated unique filename:', uniqueFileName);\r\n    \r\n    // Convert File object to buffer\r\n    const buffer = Buffer.from(await file.arrayBuffer());\r\n    console.log('File converted to buffer, size:', buffer.length);\r\n    \r\n    // Basic security: scan file content for known malicious patterns\r\n    await this.scanFileForMaliciousContent(buffer);\r\n    console.log('File security scan completed');\r\n\r\n    // Upload to Azure Blob Storage\r\n    const containerClient = this.blobServiceClient.getContainerClient(this.containerName);\r\n    const blockBlobClient = containerClient.getBlockBlobClient(uniqueFileName);\r\n    \r\n    const uploadOptions = {\r\n      blobHTTPHeaders: {\r\n        blobContentType: file.type || this.getMimeTypeFromExtension(fileExt)\r\n      }\r\n    };\r\n\r\n    const uploadBlobResponse = await blockBlobClient.uploadData(buffer, uploadOptions);\r\n    console.log('Upload result:', uploadBlobResponse.requestId);\r\n\r\n    // Extract basic metadata from the file\r\n    const metadata = {\r\n      originalName: originalFileName,\r\n      size: file.size,\r\n      type: file.type,\r\n      extension: fileExt,\r\n      uploadedAt: new Date(),\r\n      lastModified: file.lastModified ? new Date(file.lastModified) : new Date(),\r\n      hash: createHash('sha256').update(buffer).digest('hex'), // File integrity hash\r\n    };\r\n\r\n    // Return both the URL and metadata, including the blob name\r\n    return {\r\n      url: blockBlobClient.url,\r\n      blobName: uniqueFileName,\r\n      metadata\r\n    };\r\n  }\r\n\r\n  async deleteFile(fileUrl: string): Promise<boolean> {\r\n    try {\r\n      console.log('Deleting file:', fileUrl);\r\n      const fileName = this.getFileNameFromUrl(fileUrl);\r\n      console.log('Extracted filename:', fileName);\r\n      \r\n      const containerClient = this.blobServiceClient.getContainerClient(this.containerName);\r\n      const blockBlobClient = containerClient.getBlockBlobClient(fileName);\r\n      \r\n      const deleteResponse = await blockBlobClient.delete();\r\n      console.log('Delete result:', deleteResponse.requestId);\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting file:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getFileUrl(fileName: string, containerName: string = 'repository-files'): Promise<string> {\r\n    console.log('Getting file URL for:', { fileName, containerName });\r\n    const containerClient = this.blobServiceClient.getContainerClient(containerName);\r\n    const blockBlobClient = containerClient.getBlockBlobClient(fileName);\r\n    \r\n    // Generate a time-limited SAS URL for secure access\r\n    const expiryDate = new Date();\r\n    expiryDate.setHours(expiryDate.getHours() + 1); // URL expires in 1 hour\r\n    \r\n    // Get the account name from the connection string for SAS generation\r\n    const accountName = process.env.AZURE_STORAGE_ACCOUNT_NAME;\r\n    if (!accountName) {\r\n      throw new Error('Azure Storage account name is not configured');\r\n    }\r\n\r\n    // Create SAS permissions object properly\r\n    const permissions = new BlobSASPermissions();\r\n    permissions.read = true;\r\n    \r\n    const sasOptions = {\r\n      containerName: containerName,\r\n      blobName: fileName,\r\n      permissions: permissions,\r\n      expiresOn: expiryDate,\r\n    };\r\n    \r\n    // Get the account key for SAS generation\r\n    const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;\r\n    if (!connectionString) {\r\n      throw new Error('Azure Storage connection string is not configured');\r\n    }\r\n\r\n    // Extract account key from connection string\r\n    const accountKeyMatch = connectionString.match(/AccountKey=([^;]+)/);\r\n    if (!accountKeyMatch) {\r\n      throw new Error('Account key not found in connection string');\r\n    }\r\n    const accountKey = accountKeyMatch[1];\r\n    \r\n    // Create a StorageSharedKeyCredential for SAS generation\r\n    const { StorageSharedKeyCredential } = await import('@azure/storage-blob');\r\n    const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);\r\n    \r\n    const sasToken = generateBlobSASQueryParameters(sasOptions, sharedKeyCredential);\r\n    return `${blockBlobClient.url}?${sasToken}`;\r\n  }\r\n\r\n  async validateAndExtractMetadata(file: File, originalFileName: string) {\r\n    // Validate file type\r\n    const allowedTypes = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'txt', 'jpg', 'jpeg', 'png'];\r\n    const fileExt = this.getFileExtension(originalFileName).toLowerCase();\r\n    \r\n    if (!allowedTypes.includes(fileExt)) {\r\n      throw new Error(`File type ${fileExt} is not allowed. Allowed types: ${allowedTypes.join(', ')}`);\r\n    }\r\n\r\n    // Validate file size (e.g., max 50MB)\r\n    const maxSize = 50 * 1024 * 1024; // 50MB in bytes\r\n    if (file.size > maxSize) {\r\n      throw new Error(`File size exceeds maximum allowed size of ${maxSize} bytes`);\r\n    }\r\n\r\n    // Extract metadata from the file\r\n    const metadata = {\r\n      originalName: originalFileName,\r\n      size: file.size,\r\n      type: file.type,\r\n      extension: fileExt,\r\n      uploadedAt: new Date(),\r\n      lastModified: file.lastModified ? new Date(file.lastModified) : new Date(),\r\n    };\r\n\r\n    return metadata;\r\n  }\r\n\r\n  private async scanFileForMaliciousContent(buffer: Buffer): Promise<void> {\r\n    // Basic security check: scan for known malicious patterns in file content\r\n    const maliciousPatterns = [\r\n      /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, // JavaScript in HTML\r\n      /<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, // iframe tags\r\n      /<object\\b[^<]*(?:(?!<\\/object>)<[^<]*)*<\\/object>/gi, // object tags\r\n      /<embed\\b[^<]*(?:(?!<\\/embed>)<[^<]*)*<\\/embed>/gi, // embed tags\r\n      /<form\\b[^<]*(?:(?!<\\/form>)<[^<]*)*<\\/form>/gi, // form tags\r\n      /javascript:/gi, // javascript: URLs\r\n      /vbscript:/gi, // vbscript: URLs\r\n      /onload=/gi, // onload events\r\n      /onerror=/gi, // onerror events\r\n      /onmouseover=/gi, // mouseover events\r\n      /onfocus=/gi, // focus events\r\n    ];\r\n\r\n    const fileContent = buffer.toString('utf-8');\r\n\r\n    for (const pattern of maliciousPatterns) {\r\n      if (pattern.test(fileContent)) {\r\n        throw new Error('File contains potentially malicious content');\r\n      }\r\n    }\r\n  }\r\n\r\n  private getFileExtension(fileName: string): string {\r\n    return fileName.split('.').pop() || '';\r\n  }\r\n\r\n  private getFileNameFromUrl(fileUrl: string): string {\r\n    // Remove query parameters first (e.g., SAS tokens)\r\n    const urlWithoutParams = fileUrl.split('?')[0];\r\n    return urlWithoutParams.split('/').pop() || '';\r\n  }\r\n\r\n  private getMimeTypeFromExtension(extension: string): string {\r\n    const mimeTypes: { [key: string]: string } = {\r\n      'pdf': 'application/pdf',\r\n      'doc': 'application/msword',\r\n      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n      'ppt': 'application/vnd.ms-powerpoint',\r\n      'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\r\n      'xls': 'application/vnd.ms-excel',\r\n      'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n      'txt': 'text/plain',\r\n      'jpg': 'image/jpeg',\r\n      'jpeg': 'image/jpeg',\r\n      'png': 'image/png'\r\n    };\r\n\r\n    return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';\r\n  }\r\n}\r\n\r\nexport default new FileStorageService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 917, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/colivara-error-handler.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport ColivaraService from './colivara-service';\r\nimport { Document } from '@/lib/api/types';\r\n\r\nexport enum ColivaraErrorType {\r\n  API_UNAVAILABLE = 'API_UNAVAILABLE',\r\n  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',\r\n  AUTHENTICATION_FAILED = 'AUTHENTICATION_FAILED',\r\n  PROCESSING_FAILED = 'PROCESSING_FAILED',\r\n  TIMEOUT = 'TIMEOUT',\r\n  INVALID_RESPONSE = 'INVALID_RESPONSE',\r\n  NETWORK_ERROR = 'NETWORK_ERROR',\r\n  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',\r\n}\r\n\r\nexport class ColivaraError extends Error {\r\n  constructor(\r\n    public type: ColivaraErrorType,\r\n    message: string,\r\n    public originalError?: any,\r\n    public status?: number\r\n  ) {\r\n    super(message);\r\n    this.name = 'ColivaraError';\r\n  }\r\n}\r\n\r\nexport interface ErrorHandlingOptions {\r\n  maxRetries?: number;\r\n  retryDelay?: number;\r\n  fallbackToTraditional?: boolean;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface ProcessingResult {\r\n  success: boolean;\r\n  error?: ColivaraError;\r\n  fallbackUsed?: boolean;\r\n  data?: any;\r\n}\r\n\r\nexport class ColivaraErrorHandler {\r\n  private static instance: ColivaraErrorHandler;\r\n  private circuitBreakerOpen = false;\r\n  private lastFailureTime: Date | null = null;\r\n  private failureCount = 0;\r\n  private maxFailures = 5;\r\n  private resetTimeout = 300000; // 5 minutes\r\n  \r\n  private constructor() {}\r\n\r\n  public static getInstance(): ColivaraErrorHandler {\r\n    if (!ColivaraErrorHandler.instance) {\r\n      ColivaraErrorHandler.instance = new ColivaraErrorHandler();\r\n    }\r\n    return ColivaraErrorHandler.instance;\r\n  }\r\n\r\n  async handleColivaraOperation<T>(\r\n    operation: () => Promise<T>,\r\n    options: ErrorHandlingOptions = {}\r\n  ): Promise<{ result: T | null; error?: ColivaraError; fallbackUsed: boolean }> {\r\n    const { \r\n      maxRetries = 3, \r\n      retryDelay = 1000, \r\n      fallbackToTraditional = true,\r\n      timeout = 30000 \r\n    } = options;\r\n\r\n    // Check circuit breaker status\r\n    if (this.isCircuitBreakerOpen()) {\r\n      if (fallbackToTraditional) {\r\n        console.warn('Circuit breaker is open, using fallback to traditional processing');\r\n        return { result: null, error: new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'Service temporarily unavailable'), fallbackUsed: true };\r\n      } else {\r\n        throw new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'Service temporarily unavailable due to circuit breaker');\r\n      }\r\n    }\r\n\r\n    let lastError: ColivaraError | undefined;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Add timeout to the operation\r\n        const result = await this.withTimeout(operation(), timeout);\r\n        this.resetCircuitBreaker(); // Reset on success\r\n        return { result, error: undefined, fallbackUsed: false };\r\n      } catch (error) {\r\n        lastError = this.convertErrorToColivaraError(error);\r\n\r\n        // Log the error\r\n        console.error(`Colivara operation failed on attempt ${attempt + 1}:`, lastError);\r\n\r\n        // Check if this is a permanent error that shouldn't be retried\r\n        if (lastError && this.isPermanentError(lastError)) {\r\n          break;\r\n        }\r\n\r\n        // Update circuit breaker on failure\r\n        this.updateCircuitBreaker();\r\n\r\n        // If this isn't the last attempt, wait before retrying\r\n        if (attempt < maxRetries) {\r\n          await this.delay(retryDelay * Math.pow(2, attempt)); // Exponential backoff\r\n        }\r\n      }\r\n    }\r\n\r\n    // If we've exhausted retries and fallback is enabled\r\n    if (fallbackToTraditional) {\r\n      console.warn('Using fallback after Colivara operation failed:', lastError?.message);\r\n      return { result: null, error: lastError, fallbackUsed: true };\r\n    }\r\n\r\n    // If fallback is not enabled, throw the last error\r\n    throw lastError;\r\n  }\r\n\r\n  private async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<T>((_, reject) => {\r\n        setTimeout(() => {\r\n          reject(new ColivaraError(ColivaraErrorType.TIMEOUT, `Operation timed out after ${timeoutMs}ms`));\r\n        }, timeoutMs);\r\n      })\r\n    ]);\r\n  }\r\n\r\n  public convertErrorToColivaraError(error: any): ColivaraError {\r\n    if (error instanceof ColivaraError) {\r\n      return error;\r\n    }\r\n\r\n    // Check for specific error types\r\n    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\r\n      return new ColivaraError(ColivaraErrorType.NETWORK_ERROR, 'Network connection failed', error);\r\n    }\r\n\r\n    if (error.status === 429) {\r\n      return new ColivaraError(ColivaraErrorType.RATE_LIMIT_EXCEEDED, 'Rate limit exceeded', error, error.status);\r\n    }\r\n\r\n    if (error.status === 401 || error.status === 403) {\r\n      return new ColivaraError(ColivaraErrorType.AUTHENTICATION_FAILED, 'Authentication failed', error, error.status);\r\n    }\r\n\r\n    if (error.status === 404) {\r\n      return new ColivaraError(ColivaraErrorType.DOCUMENT_NOT_FOUND, 'Document not found in Colivara collections', error, error.status);\r\n    }\r\n\r\n    if (error.status >= 500) {\r\n      return new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'API temporarily unavailable', error, error.status);\r\n    }\r\n\r\n    if (error.name === 'TimeoutError') {\r\n      return new ColivaraError(ColivaraErrorType.TIMEOUT, error.message, error);\r\n    }\r\n\r\n    // Default to processing failed\r\n    return new ColivaraError(ColivaraErrorType.PROCESSING_FAILED, error.message || 'Processing failed', error);\r\n  }\r\n\r\n  private isPermanentError(error: ColivaraError): boolean {\r\n    // These errors should not be retried\r\n    return [\r\n      ColivaraErrorType.AUTHENTICATION_FAILED,\r\n      ColivaraErrorType.INVALID_RESPONSE,\r\n      ColivaraErrorType.DOCUMENT_NOT_FOUND\r\n    ].includes(error.type);\r\n  }\r\n\r\n  private isCircuitBreakerOpen(): boolean {\r\n    if (!this.circuitBreakerOpen) {\r\n      return false;\r\n    }\r\n\r\n    // Check if enough time has passed to close the circuit\r\n    if (this.lastFailureTime && \r\n        new Date().getTime() - this.lastFailureTime.getTime() > this.resetTimeout) {\r\n      this.circuitBreakerOpen = false;\r\n      this.failureCount = 0;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateCircuitBreaker(): void {\r\n    this.failureCount++;\r\n    this.lastFailureTime = new Date();\r\n    \r\n    if (this.failureCount >= this.maxFailures) {\r\n      this.circuitBreakerOpen = true;\r\n      console.warn('Circuit breaker opened due to too many failures');\r\n    }\r\n  }\r\n\r\n  private resetCircuitBreaker(): void {\r\n    this.circuitBreakerOpen = false;\r\n    this.failureCount = 0;\r\n    this.lastFailureTime = null;\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  // Method to check service health\r\n  async checkServiceHealth(service: ColivaraService): Promise<boolean> {\r\n    try {\r\n      return await service.validateApiKey();\r\n    } catch (error) {\r\n      console.error('Colivara service health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Method to handle graceful degradation\r\n  async handleGracefulDegradation<T>(\r\n    colivaraOperation: () => Promise<T>,\r\n    fallbackOperation: () => Promise<T>,\r\n    options: ErrorHandlingOptions = {}\r\n  ): Promise<{ result: T; degraded: boolean; error?: ColivaraError }> {\r\n    const { result, error, fallbackUsed } = await this.handleColivaraOperation(\r\n      colivaraOperation,\r\n      { ...options, fallbackToTraditional: true }\r\n    );\r\n\r\n    if (fallbackUsed && result === null) {\r\n      // Use fallback operation\r\n      try {\r\n        const fallbackResult = await fallbackOperation();\r\n        return { result: fallbackResult, degraded: true, error };\r\n      } catch (fallbackError) {\r\n        console.error('Fallback operation also failed:', fallbackError);\r\n        throw new ColivaraError(\r\n          ColivaraErrorType.PROCESSING_FAILED, \r\n          'Both primary and fallback operations failed',\r\n          fallbackError\r\n        );\r\n      }\r\n    }\r\n\r\n    if (result !== null) {\r\n      return { result, degraded: false };\r\n    }\r\n\r\n    throw new ColivaraError(ColivaraErrorType.PROCESSING_FAILED, 'Operation failed', error);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const colivaraErrorHandler = ColivaraErrorHandler.getInstance();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1130, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/colivara-service.ts"],"sourcesContent":["import { ColiVara } from 'colivara-ts';\r\nimport prisma from '@/lib/prisma';\r\nimport { Document } from '@/lib/api/types';\r\nimport { ColivaraDocument, ColivaraIndex } from '@/lib/types/colivara-types';\r\nimport { colivaraErrorHandler, ColivaraError as ColivaraServiceError, ColivaraErrorType } from './colivara-error-handler';\r\n\r\ninterface DocumentMetadata {\r\n  originalName: string;\r\n  size: number;\r\n  type: string;\r\n  extension: string;\r\n  uploadedAt: Date;\r\n lastModified: Date;\r\n  hash: string;\r\n}\r\n\r\ninterface ProcessingStatus {\r\n  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED';\r\n  progress?: number;\r\n  error?: string;\r\n  processedAt?: Date;\r\n  num_pages?: number;  // Add page count field\r\n}\r\n\r\ninterface SearchFilters {\r\n  unitId?: string;\r\n  category?: string;\r\n  dateRange?: { start: Date; end: Date };\r\n  fileType?: string[];\r\n}\r\n\r\ninterface SearchResults {\r\n  results: SearchResult[];\r\n  total: number;\r\n  query: string;\r\n processingTime: number;\r\n}\r\n\r\ninterface SearchResult {\r\n  documentId: string;\r\n  title: string;\r\n  content: string;\r\n  score: number;\r\n  pageNumbers: number[];\r\n  documentSection?: string;\r\n  confidenceScore?: number;\r\n  snippet: string;\r\n  document: Document;\r\n  visualContent?: string; // Base64 encoded visual content\r\n  extractedText?: string; // Extracted text content\r\n  screenshots?: string[]; // Array of screenshot base64 strings\r\n}\r\n\r\ninterface ColivaraConfig {\r\n  apiKey: string;\r\n  processingTimeout: number;\r\n  maxFileSize: number;\r\n  retryAttempts: number;\r\n  batchSize: number;\r\n  cacheEnabled: boolean;\r\n  cacheTtl: number;\r\n  defaultCollection: string;\r\n}\r\n\r\nclass ColivaraError extends Error {\r\n  constructor(message: string, public code?: string, public status?: number) {\r\n    super(message);\r\n    this.name = 'ColivaraError';\r\n }\r\n}\r\n\r\nclass ColivaraApiError extends ColivaraError {\r\n  constructor(message: string, public response?: any) {\r\n    super(message, 'API_ERROR', response?.status);\r\n    this.name = 'ColivaraApiError';\r\n  }\r\n}\r\n\r\nclass ColivaraProcessingError extends ColivaraError {\r\n  constructor(message: string, public documentId: string) {\r\n    super(message, 'PROCESSING_ERROR');\r\n    this.name = 'ColivaraProcessingError';\r\n  }\r\n}\r\n\r\nclass ColivaraService {\r\n  private client: ColiVara;\r\n  private config: ColivaraConfig;\r\n  private isInitialized: boolean;\r\n  private defaultCollection: string = 'lspu-kmis-documents';\r\n\r\n  constructor(config?: Partial<ColivaraConfig>) {\r\n    this.config = this.mergeConfig(config);\r\n    this.client = new ColiVara(this.config.apiKey);\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  private mergeConfig(userConfig?: Partial<ColivaraConfig>): ColivaraConfig {\r\n    return {\r\n      apiKey: process.env.COLIVARA_API_KEY || userConfig?.apiKey || '',\r\n      processingTimeout: userConfig?.processingTimeout || 300000, // 5 minutes default\r\n      maxFileSize: userConfig?.maxFileSize || 52428800, // 50MB default\r\n      retryAttempts: userConfig?.retryAttempts || 3,\r\n      batchSize: userConfig?.batchSize || 10,\r\n      cacheEnabled: userConfig?.cacheEnabled ?? true,\r\n      cacheTtl: userConfig?.cacheTtl || 3600000, // 1 hour default\r\n      defaultCollection: userConfig?.defaultCollection || 'lspu-kmis-documents',\r\n    };\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      // Validate API key by checking health\r\n      await this.validateApiKey();\r\n      \r\n      // Ensure the default collection exists\r\n      await this.ensureDefaultCollection();\r\n      \r\n      this.isInitialized = true;\r\n      console.log('Colivara service initialized successfully');\r\n    } catch (error) {\r\n      console.error('Failed to initialize Colivara service:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async validateApiKey(): Promise<boolean> {\r\n    try {\r\n      // Test connectivity to Colivara service using the health check\r\n      if (typeof this.client.checkHealth !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a checkHealth method');\r\n      }\r\n      await this.client.checkHealth();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('API key validation failed:', error);\r\n      throw colivaraErrorHandler.convertErrorToColivaraError(error);\r\n    }\r\n  }\r\n\r\n  private async ensureDefaultCollection(): Promise<void> {\r\n    try {\r\n      // Try to get the collection first\r\n      if (typeof this.client.getCollection !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getCollection method');\r\n      }\r\n      \r\n      try {\r\n        await this.client.getCollection({ collection_name: this.config.defaultCollection });\r\n        console.log(`Collection '${this.config.defaultCollection}' already exists`);\r\n      } catch (error) {\r\n        // Check if the error is because the method doesn't exist or collection doesn't exist\r\n        if (error instanceof TypeError || (error instanceof Error && error.message.includes('method'))) {\r\n          throw error; // Re-throw if it's a method not found error\r\n        }\r\n        \r\n        // If collection doesn't exist, create it\r\n        console.log(`Creating collection '${this.config.defaultCollection}'`);\r\n        \r\n        if (typeof this.client.createCollection !== 'function') {\r\n          throw new ColivaraApiError('Colivara client does not have a createCollection method');\r\n        }\r\n        \r\n        await this.client.createCollection({\r\n          name: this.config.defaultCollection,\r\n          metadata: {\r\n            description: 'Default collection for LSPU KMIS documents',\r\n            created_at: new Date().toISOString()\r\n          }\r\n        });\r\n        console.log(`Collection '${this.config.defaultCollection}' created successfully`);\r\n      }\r\n    } catch (error) {\r\n      console.error(`Failed to ensure default collection exists:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async uploadDocument(fileUrl: string, documentId: string, metadata: DocumentMetadata, base64Content?: string): Promise<string> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Update document status to PROCESSING using raw SQL since Prisma client hasn't been updated\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'PROCESSING', \"colivaraChecksum\" = ${metadata.hash}\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      // Check if the upsertDocument method exists\r\n      if (typeof this.client.upsertDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have an upsertDocument method');\r\n      }\r\n      \r\n      // Validate document metadata before upload\r\n      if (!documentId || typeof documentId !== 'string') {\r\n        throw new ColivaraApiError('Invalid document ID provided for upload');\r\n      }\r\n\r\n      // Validate document name\r\n      const documentName = `${documentId}_${metadata.originalName}`;\r\n      if (!documentName || documentName.length > 255) {\r\n        throw new ColivaraApiError('Document name is invalid or too long');\r\n      }\r\n\r\n      // Validate collection name\r\n      if (!this.config.defaultCollection || typeof this.config.defaultCollection !== 'string') {\r\n        throw new ColivaraApiError('Invalid collection name provided');\r\n      }\r\n\r\n      // Prepare upload parameters\r\n      const uploadParams: any = {\r\n        name: documentName,\r\n        collection_name: this.config.defaultCollection,\r\n        metadata: {\r\n          documentId,\r\n          title: metadata.originalName, // Ensure the title is stored in metadata for proper display\r\n          ...metadata\r\n        },\r\n        wait: false // Don't wait for processing to complete, we'll check status separately\r\n      };\r\n\r\n      // If base64 content is provided, use it instead of the URL\r\n      if (base64Content) {\r\n        console.log('Uploading document with base64 content:', {\r\n          name: documentName,\r\n          collection_name: this.config.defaultCollection,\r\n          metadata: {\r\n            documentId,\r\n            ...metadata\r\n          }\r\n        });\r\n        uploadParams.document_base64 = base64Content; // Use document_base64 instead of content for Colivara API\r\n      } else {\r\n        // If no base64 content provided, use the URL (fallback for backward compatibility)\r\n        if (!fileUrl || typeof fileUrl !== 'string') {\r\n          throw new ColivaraApiError('Invalid file URL provided for upload');\r\n        }\r\n        console.log('Uploading document with URL:', {\r\n          name: documentName,\r\n          collection_name: this.config.defaultCollection,\r\n          document_url: fileUrl,\r\n          metadata: {\r\n            documentId,\r\n            ...metadata\r\n          }\r\n        });\r\n        uploadParams.document_url = fileUrl;\r\n      }\r\n\r\n      const response = await this.client.upsertDocument(uploadParams);\r\n\r\n      console.log('Upload response received:', response);\r\n\r\n      // Extract document ID from response - adjust based on actual API response structure\r\n      // Ensure we return a string value, not the entire response object\r\n      const responseObj = response as any;\r\n      const documentIdFromResponse = responseObj.id || responseObj.documentId || responseObj.name ||\r\n                                    (typeof response === 'string' ? response : documentName);\r\n\r\n      if (!documentIdFromResponse) {\r\n        throw new ColivaraApiError('Invalid response from upsertDocument - no document ID returned');\r\n      }\r\n\r\n      // Validate that the document ID is a proper string\r\n      if (typeof documentIdFromResponse !== 'string' || documentIdFromResponse === '[object Object]') {\r\n        throw new ColivaraApiError(`Invalid document ID returned from API: ${typeof documentIdFromResponse}`);\r\n      }\r\n\r\n      // Store the Colivara document ID using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraDocumentId\" = ${documentIdFromResponse}\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      return documentIdFromResponse;\r\n    } catch (error) {\r\n      console.error(`Failed to upload document ${documentId} to Colivara:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED', \"colivaraMetadata\" = ${JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' })}::jsonb\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      if (error instanceof ColivaraError) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ColivaraProcessingError(\r\n        `Failed to upload document to Colivara: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        documentId\r\n      );\r\n    }\r\n  }\r\n\r\n  async checkProcessingStatus(colivaraDocumentId: string): Promise<ProcessingStatus> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]' || !colivaraDocumentId) {\r\n        throw new ColivaraApiError('Invalid document ID provided to checkProcessingStatus');\r\n      }\r\n\r\n      console.log(`Checking processing status for document ID: ${colivaraDocumentId}`);\r\n\r\n      if (typeof this.client.getDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getDocument method');\r\n      }\r\n      \r\n      const response = await this.client.getDocument({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection  // Include collection name in the request\r\n      });\r\n\r\n      console.log(`Processing status response for ${colivaraDocumentId}:`, response);\r\n\r\n      // Handle the response based on the actual ColiVara API response structure\r\n      // Since we don't have exact type information, we'll access fields safely\r\n      return {\r\n        status: (response as any).status as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' || 'PENDING',\r\n        progress: (response as any).progress || 0,\r\n        error: (response as any).error,\r\n        processedAt: (response as any).processedAt ? new Date((response as any).processedAt) : undefined,\r\n        num_pages: (response as any).num_pages || (response as any).pages || (response as any).page_count || 0,  // Add page count information\r\n      };\r\n    } catch (error) {\r\n      console.error(`Failed to check processing status for ${colivaraDocumentId}:`, error);\r\n      \r\n      // Convert error to ColivaraError to check if it's a 404\r\n      const colivaraError = colivaraErrorHandler.convertErrorToColivaraError(error);\r\n      \r\n      // If it's a document not found error, return appropriate status\r\n      if (colivaraError.type === ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n        console.warn(`Document ${colivaraDocumentId} not found in Colivara collections`);\r\n        return {\r\n          status: 'FAILED',\r\n          error: `Document not found in Colivara: ${colivaraError.message}`,\r\n          processedAt: new Date(),\r\n        };\r\n      }\r\n      \r\n      // For other errors, log them and re-throw\r\n      console.error(`Error checking processing status for ${colivaraDocumentId}:`, colivaraError);\r\n      throw colivaraError;\r\n    }\r\n  }\r\n\r\n  async waitForProcessing(colivaraDocumentId: string, maxWaitTime: number = 3000): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    const checkInterval = 5000; // Check every 5 seconds\r\n\r\n    // Add a 2-second delay before starting the status check loop\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n    console.log(`Waiting 2 seconds before starting status check for document: ${colivaraDocumentId}`);\r\n\r\n    while (Date.now() - startTime < maxWaitTime) {\r\n      try {\r\n        const status = await this.checkProcessingStatus(colivaraDocumentId);\r\n        \r\n        if (status.status === 'COMPLETED' || (status.num_pages !== undefined && status.num_pages > 0)) {\r\n          return true;\r\n        } else if (status.status === 'FAILED') {\r\n          console.error(`Document processing failed for ${colivaraDocumentId}: ${status.error}`);\r\n          return false;\r\n        }\r\n        \r\n        // Wait before next check\r\n        await new Promise(resolve => setTimeout(resolve, checkInterval));\r\n      } catch (error) {\r\n        console.error(`Error checking processing status for ${colivaraDocumentId}:`, error);\r\n        // If the error is due to document not being found, return false immediately\r\n        if (error instanceof ColivaraServiceError && (error as any).type === ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n          console.error(`Document ${colivaraDocumentId} not found in Colivara, failing immediately`);\r\n          return false;\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    console.warn(`Processing timeout for ${colivaraDocumentId} after ${maxWaitTime}ms`);\r\n    return false;\r\n  }\r\n\r\n  async performSemanticSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      const startTime = Date.now();\r\n      \r\n      let response;\r\n      \r\n      // Check if the search method exists on the client\r\n      if (typeof this.client.search !== 'function') {\r\n        console.warn('Colivara client does not have a search method, falling back to traditional search');\r\n        return {\r\n          results: [],\r\n          total: 0,\r\n          query,\r\n          processingTime: 0,\r\n        };\r\n      }\r\n      \r\n      try {\r\n        response = await this.client.search({\r\n          query,\r\n          collection_name: this.config.defaultCollection,\r\n          top_k: 10 // Return top 10 results\r\n          // Note: Filters are not directly supported in the search call,\r\n          // they would need to be implemented using metadata filtering if available in the actual API\r\n        });\r\n      } catch (error) {\r\n        console.error('Colivara search API call failed:', error);\r\n        // Return empty results but don't throw, let the fallback mechanism handle it\r\n        return {\r\n          results: [],\r\n          total: 0,\r\n          query,\r\n          processingTime: 0,\r\n        };\r\n      }\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      // Format results to match our expected structure\r\n      const results: SearchResult[] = response.results.map((item: any) => {\r\n        // Extract the original document ID from multiple possible locations\r\n        let originalDocumentId = item.metadata?.documentId ||\r\n                                (item.document && item.document.metadata?.documentId) ||\r\n                                item.metadata?.id ||\r\n                                item.id;\r\n                                \r\n        // If still not found, try to extract from document_metadata in the document object\r\n        if (!originalDocumentId && item.document && item.document_metadata) {\r\n          originalDocumentId = item.document.document_metadata.documentId;\r\n        }\r\n        \r\n        // If still not found, try to extract directly from document_metadata property\r\n        if (!originalDocumentId && item.document_metadata) {\r\n          originalDocumentId = item.document_metadata.documentId;\r\n        }\r\n        \r\n        // If still not found, try to extract from the document name (which contains the document ID)\r\n        if (!originalDocumentId && item.document?.document_name) {\r\n          // Extract document ID from document_name which is in format \"docId_originalName.ext\"\r\n          const nameParts = item.document.document_name.split('_');\r\n          if (nameParts.length >= 1) {\r\n            originalDocumentId = nameParts[0];\r\n          }\r\n        }\r\n                                  \r\n        // Extract score - prioritize similarity/prob over confidence since those are more likely to be the actual relevance scores\r\n        const score = item.score || item.similarity || item.prob || item.confidence || 0;\r\n                                  \r\n        return {\r\n          documentId: originalDocumentId,\r\n          title: item.metadata?.title || item.title || item.metadata?.originalName || item.name || 'Untitled Document',\r\n          content: item.content || item.text || item.metadata?.content || '',\r\n          score: score,\r\n          pageNumbers: item.page_numbers || item.pageNumbers || item.pages || [item.document?.page_number] || [],\r\n          documentSection: item.section || item.documentSection || item.metadata?.section || '',\r\n          confidenceScore: score, // Use the same score value for consistency\r\n          snippet: item.snippet || item.content?.substring(0, 200) + '...' || item.text?.substring(0, 200) + '...' || item.metadata?.content?.substring(0, 200) + '...' || '',\r\n          document: item.document || item.metadata?.document || item || {} as Document,\r\n          visualContent: item.visualContent || item.image || item.image_data || undefined,\r\n          extractedText: item.extractedText || item.text || item.content || undefined,\r\n        };\r\n      });\r\n\r\n      return {\r\n        results,\r\n        total: results.length,\r\n        query,\r\n        processingTime,\r\n      };\r\n    } catch (error) {\r\n      console.error('Semantic search failed:', error);\r\n      // Return an empty result set in case of error\r\n      return {\r\n        results: [],\r\n        total: 0,\r\n        query,\r\n        processingTime: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  async performHybridSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Perform semantic search with Colivara\r\n      const semanticResults = await this.performSemanticSearch(query, filters, userId);\r\n\r\n      // Perform traditional database search\r\n      const traditionalResults = await this.performTraditionalSearch(query, filters, userId);\r\n\r\n      // Combine and rank results\r\n      const combinedResults = this.combineSearchResults(semanticResults, traditionalResults);\r\n\r\n      return {\r\n        results: combinedResults,\r\n        total: combinedResults.length,\r\n        query,\r\n        processingTime: semanticResults.processingTime + (traditionalResults as any).processingTime || 0,\r\n      };\r\n    } catch (error) {\r\n      console.error('Hybrid search failed:', error);\r\n      // Fallback to traditional search only\r\n      return await this.performTraditionalSearch(query, filters, userId);\r\n    }\r\n  }\r\n\r\n  private async performTraditionalSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    // This would use the existing search functionality from enhanced-document-service\r\n    // For now, we'll implement a basic version\r\n    const documents = await prisma.document.findMany({\r\n      where: {\r\n        AND: [\r\n          {\r\n            OR: [\r\n              { title: { contains: query, mode: 'insensitive' } },\r\n              { description: { contains: query, mode: 'insensitive' } },\r\n              { tags: { path: ['$[*]'], string_contains: query } as any }, // Search for query string within the tags array using JSON path as array\r\n            ]\r\n          },\r\n          filters?.unitId ? { unitId: filters.unitId } : {},\r\n          filters?.category ? { category: filters.category } : {},\r\n        ],\r\n        status: 'ACTIVE',\r\n      },\r\n      include: {\r\n        uploadedByUser: true,\r\n        documentUnit: true,\r\n      },\r\n      take: 50, // Limit to 50 results\r\n    });\r\n\r\n    const results: SearchResult[] = documents.map((doc: any) => ({\r\n      documentId: doc.id,\r\n      title: doc.title,\r\n      content: doc.description,\r\n      score: 0.5, // Default score for traditional search\r\n      pageNumbers: [],\r\n      documentSection: 'description',\r\n      confidenceScore: 0.5,\r\n      snippet: doc.description.substring(0, 200) + '...',\r\n      document: {\r\n        ...doc,\r\n        tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n        uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n        unit: doc.documentUnit ? {\r\n          id: doc.documentUnit.id,\r\n          name: doc.documentUnit.name,\r\n          code: doc.documentUnit.code,\r\n          description: doc.documentUnit.description || undefined,\r\n          createdAt: doc.documentUnit.createdAt,\r\n          updatedAt: doc.documentUnit.updatedAt,\r\n        } : undefined,\r\n        uploadedAt: new Date(doc.uploadedAt),\r\n        createdAt: new Date(doc.createdAt),\r\n        updatedAt: new Date(doc.updatedAt),\r\n        // Colivara fields (for consistency)\r\n        colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n      } as Document,\r\n    }));\r\n\r\n    return {\r\n      results,\r\n      total: results.length,\r\n      query,\r\n      processingTime: 0, // We don't track this for traditional search here\r\n    };\r\n  }\r\n\r\n  private combineSearchResults(semanticResults: SearchResults, traditionalResults: SearchResults): SearchResult[] {\r\n   // This is a simplified combination - in a real implementation, we would have more sophisticated ranking\r\n   const combined = [...semanticResults.results];\r\n   \r\n   // Add traditional results that aren't already in semantic results\r\n   for (const tradResult of traditionalResults.results) {\r\n     // Check if document already exists in combined results using documentId field\r\n     const exists = combined.some(semResult => {\r\n       const semDocId = semResult.documentId;\r\n       const tradDocId = tradResult.documentId;\r\n       return semDocId && tradDocId && semDocId === tradDocId;\r\n     });\r\n     if (!exists) {\r\n       combined.push(tradResult);\r\n     }\r\n   }\r\n   \r\n   // Sort by score (or some combination of scores)\r\n   return combined.sort((a, b) => (b.score || 0) - (a.score || 0));\r\n }\r\n\r\n  async indexDocument(documentId: string, base64Content?: string): Promise<boolean> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Get document from database\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!document) {\r\n        throw new ColivaraProcessingError(`Document not found: ${documentId}`, documentId);\r\n      }\r\n\r\n      // Update document status to PROCESSING using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'PROCESSING'\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      // Upload document to Colivara for processing\r\n      const colivaraDocId = await this.uploadDocument(\r\n        document.fileUrl,\r\n        documentId,\r\n        {\r\n          originalName: document.fileName,\r\n          size: document.fileSize,\r\n          type: document.fileType,\r\n          extension: document.fileName.split('.').pop() || '',\r\n          uploadedAt: document.uploadedAt,\r\n          lastModified: document.updatedAt,\r\n          hash: (document as any).colivaraChecksum || ''\r\n        },\r\n        base64Content // Pass the base64 content if provided\r\n      );\r\n\r\n      console.log('Upload result from upsertDocument:', { colivaraDocId, documentId });\r\n\r\n      // Start background processing without blocking\r\n      this.waitForProcessingAndComplete(documentId, colivaraDocId);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Failed to index document ${documentId}:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED'\r\n        WHERE id = ${documentId}\r\n      `;\r\n      \r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async waitForProcessingAndComplete(documentId: string, colivaraDocId: string): Promise<void> {\r\n    try {\r\n      // Wait for processing to complete\r\n      const completed = await this.waitForProcessing(colivaraDocId, this.config.processingTimeout);\r\n\r\n      if (completed) {\r\n        // Update document with Colivara results using raw SQL\r\n        await prisma.$executeRaw`\r\n          UPDATE documents\r\n          SET \"colivaraDocumentId\" = ${colivaraDocId},\r\n              \"colivaraProcessingStatus\" = 'COMPLETED',\r\n              \"colivaraProcessedAt\" = ${new Date()}::timestamp\r\n          WHERE id = ${documentId}\r\n        `;\r\n\r\n        // Extract and store the processed content in ColivaraIndex\r\n        await this.storeProcessedContent(documentId, colivaraDocId);\r\n      } else {\r\n        // Handle timeout or failure\r\n        await prisma.$executeRaw`\r\n          UPDATE documents\r\n          SET \"colivaraProcessingStatus\" = 'FAILED'\r\n          WHERE id = ${documentId}\r\n        `;\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error completing processing for document ${documentId}:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED'\r\n        WHERE id = ${documentId}\r\n      `;\r\n    }\r\n  }\r\n\r\n  private async storeProcessedContent(documentId: string, colivaraDocId: string): Promise<void> {\r\n    try {\r\n      // Get the processed content from Colivara\r\n      // Note: The official API might not have a direct content endpoint\r\n      // We'll need to implement this based on what the actual API provides\r\n      console.log(`Storing processed content for document ${documentId} with Colivara ID ${colivaraDocId}`);\r\n      \r\n      // For now, we'll just log this operation\r\n      // The actual implementation would depend on what data the Colivara API returns\r\n      // after document processing is complete\r\n    } catch (error) {\r\n      console.error(`Failed to store processed content for document ${documentId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n   async updateIndex(documentId: string, base64Content?: string): Promise<boolean> {\r\n     try {\r\n       // Get the current document to check if it has changed\r\n       const document = await prisma.document.findUnique({\r\n         where: { id: documentId }\r\n       });\r\n \r\n       if (!document) {\r\n         return false;\r\n       }\r\n \r\n       // Check if we need to reprocess (e.g., if file has changed)\r\n       // For now, we'll just reprocess - we'll need to implement proper change detection\r\n       // once the Prisma client is updated with new fields\r\n       if ((document as any).colivaraProcessingStatus === 'COMPLETED' && (document as any).colivaraChecksum) {\r\n         // In a real implementation, we would check if the file has changed\r\n         // For now, we'll just reprocess\r\n       }\r\n \r\n       return await this.indexDocument(documentId, base64Content);\r\n     } catch (error) {\r\n       console.error(`Failed to update index for document ${documentId}:`, error);\r\n       return false;\r\n     }\r\n   }\r\n\r\n  async deleteFromIndex(documentId: string): Promise<boolean> {\r\n    try {\r\n      // Get the document first to check if it has a Colivara document ID\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId }\r\n      });\r\n\r\n      // If document exists and has a Colivara document ID, delete from Colivara collection\r\n      if (document && (document as any).colivaraDocumentId) {\r\n        try {\r\n          // Delete from Colivara collection using the official API\r\n          await this.client.deleteDocument({\r\n            document_name: (document as any).colivaraDocumentId,\r\n            collection_name: this.config.defaultCollection\r\n          });\r\n          console.log(`Successfully deleted document ${documentId} (${(document as any).colivaraDocumentId}) from Colivara collection`);\r\n        } catch (colivaraError) {\r\n          // Log the error but continue with database cleanup\r\n          console.error(`Failed to delete document ${documentId} from Colivara collection:`, colivaraError);\r\n          \r\n          // Check if it's a \"document not found\" error, which is acceptable\r\n          const colivaraServiceError = colivaraErrorHandler.convertErrorToColivaraError(colivaraError);\r\n          if (colivaraServiceError.type !== ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n            // For other errors, log but continue with database cleanup\r\n            console.warn(`Non-critical error deleting document from Colivara collection, proceeding with database cleanup:`, colivaraError);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Delete all index entries for this document using raw SQL\r\n      await prisma.$executeRaw`\r\n        DELETE FROM colivara_indexes WHERE \"documentId\" = ${documentId}\r\n      `;\r\n\r\n      // Update document to reset Colivara fields using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraDocumentId\" = NULL,\r\n            \"colivaraEmbeddings\" = NULL,\r\n            \"colivaraMetadata\" = NULL,\r\n            \"colivaraProcessingStatus\" = NULL,\r\n            \"colivaraProcessedAt\" = NULL,\r\n            \"colivaraChecksum\" = NULL\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Failed to delete document ${documentId} from index:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async extractDocumentMetadata(colivaraDocumentId: string): Promise<any> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to extractDocumentMetadata');\r\n      }\r\n\r\n      if (typeof this.client.getDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getDocument method');\r\n      }\r\n      \r\n      const response = await this.client.getDocument({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection  // Include collection name in the request\r\n      });\r\n      return response.metadata || response;\r\n    } catch (error) {\r\n      console.error(`Failed to extract metadata for ${colivaraDocumentId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async processNewDocument(document: Document, fileUrl: string, base64Content?: string): Promise<void> {\r\n    // This method processes a newly uploaded document\r\n    // It will be called after a document is successfully uploaded to the system\r\n    // Processing happens in the background without blocking the upload response\r\n    this.processNewDocumentAsync(document, fileUrl, base64Content);\r\n  }\r\n\r\n  private async processNewDocumentAsync(document: Document, fileUrl: string, base64Content?: string): Promise<void> {\r\n    try {\r\n      // The document should already be in the database with PENDING status\r\n      // We just need to trigger the Colivara processing\r\n      // Processing happens in the background without waiting for completion\r\n      this.indexDocument(document.id, base64Content);\r\n    } catch (error) {\r\n      console.error(`Error starting processing for new document ${document.id}:`, error);\r\n    }\r\n }\r\n\r\n  async handleDocumentUpdate(documentId: string, updatedDocument: Document, fileUrl?: string, base64Content?: string): Promise<void> {\r\n    try {\r\n      // Handle document updates\r\n      // If the file has changed (fileUrl is provided), reprocess the document\r\n      if (fileUrl) {\r\n        // Use updateIndex which will call indexDocument with the base64 content if provided\r\n        const success = await this.updateIndex(documentId, base64Content);\r\n        if (!success) {\r\n          console.error(`Failed to reprocess updated document ${documentId} with Colivara`);\r\n        }\r\n      } else {\r\n        // If only metadata changed, we might need to update the index differently\r\n        // For now, just return\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error handling document update for ${documentId}:`, error);\r\n    }\r\n  }\r\n\r\n /**\r\n   * Get visual content (screenshots/pages) from processed documents\r\n   * @param colivaraDocumentId The document ID in Colivara\r\n   * @param pageNumbers Specific pages to retrieve (optional, if not provided, returns all available)\r\n   */\r\n  async getVisualContent(colivaraDocumentId: string, pageNumbers?: number[]): Promise<string[]> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to getVisualContent');\r\n      }\r\n\r\n      console.log(`Getting visual content for document: ${colivaraDocumentId}, pages: ${pageNumbers || 'all'}`);\r\n\r\n      // Check if the getDocumentPages method exists on the client\r\n      if (typeof (this.client as any).getDocumentPages !== 'function') {\r\n        console.warn('Colivara client does not have a getDocumentPages method, returning empty array');\r\n        return [];\r\n      }\r\n\r\n      const response = await (this.client as any).getDocumentPages({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection,\r\n        page_numbers: pageNumbers\r\n      });\r\n\r\n      // Process the response to extract base64 images\r\n      if (response && response.pages) {\r\n        // If pages is an array of objects with image data\r\n        if (Array.isArray(response.pages)) {\r\n          return response.pages.map((page: any) => {\r\n            // Return base64 image data if available, otherwise return empty string\r\n            return page.image_data || page.image || page.base64 || '';\r\n          }).filter((img: string) => img !== ''); // Filter out empty strings\r\n        }\r\n        // If response has a different structure, try to extract images\r\n        else if (response.images && Array.isArray(response.images)) {\r\n          return response.images;\r\n        }\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error(`Failed to get visual content for ${colivaraDocumentId}:`, error);\r\n      return [];\r\n    }\r\n }\r\n\r\n  /**\r\n   * Get extracted text content from processed documents\r\n   * @param colivaraDocumentId The document ID in Colivara\r\n   * @param pageNumbers Specific pages to retrieve text from (optional, if not provided, returns all available)\r\n   */\r\n  async getExtractedText(colivaraDocumentId: string, pageNumbers?: number[]): Promise<string> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to getExtractedText');\r\n      }\r\n\r\n      console.log(`Getting extracted text for document: ${colivaraDocumentId}, pages: ${pageNumbers || 'all'}`);\r\n\r\n      // Check if the getDocumentText method exists on the client\r\n      if (typeof (this.client as any).getDocumentText !== 'function') {\r\n        console.warn('Colivara client does not have a getDocumentText method, returning empty string');\r\n        return '';\r\n      }\r\n\r\n      const response = await (this.client as any).getDocumentText({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection,\r\n        page_numbers: pageNumbers\r\n      });\r\n\r\n      // Return the extracted text content\r\n      return response.text || response.content || response.extracted_text || '';\r\n    } catch (error) {\r\n      console.error(`Failed to get extracted text for ${colivaraDocumentId}:`, error);\r\n      return '';\r\n    }\r\n }\r\n\r\n  /**\r\n   * Enhanced search method that includes visual content and extracted text for multimodal processing\r\n   */\r\n  async performEnhancedSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      // First, perform the standard semantic search\r\n      const standardResults = await this.performSemanticSearch(query, filters, userId);\r\n\r\n      // Instead of calling getVisualContent and getExtractedText which may trigger getDocumentPages errors,\r\n      // we'll return the standard results which should already contain the content from the search response\r\n      // This avoids the problematic API calls while still providing data for Gemini\r\n      return standardResults;\r\n    } catch (error) {\r\n      console.error('Enhanced search failed:', error);\r\n      // Fallback to standard search\r\n      return await this.performSemanticSearch(query, filters, userId);\r\n    }\r\n  }\r\n}\r\n\r\nexport default ColivaraService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1962, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/document-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma';\r\nimport { Document, DocumentPermission, DocumentComment, User } from '@/lib/api/types';\r\nimport fileStorageService from './file-storage-service';\r\nimport ColivaraService from './colivara-service';\r\n\r\n// Create a singleton instance of the Colivara service\r\nconst colivaraService = new ColivaraService();\r\n\r\nclass DocumentService {\r\n  /**\r\n   * Helper method to find a user by database ID only\r\n   */\r\n  private async findUserById(userId: string): Promise<User | null> {\r\n    // Find user by the provided userId (database ID)\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId },\r\n    });\r\n\r\n    if (!user) {\r\n      return null;\r\n    }\r\n\r\n    // Transform the Prisma user to match the API type\r\n    return {\r\n      id: user.id,\r\n      email: user.email,\r\n      name: user.name,\r\n      role: user.role as 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL',\r\n      unitId: user.unitId || undefined, // Convert null to undefined\r\n      avatar: user.avatar || undefined, // Convert null to undefined\r\n      createdAt: user.createdAt,\r\n      updatedAt: user.updatedAt,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all documents with optional filtering and pagination\r\n   */\r\n  async getDocuments(\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    category?: string,\r\n    search?: string,\r\n    userId?: string,\r\n    sort?: string,\r\n    order: 'asc' | 'desc' = 'desc',\r\n    unitId?: string  // NEW: Unit filter\r\n ): Promise<{ documents: Document[]; total: number }> {\r\n    const skip = (page - 1) * limit;\r\n    \r\n    // Build where clause based on permissions and filters\r\n    const whereClause: any = {\r\n      status: 'ACTIVE', // Only show active documents\r\n    };\r\n\r\n    // Add category filter if provided\r\n    if (category && category !== 'all') {\r\n      whereClause.category = category;\r\n    }\r\n\r\n    // Add unit filter if provided\r\n    if (unitId) {\r\n      whereClause.unitId = unitId;\r\n    }\r\n\r\n    // Add search filter if provided\r\n    if (search) {\r\n      const searchCondition = {\r\n        OR: [\r\n          { title: { contains: search, mode: 'insensitive' } },\r\n          { description: { contains: search, mode: 'insensitive' } },\r\n          { tags: { array_contains: [search] } }, // Updated for JSON field\r\n        ]\r\n      };\r\n      \r\n      // If we already have conditions (like category or unit), wrap everything in AND\r\n      if (Object.keys(whereClause).length > 1) { // More than just status\r\n        whereClause.AND = whereClause.AND || [];\r\n        whereClause.AND.push(searchCondition);\r\n      } else {\r\n        // If no other conditions exist, just add the search condition\r\n        Object.assign(whereClause, searchCondition);\r\n      }\r\n    }\r\n\r\n    // If user is not admin, only show documents they have access to\r\n    if (userId) {\r\n      const user = await this.findUserById(userId);\r\n\r\n      if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n        // For non-admin and non-faculty users, we need to check document permissions\r\n        const permissionCondition = {\r\n          OR: [\r\n            { uploadedById: user.id }, // Allow access to user's own documents (using db ID)\r\n            { permissions: { some: { userId: user.id, permission: { in: ['READ', 'WRITE', 'ADMIN'] } } } } // Documents with explicit permissions\r\n          ]\r\n        };\r\n\r\n        // If we already have conditions in whereClause, wrap everything in AND\r\n        if (Object.keys(whereClause).length > 1) { // More than just status\r\n          whereClause.AND = whereClause.AND || [];\r\n          whereClause.AND.push(permissionCondition);\r\n        } else {\r\n          // If no other conditions exist, just add the permission condition\r\n          Object.assign(whereClause, permissionCondition);\r\n        }\r\n      }\r\n    }\r\n\r\n    try {\r\n      const [documents, total] = await Promise.all([\r\n        prisma.document.findMany({\r\n          where: whereClause,\r\n          skip,\r\n          take: limit,\r\n          orderBy: sort ? { [sort]: order } : { uploadedAt: 'desc' },\r\n          include: {\r\n            uploadedByUser: true,\r\n            documentUnit: true,\r\n          }\r\n        }),\r\n        prisma.document.count({ where: whereClause }),\r\n      ]);\r\n\r\n      return {\r\n        documents: documents.map((doc: any) => ({\r\n          ...doc,\r\n          tags: Array.isArray(doc.tags) ? doc.tags as string[] : (typeof doc.tags === 'object' && doc.tags !== null ? Object.values(doc.tags) : []),\r\n          unitId: doc.unitId ?? undefined,\r\n          versionNotes: doc.versionNotes ?? undefined,\r\n          downloadsCount: doc.downloadsCount ?? 0,\r\n          viewsCount: doc.viewsCount ?? 0,\r\n          uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n          unit: doc.documentUnit || undefined,\r\n          uploadedAt: new Date(doc.uploadedAt),\r\n          createdAt: new Date(doc.createdAt),\r\n          updatedAt: new Date(doc.updatedAt),\r\n        })),\r\n        total,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocuments:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific document by ID\r\n   */\r\n  async getDocumentById(id: string, userId?: string): Promise<Document | null> {\r\n    try {\r\n      // Validate the document ID format before querying the database\r\n      if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('undefined') || id.includes('.pdf') || id.includes('.')) {\r\n        console.warn('Invalid document ID format received in getDocumentById:', id);\r\n        return null;\r\n      }\r\n\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!document) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has access to the document\r\n      if (userId) {\r\n        const user = await this.findUserById(userId);\r\n\r\n        if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n          // Check if user has explicit permission for this document\r\n          const permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: id,\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['READ', 'WRITE', 'ADMIN'] }, // User needs at least READ permission\r\n            },\r\n          });\r\n\r\n          // Allow access if user has explicit READ/WRITE/ADMIN permission OR if user uploaded the document\r\n          if (!permission && document.uploadedById !== user.id) {\r\n            return null; // User doesn't have access\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...document,\r\n        tags: Array.isArray(document.tags) ?\r\n          (document.tags as any[]).map(tag => String(tag)) :\r\n          (typeof document.tags === 'object' && document.tags !== null ?\r\n            Object.values(document.tags).map(tag => String(tag)) : []),\r\n        year: document.year ?? undefined,\r\n        quarter: document.quarter ?? undefined,\r\n        unitId: document.unitId || undefined, // Convert null to undefined\r\n        versionNotes: document.versionNotes || undefined, // Convert null to undefined\r\n        downloadsCount: document.downloadsCount || 0, // Convert null to 0\r\n        viewsCount: document.viewsCount || 0, // Convert null to 0\r\n        uploadedBy: document.uploadedByUser?.name || document.uploadedBy,\r\n        status: document.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW',\r\n        unit: document.documentUnit && document.documentUnit.code ? {\r\n          id: document.documentUnit.id,\r\n          name: document.documentUnit.name,\r\n          code: document.documentUnit.code,\r\n          description: document.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: document.documentUnit.createdAt,\r\n          updatedAt: document.documentUnit.updatedAt,\r\n        } : undefined,\r\n        uploadedAt: new Date(document.uploadedAt),\r\n        createdAt: new Date(document.createdAt),\r\n        updatedAt: new Date(document.updatedAt),\r\n        colivaraDocumentId: document.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: document.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: document.colivaraProcessedAt ? new Date(document.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: document.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocumentById:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new document\r\n   */\r\n  async createDocument(\r\n    title: string,\r\n    description: string,\r\n    category: string,\r\n    tags: string[],\r\n    uploadedBy: string,\r\n    fileUrl: string,\r\n    fileName: string,\r\n    fileType: string,\r\n    fileSize: number,\r\n    userId: string,\r\n    unitId?: string  // NEW: Unit assignment\r\n  ): Promise<Document> {\r\n    try {\r\n      console.log('Creating document in database...', {\r\n        title,\r\n        description,\r\n        category,\r\n        tags,\r\n        uploadedBy,\r\n        fileUrl,\r\n        fileName,\r\n        fileType,\r\n        fileSize,\r\n        userId\r\n      });\r\n      \r\n      const user = await this.findUserById(userId);\r\n      \r\n      console.log('User lookup result:', { user: !!user, role: user?.role });\r\n\r\n      if (!user || !['ADMIN', 'FACULTY'].includes(user.role)) {\r\n        throw new Error('Only admins and faculty can upload documents');\r\n      }\r\n\r\n      const document = await prisma.document.create({\r\n        data: {\r\n          title,\r\n          description,\r\n          category,\r\n          tags: tags || [], // Ensure tags is always an array, even if undefined\r\n          uploadedBy: user.name,\r\n          uploadedById: user.id, // Use the database user ID, not the Supabase auth ID\r\n          fileUrl,\r\n          fileName,\r\n          fileType,\r\n          fileSize,\r\n          unitId: unitId || undefined, // Use provided unitId or undefined\r\n          status: 'ACTIVE',\r\n        },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n      \r\n      console.log('Document created:', document.id);\r\n\r\n      // Grant the uploader full permissions\r\n      await prisma.documentPermission.create({\r\n        data: {\r\n          documentId: document.id,\r\n          userId: user.id, // Use the database user ID for permissions\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n      \r\n      console.log('Document permissions granted');\r\n      \r\n      return {\r\n        id: document.id,\r\n        title: document.title,\r\n        description: document.description,\r\n        category: document.category,\r\n        tags: Array.isArray(document.tags) ?\r\n          (document.tags as any[]).map(tag => String(tag)) :\r\n          (typeof document.tags === 'object' && document.tags !== null ?\r\n            Object.values(document.tags).map(tag => String(tag)) : []),\r\n        uploadedBy: document.uploadedByUser?.name || document.uploadedBy,\r\n        uploadedById: document.uploadedById,\r\n        uploadedAt: new Date(document.uploadedAt),\r\n        fileUrl: document.fileUrl,\r\n        fileName: document.fileName,\r\n        fileType: document.fileType,\r\n        fileSize: document.fileSize,\r\n        downloadsCount: document.downloadsCount || 0, // Convert null to 0\r\n        viewsCount: document.viewsCount || 0, // Convert null to 0\r\n        version: document.version || 1,\r\n        versionNotes: document.versionNotes || undefined, // Convert null to undefined\r\n        status: document.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW',\r\n        createdAt: new Date(document.createdAt),\r\n        updatedAt: new Date(document.updatedAt),\r\n        unitId: document.unitId || undefined, // Convert null to undefined\r\n        unit: document.documentUnit && document.documentUnit.code ? {\r\n          id: document.documentUnit.id,\r\n          name: document.documentUnit.name,\r\n          code: document.documentUnit.code,\r\n          description: document.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: document.documentUnit.createdAt,\r\n          updatedAt: document.documentUnit.updatedAt,\r\n        } : undefined,\r\n        colivaraDocumentId: document.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: document.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: document.colivaraProcessedAt ? new Date(document.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: document.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in createDocument:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a document\r\n   */\r\n  async updateDocument(\r\n    id: string,\r\n    title?: string,\r\n    description?: string,\r\n    category?: string,\r\n    tags?: string[],\r\n    unitId?: string, // NEW: Unit assignment\r\n    userId?: string,\r\n    fileUrl?: string // NEW: File URL for Colivara reprocessing\r\n  ): Promise<Document | null> {\r\n    try {\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!document) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has permission to update the document\r\n      let permission = null;\r\n      let user = null;\r\n\r\n      if (userId) {\r\n        user = await this.findUserById(userId);\r\n\r\n        if (user) {\r\n          permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: id,\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['WRITE', 'ADMIN'] },\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      if (userId && !permission && user?.role !== 'ADMIN' && document.uploadedById !== user?.id) {\r\n        throw new Error('User does not have permission to update this document');\r\n      }\r\n\r\n      // Update document fields that Prisma client recognizes\r\n      const updatedDocument = await prisma.document.update({\r\n        where: { id },\r\n        data: {\r\n          ...(title && { title }),\r\n          ...(description && { description }),\r\n          ...(category && { category }),\r\n          ...(tags !== undefined && { tags: tags || [] }),\r\n          ...(unitId !== undefined && { unitId }),\r\n          updatedAt: new Date(),\r\n        },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      return {\r\n        id: updatedDocument.id,\r\n        title: updatedDocument.title,\r\n        description: updatedDocument.description,\r\n        category: updatedDocument.category,\r\n        tags: Array.isArray(updatedDocument.tags) ?\r\n          (updatedDocument.tags as any[]).map(tag => String(tag)) :\r\n          (typeof updatedDocument.tags === 'object' && updatedDocument.tags !== null ?\r\n            Object.values(updatedDocument.tags).map(tag => String(tag)) : []),\r\n        uploadedBy: updatedDocument.uploadedByUser?.name || updatedDocument.uploadedBy,\r\n        uploadedById: updatedDocument.uploadedById,\r\n        uploadedAt: new Date(updatedDocument.uploadedAt),\r\n        fileUrl: updatedDocument.fileUrl,\r\n        fileName: updatedDocument.fileName,\r\n        fileType: updatedDocument.fileType,\r\n        fileSize: updatedDocument.fileSize,\r\n        downloadsCount: updatedDocument.downloadsCount || 0, // Convert null to 0\r\n        viewsCount: updatedDocument.viewsCount || 0, // Convert null to 0\r\n        version: updatedDocument.version || 1,\r\n        versionNotes: updatedDocument.versionNotes || undefined, // Convert null to undefined\r\n        status: updatedDocument.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW',\r\n        createdAt: new Date(updatedDocument.createdAt),\r\n        updatedAt: new Date(updatedDocument.updatedAt),\r\n        unitId: updatedDocument.unitId || undefined, // Convert null to undefined\r\n        unit: updatedDocument.documentUnit && updatedDocument.documentUnit.code ? {\r\n          id: updatedDocument.documentUnit.id,\r\n          name: updatedDocument.documentUnit.name,\r\n          code: updatedDocument.documentUnit.code,\r\n          description: updatedDocument.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: updatedDocument.documentUnit.createdAt,\r\n          updatedAt: updatedDocument.documentUnit.updatedAt,\r\n        } : undefined,\r\n        colivaraDocumentId: updatedDocument.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: updatedDocument.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: updatedDocument.colivaraProcessedAt ? new Date(updatedDocument.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: updatedDocument.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in updateDocument:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a document\r\n   */\r\n  async deleteDocument(id: string, userId: string): Promise<boolean> {\r\n    try {\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n        include: {\r\n          permissions: true, // Include related permissions\r\n          comments: true,    // Include related comments\r\n          downloads: true,   // Include related downloads\r\n          views: true,       // Include related views\r\n        }\r\n      });\r\n  \r\n      if (!document) {\r\n        return false;\r\n      }\r\n  \r\n      const user = await this.findUserById(userId);\r\n  \r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n  \r\n      // Check if user has permission to delete the document\r\n      const permission = await prisma.documentPermission.findFirst({\r\n        where: {\r\n          documentId: id,\r\n          userId: user.id, // Use the database user ID\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n  \r\n      if (!permission && user.role !== 'ADMIN' && document.uploadedById !== user.id) {\r\n        throw new Error('User does not have permission to delete this document');\r\n      }\r\n  \r\n      // QPRO CLEANUP: Before deleting, capture KPIContribution records for accurate deduction\r\n      // This solves the \"memory loss\" problem - we know exactly what this document contributed\r\n      const kpiContributions = await prisma.kPIContribution.findMany({\r\n        where: { document_id: id },\r\n        select: {\r\n          id: true,\r\n          kra_id: true,\r\n          initiative_id: true,\r\n          value: true,\r\n          year: true,\r\n          quarter: true,\r\n          target_type: true,\r\n        }\r\n      });\r\n\r\n      // Also get aggregation activities for legacy cleanup (in case contributions don't exist)\r\n      const qproAnalysis = await prisma.qPROAnalysis.findFirst({\r\n        where: { documentId: id },\r\n        select: {\r\n          id: true,\r\n          year: true,\r\n          quarter: true,\r\n          unitId: true,\r\n          aggregationActivities: {\r\n            where: { isApproved: true },\r\n            select: {\r\n              initiative_id: true,\r\n              reported: true,\r\n              aggregation_id: true,\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      // Track which KRAggregations need recalculation (from KPIContributions - preferred)\r\n      const contributionsByKpi = new Map<string, { kraId: string; initiativeId: string; value: number; year: number; quarter: number }>();\r\n      for (const contrib of kpiContributions) {\r\n        const key = `${contrib.kra_id}|${contrib.initiative_id}|${contrib.year}|${contrib.quarter}`;\r\n        contributionsByKpi.set(key, {\r\n          kraId: contrib.kra_id,\r\n          initiativeId: contrib.initiative_id,\r\n          value: contrib.value,\r\n          year: contrib.year,\r\n          quarter: contrib.quarter,\r\n        });\r\n      }\r\n\r\n      // Fallback: Track from aggregation activities if no contributions exist\r\n      const affectedAggregations: { aggregationId: string; initiativeId: string; reportedValue: number }[] = [];\r\n      if (kpiContributions.length === 0 && qproAnalysis?.aggregationActivities) {\r\n        for (const activity of qproAnalysis.aggregationActivities) {\r\n          if (activity.aggregation_id && activity.reported !== null) {\r\n            affectedAggregations.push({\r\n              aggregationId: activity.aggregation_id,\r\n              initiativeId: activity.initiative_id,\r\n              reportedValue: activity.reported,\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      console.log(`[Document Delete] Found ${kpiContributions.length} KPIContributions to deduct, ${affectedAggregations.length} legacy aggregation activities`);\r\n\r\n      // Delete related records first (due to foreign key constraints)\r\n      await prisma.documentComment.deleteMany({\r\n        where: { documentId: id },\r\n      });\r\n      \r\n      await prisma.documentDownload.deleteMany({\r\n        where: { documentId: id },\r\n      });\r\n      \r\n      await prisma.documentView.deleteMany({\r\n        where: { documentId: id },\r\n      });\r\n      \r\n      await prisma.documentPermission.deleteMany({\r\n        where: { documentId: id },\r\n      });\r\n      \r\n      // Delete Colivara indexes if they exist\r\n      await prisma.colivaraIndex.deleteMany({\r\n        where: { documentId: id },\r\n      });\r\n\r\n      // Delete the file from storage before removing the database record\r\n      try {\r\n        const fileName = document.fileUrl.split('/').pop(); // Extract filename from URL\r\n        if (fileName) {\r\n          const fileDeleted = await fileStorageService.deleteFile(fileName);\r\n          if (!fileDeleted) {\r\n            console.warn(`Failed to delete file ${fileName} from storage, but continuing with database deletion`);\r\n          }\r\n        } else {\r\n          console.warn(`Could not extract filename from URL: ${document.fileUrl}`);\r\n        }\r\n      } catch (fileError) {\r\n        console.error('Error deleting file from storage:', fileError);\r\n        // Continue with database deletion even if file deletion fails to avoid orphaned records\r\n      }\r\n  \r\n      // Delete from Colivara index if it exists\r\n      try {\r\n        // Initialize the service if needed (in case it hasn't been initialized)\r\n        if (!colivaraService['isInitialized']) {\r\n          await colivaraService.initialize();\r\n        }\r\n        await colivaraService.deleteFromIndex(id);\r\n      } catch (colivaraError) {\r\n        console.error(`Failed to delete document ${id} from Colivara index:`, colivaraError);\r\n        // Continue with deletion even if Colivara deletion fails\r\n      }\r\n      \r\n      // Delete the document from the database (cascades to QPROAnalysis, AggregationActivity, and KPIContribution)\r\n      await prisma.document.delete({\r\n        where: { id },\r\n      });\r\n\r\n      // QPRO CLEANUP: Deduct contributions from KRAggregation records after deletion\r\n      // Use KPIContributions (preferred - accurate per-document stamped values)\r\n      if (contributionsByKpi.size > 0) {\r\n        console.log(`[Document Delete] Deducting ${contributionsByKpi.size} KPI contributions from aggregations`);\r\n        \r\n        for (const [, contrib] of contributionsByKpi) {\r\n          try {\r\n            // Find the KRAggregation for this KPI\r\n            const aggregation = await prisma.kRAggregation.findFirst({\r\n              where: {\r\n                year: contrib.year,\r\n                quarter: contrib.quarter,\r\n                kra_id: contrib.kraId,\r\n                initiative_id: contrib.initiativeId,\r\n              },\r\n            });\r\n\r\n            if (!aggregation) {\r\n              console.log(`[Document Delete] No KRAggregation found for ${contrib.kraId}/${contrib.initiativeId}`);\r\n              continue;\r\n            }\r\n\r\n            // Deduct the exact contribution value\r\n            const newTotal = Math.max(0, (aggregation.total_reported ?? 0) - contrib.value);\r\n            const newCount = Math.max(0, aggregation.submission_count - 1);\r\n            \r\n            if (newCount === 0) {\r\n              // No more contributions - delete the KRAggregation record\r\n              await prisma.kRAggregation.delete({\r\n                where: { id: aggregation.id },\r\n              });\r\n              console.log(`[Document Delete] Deleted empty KRAggregation: ${aggregation.id}`);\r\n            } else {\r\n              // Recalculate achievement with the deducted total\r\n              const targetValue = aggregation.target_value?.toNumber() ?? 1;\r\n              const newAchievement = targetValue > 0 ? (newTotal / targetValue) * 100 : 0;\r\n              \r\n              await prisma.kRAggregation.update({\r\n                where: { id: aggregation.id },\r\n                data: {\r\n                  total_reported: newTotal,\r\n                  submission_count: newCount,\r\n                  achievement_percent: Math.min(newAchievement, 100),\r\n                  last_updated: new Date(),\r\n                }\r\n              });\r\n              console.log(`[Document Delete] Deducted ${contrib.value} from KRAggregation ${aggregation.id}: new total=${newTotal}`);\r\n            }\r\n          } catch (deductError) {\r\n            console.error(`[Document Delete] Error deducting contribution for ${contrib.initiativeId}:`, deductError);\r\n          }\r\n        }\r\n      } \r\n      // Fallback: Legacy recalculation for documents without KPIContributions\r\n      else if (affectedAggregations.length > 0) {\r\n        console.log(`[Document Delete] Legacy recalculating ${affectedAggregations.length} affected KRAggregation records`);\r\n        \r\n        for (const affected of affectedAggregations) {\r\n          try {\r\n            // Get remaining approved activities for this aggregation\r\n            const remainingActivities = await prisma.aggregationActivity.findMany({\r\n              where: {\r\n                aggregation_id: affected.aggregationId,\r\n                isApproved: true,\r\n              },\r\n              select: {\r\n                reported: true,\r\n              }\r\n            });\r\n\r\n            if (remainingActivities.length === 0) {\r\n              // No more activities - delete the KRAggregation record\r\n              await prisma.kRAggregation.delete({\r\n                where: { id: affected.aggregationId },\r\n              });\r\n              console.log(`[Document Delete] Deleted orphaned KRAggregation: ${affected.aggregationId}`);\r\n            } else {\r\n              // Recalculate totals from remaining activities\r\n              const newTotal = remainingActivities.reduce((sum, a) => sum + (a.reported ?? 0), 0);\r\n              const newCount = remainingActivities.length;\r\n              \r\n              // Get target for achievement calculation\r\n              const aggregation = await prisma.kRAggregation.findUnique({\r\n                where: { id: affected.aggregationId },\r\n                select: { target_value: true }\r\n              });\r\n              \r\n              const targetValue = aggregation?.target_value?.toNumber() ?? 1;\r\n              const newAchievement = targetValue > 0 ? (newTotal / targetValue) * 100 : 0;\r\n              \r\n              await prisma.kRAggregation.update({\r\n                where: { id: affected.aggregationId },\r\n                data: {\r\n                  total_reported: newTotal,\r\n                  submission_count: newCount,\r\n                  achievement_percent: Math.min(newAchievement, 100),\r\n                  last_updated: new Date(),\r\n                }\r\n              });\r\n              console.log(`[Document Delete] Updated KRAggregation ${affected.aggregationId}: total=${newTotal}, count=${newCount}`);\r\n            }\r\n          } catch (recalcError) {\r\n            console.error(`[Document Delete] Error recalculating KRAggregation ${affected.aggregationId}:`, recalcError);\r\n            // Continue with other aggregations even if one fails\r\n          }\r\n        }\r\n      }\r\n  \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Database connection error in deleteDocument:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get document permissions\r\n   */\r\n  async getDocumentPermissions(documentId: string, userId: string): Promise<DocumentPermission[]> {\r\n    try {\r\n      const user = await this.findUserById(userId);\r\n  \r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n  \r\n      // Check if user has admin permission for the document\r\n      const adminPermission = await prisma.documentPermission.findFirst({\r\n        where: {\r\n          documentId,\r\n          userId: user.id, // Use the database user ID\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n  \r\n      if (!adminPermission && user.role !== 'ADMIN') {\r\n        throw new Error('User does not have permission to view document permissions');\r\n      }\r\n  \r\n      const permissions = await prisma.documentPermission.findMany({\r\n        where: { documentId },\r\n      });\r\n  \r\n      return permissions.map((perm: any) => ({\r\n        ...perm,\r\n        permission: perm.permission as 'READ' | 'WRITE' | 'ADMIN',\r\n        createdAt: new Date(perm.createdAt),\r\n      }));\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocumentPermissions:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add or update document permission\r\n   */\r\n  async setDocumentPermission(\r\n    documentId: string,\r\n    userId: string,\r\n    targetUserId: string,\r\n    permission: 'READ' | 'WRITE' | 'ADMIN'\r\n  ): Promise<DocumentPermission> {\r\n    try {\r\n      // Find the requesting user\r\n      const user = await this.findUserById(userId);\r\n  \r\n      if (!user) {\r\n        throw new Error('Requesting user not found');\r\n      }\r\n  \r\n      // Check if the requesting user has admin permission for the document\r\n      const adminPermission = await prisma.documentPermission.findFirst({\r\n        where: {\r\n          documentId,\r\n          userId: user.id, // Use the database user ID\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n  \r\n      if (!adminPermission && user.role !== 'ADMIN') {\r\n        throw new Error('User does not have permission to manage document permissions');\r\n      }\r\n  \r\n      // Find the target user\r\n      const targetUser = await this.findUserById(targetUserId);\r\n  \r\n      if (!targetUser) {\r\n        throw new Error('Target user does not exist');\r\n      }\r\n  \r\n      // Create or update the permission\r\n      const permissionRecord = await prisma.documentPermission.upsert({\r\n        where: {\r\n          documentId_userId: {\r\n            documentId,\r\n            userId: targetUser.id, // Use the target user's database ID\r\n          },\r\n        },\r\n        update: {\r\n          permission,\r\n        },\r\n        create: {\r\n          documentId,\r\n          userId: targetUser.id, // Use the target user's database ID\r\n          permission,\r\n        },\r\n      });\r\n  \r\n      return {\r\n        ...permissionRecord,\r\n        permission: permissionRecord.permission as 'READ' | 'WRITE' | 'ADMIN',\r\n        createdAt: new Date(permissionRecord.createdAt),\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in setDocumentPermission:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove document permission\r\n   */\r\n  async removeDocumentPermission(\r\n    documentId: string,\r\n    userId: string,\r\n    targetUserId: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Find the requesting user\r\n      const requestingUser = await this.findUserById(userId);\r\n\r\n      if (!requestingUser) {\r\n        throw new Error('Requesting user not found');\r\n      }\r\n\r\n      // Check if the requesting user has admin permission for the document\r\n      const adminPermission = await prisma.documentPermission.findFirst({\r\n        where: {\r\n          documentId,\r\n          userId: requestingUser.id, // Use the database user ID\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n\r\n      if (!adminPermission && requestingUser.role !== 'ADMIN') {\r\n        throw new Error('User does not have permission to manage document permissions');\r\n      }\r\n\r\n      // Find the target user\r\n      const targetUser = await this.findUserById(targetUserId);\r\n\r\n      if (!targetUser) {\r\n        throw new Error('Target user does not exist');\r\n      }\r\n\r\n      await prisma.documentPermission.delete({\r\n        where: {\r\n          documentId_userId: {\r\n            documentId,\r\n            userId: targetUser.id, // Use the target user's database ID\r\n          },\r\n        },\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Database connection error in removeDocumentPermission:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record document download\r\n   */\r\n  async recordDownload(documentId: string, userId: string): Promise<void> {\r\n    try {\r\n      const user = await this.findUserById(userId);\r\n\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      await prisma.documentDownload.create({\r\n        data: {\r\n          documentId,\r\n          userId: user.id, // Use the database user ID\r\n        },\r\n      });\r\n\r\n      // Increment download count\r\n      await prisma.document.update({\r\n        where: { id: documentId },\r\n        data: {\r\n          downloadsCount: {\r\n            increment: 1,\r\n          },\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.error('Database connection error in recordDownload:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n }\r\n\r\n  /**\r\n   * Record document view\r\n   */\r\n  async recordView(documentId: string, userId: string): Promise<void> {\r\n    try {\r\n      const user = await this.findUserById(userId);\r\n\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      // Check if user has already viewed the document recently to avoid inflating stats\r\n      const recentView = await prisma.documentView.findFirst({\r\n        where: {\r\n          documentId,\r\n          userId: user.id, // Use the database user ID\r\n          viewedAt: {\r\n            gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Within last 24 hours\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!recentView) {\r\n        await prisma.documentView.create({\r\n          data: {\r\n            documentId,\r\n            userId: user.id, // Use the database user ID\r\n          },\r\n        });\r\n\r\n        // Increment view count\r\n        await prisma.document.update({\r\n          where: { id: documentId },\r\n          data: {\r\n            viewsCount: {\r\n              increment: 1,\r\n            },\r\n          },\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Database connection error in recordView:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n }\r\n\r\n  /**\r\n   * Get document comments\r\n   */\r\n  async getDocumentComments(\r\n    documentId: string,\r\n    page: number = 1,\r\n    limit: number = 10\r\n  ): Promise<{ comments: DocumentComment[]; total: number }> {\r\n    try {\r\n      const skip = (page - 1) * limit;\r\n\r\n      const [comments, total] = await Promise.all([\r\n        prisma.documentComment.findMany({\r\n          where: { documentId },\r\n          skip,\r\n          take: limit,\r\n          orderBy: { createdAt: 'desc' },\r\n          include: {\r\n            user: true,\r\n          }\r\n        }),\r\n        prisma.documentComment.count({ where: { documentId } }),\r\n      ]);\r\n\r\n      return {\r\n        comments: comments.map((comment: any) => ({\r\n          ...comment,\r\n          parentCommentId: comment.parentCommentId ?? undefined, // Convert null to undefined\r\n          createdAt: new Date(comment.createdAt),\r\n          updatedAt: new Date(comment.updatedAt),\r\n        })),\r\n        total,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocumentComments:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add comment to document\r\n   */\r\n  async addDocumentComment(\r\n    documentId: string,\r\n    userId: string,\r\n    content: string,\r\n    parentCommentId?: string\r\n  ): Promise<DocumentComment> {\r\n    try {\r\n      // Check if document exists\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId },\r\n      });\r\n\r\n      if (!document) {\r\n        throw new Error('Document not found');\r\n      }\r\n\r\n      // Find the user\r\n      const user = await this.findUserById(userId);\r\n\r\n      if (!user) {\r\n        throw new Error('User not found');\r\n      }\r\n\r\n      // Check if user has permission to comment (must have read access)\r\n      // Allow admins and faculty to comment on any document\r\n      if (user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n        const permission = await prisma.documentPermission.findFirst({\r\n          where: {\r\n            documentId,\r\n            userId: user.id, // Use the database user ID\r\n            permission: { in: ['READ', 'WRITE', 'ADMIN'] }, // User needs at least READ permission to comment\r\n          },\r\n        });\r\n\r\n        if (!permission && document.uploadedById !== user.id) {\r\n          throw new Error('User does not have permission to comment on this document');\r\n        }\r\n      }\r\n\r\n      if (parentCommentId) {\r\n        // Verify the parent comment exists and belongs to the same document\r\n        const parentComment = await prisma.documentComment.findUnique({\r\n          where: { id: parentCommentId },\r\n        });\r\n\r\n        if (!parentComment || parentComment.documentId !== documentId) {\r\n          throw new Error('Invalid parent comment');\r\n        }\r\n      }\r\n\r\n      const comment = await prisma.documentComment.create({\r\n        data: {\r\n          documentId,\r\n          userId: user.id, // Use the database user ID\r\n          content,\r\n          parentCommentId,\r\n        },\r\n      });\r\n\r\n      return {\r\n        ...comment,\r\n        parentCommentId: comment.parentCommentId ?? undefined, // Convert null to undefined\r\n        createdAt: new Date(comment.createdAt),\r\n        updatedAt: new Date(comment.updatedAt),\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in addDocumentComment:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a document by its Colivara document ID\r\n   */\r\n  async getDocumentByColivaraId(colivaraDocumentId: string, userId?: string): Promise<Document | null> {\r\n    try {\r\n      // Validate the colivara document ID format before querying the database\r\n      if (!colivaraDocumentId || typeof colivaraDocumentId !== 'string' || colivaraDocumentId.trim() === '' || colivaraDocumentId.includes('undefined') || colivaraDocumentId.includes('.pdf') || colivaraDocumentId.includes('.')) {\r\n        console.warn('Invalid colivara document ID format received in getDocumentByColivaraId:', colivaraDocumentId);\r\n        return null;\r\n      }\r\n\r\n      // Find the document that has this colivaraDocumentId\r\n      const dbDocument = await prisma.document.findFirst({\r\n        where: {\r\n          colivaraDocumentId: colivaraDocumentId\r\n        },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!dbDocument) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has access to the document - reuse the same access logic as getDocumentById\r\n      if (userId) {\r\n        const user = await this.findUserById(userId);\r\n\r\n        if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n          // Check if user has explicit permission for this document\r\n          const permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: dbDocument.id,  // Use the database document ID for permission check\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['READ', 'WRITE', 'ADMIN'] }, // User needs at least READ permission\r\n            },\r\n          });\r\n\r\n          // Allow access if user has explicit READ/WRITE/ADMIN permission OR if user uploaded the document\r\n          if (!permission && dbDocument.uploadedById !== user.id) {\r\n            return null; // User doesn't have access\r\n          }\r\n        }\r\n      }\r\n\r\n      // Return the document in the expected format\r\n      return {\r\n        id: dbDocument.id,\r\n        title: dbDocument.title,\r\n        description: dbDocument.description,\r\n        category: dbDocument.category,\r\n        tags: Array.isArray(dbDocument.tags) ?\r\n          (dbDocument.tags as any[]).map(tag => String(tag)) :\r\n          (typeof dbDocument.tags === 'object' && dbDocument.tags !== null ?\r\n            Object.values(dbDocument.tags).map(tag => String(tag)) : []),\r\n        uploadedBy: dbDocument.uploadedByUser?.name || dbDocument.uploadedBy,\r\n        uploadedById: dbDocument.uploadedById,\r\n        uploadedAt: new Date(dbDocument.uploadedAt),\r\n        fileUrl: dbDocument.fileUrl,\r\n        fileName: dbDocument.fileName,\r\n        fileType: dbDocument.fileType,\r\n        fileSize: dbDocument.fileSize,\r\n        downloadsCount: dbDocument.downloadsCount || 0, // Convert null to 0\r\n        viewsCount: dbDocument.viewsCount || 0, // Convert null to 0\r\n        version: dbDocument.version || 1,\r\n        versionNotes: dbDocument.versionNotes || undefined, // Convert null to undefined\r\n        status: dbDocument.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW',\r\n        createdAt: new Date(dbDocument.createdAt),\r\n        updatedAt: new Date(dbDocument.updatedAt),\r\n        unitId: dbDocument.unitId || undefined, // Convert null to undefined\r\n        unit: dbDocument.documentUnit ? {\r\n          id: dbDocument.documentUnit.id,\r\n          name: dbDocument.documentUnit.name,\r\n          code: dbDocument.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: dbDocument.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: dbDocument.documentUnit.createdAt,\r\n          updatedAt: dbDocument.documentUnit.updatedAt,\r\n        } : undefined,\r\n        colivaraDocumentId: dbDocument.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: dbDocument.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: dbDocument.colivaraProcessedAt ? new Date(dbDocument.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: dbDocument.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocumentByColivaraId:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error &&\r\n          (error.message.includes('Authentication failed') ||\r\n           error.message.includes('password') ||\r\n           error.message.includes('credentials'))) {\r\n        throw new Error('Database authentication failed. Please check your database credentials.');\r\n      }\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n}\r\n\r\nexport default new DocumentService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3121, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/app/api/documents/%5Bid%5D/view/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireAuth } from '@/lib/middleware/auth-middleware';\r\nimport documentService from '@/lib/services/document-service';\r\nimport fileStorageService from '@/lib/services/file-storage-service';\r\n\r\nexport async function GET(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ id: string }> }\r\n) {\r\n  try {\r\n    const { id } = await params;\r\n\r\n    // Verify authentication\r\n    const authResult = await requireAuth(request);\r\n    if ('status' in authResult) {\r\n      return authResult;\r\n    }\r\n\r\n    const { user } = authResult;\r\n    const userId = user.id;\r\n\r\n    // Get document\r\n    const document = await documentService.getDocumentById(id, userId);\r\n    \r\n    if (!document) {\r\n      return NextResponse.json(\r\n        { error: 'Document not found or access denied' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Record the view\r\n    await documentService.recordView(document.id, userId);\r\n\r\n    // Extract filename from the stored URL\r\n    const fileName = document.fileUrl.split('/').pop();\r\n    if (!fileName) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid file URL' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    try {\r\n      // Generate a signed URL with inline content disposition for viewing\r\n      const fileUrl = await fileStorageService.getFileUrl(fileName, 'repository-files');\r\n      \r\n      // Redirect to the file URL which will display inline\r\n      return NextResponse.redirect(fileUrl);\r\n    } catch (error) {\r\n      console.error('Error getting file URL:', error);\r\n      return NextResponse.json(\r\n        { error: 'Failed to retrieve file' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n  } catch (error) {\r\n    console.error('Error in view endpoint:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QAErB,wBAAwB;QACxB,MAAM,aAAa,MAAM,IAAA,wJAAW,EAAC;QACrC,IAAI,YAAY,YAAY;YAC1B,OAAO;QACT;QAEA,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,MAAM,SAAS,KAAK,EAAE;QAEtB,eAAe;QACf,MAAM,WAAW,MAAM,mJAAe,CAAC,eAAe,CAAC,IAAI;QAE3D,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAsC,GAC/C;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,mJAAe,CAAC,UAAU,CAAC,SAAS,EAAE,EAAE;QAE9C,uCAAuC;QACvC,MAAM,WAAW,SAAS,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG;QAChD,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmB,GAC5B;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI;YACF,oEAAoE;YACpE,MAAM,UAAU,MAAM,0JAAkB,CAAC,UAAU,CAAC,UAAU;YAE9D,qDAAqD;YACrD,OAAO,gJAAY,CAAC,QAAQ,CAAC;QAC/B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}