module.exports = [
"[project]/node_modules/@azure/storage-blob/dist/esm/log.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "logger",
    ()=>logger
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$logger$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/logger/dist/esm/index.js [app-route] (ecmascript)");
;
const logger = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$logger$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClientLogger"])("storage-blob"); //# sourceMappingURL=log.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/RequestPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * The base class from which all request policies derive.
 */ __turbopack_context__.s([
    "BaseRequestPolicy",
    ()=>BaseRequestPolicy
]);
class BaseRequestPolicy {
    _nextPolicy;
    _options;
    /**
     * The main method to implement that manipulates a request/response.
     */ constructor(/**
     * The next policy in the pipeline. Each policy is responsible for executing the next one if the request is to continue through the pipeline.
     */ _nextPolicy, /**
     * The options that can be passed to a given request policy.
     */ _options){
        this._nextPolicy = _nextPolicy;
        this._options = _options;
    }
    /**
     * Get whether or not a log with the provided log level should be logged.
     * @param logLevel - The log level of the log that will be logged.
     * @returns Whether or not a log with the provided log level should be logged.
     */ shouldLog(logLevel) {
        return this._options.shouldLog(logLevel);
    }
    /**
     * Attempt to log the provided message to the provided logger. If no logger was provided or if
     * the log level does not meat the logger's threshold, then nothing will be logged.
     * @param logLevel - The log level of this log.
     * @param message - The message of this log.
     */ log(logLevel, message) {
        this._options.log(logLevel, message);
    }
} //# sourceMappingURL=RequestPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicyType.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * RetryPolicy types.
 */ __turbopack_context__.s([
    "StorageRetryPolicyType",
    ()=>StorageRetryPolicyType
]);
var StorageRetryPolicyType;
(function(StorageRetryPolicyType) {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */ StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    /**
     * Linear retry. Retry time delay grows linearly.
     */ StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
})(StorageRetryPolicyType || (StorageRetryPolicyType = {})); //# sourceMappingURL=StorageRetryPolicyType.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "NewRetryPolicyFactory",
    ()=>NewRetryPolicyFactory,
    "StorageRetryPolicy",
    ()=>StorageRetryPolicy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/AbortError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/RequestPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/log.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicyType.js [app-route] (ecmascript)");
;
;
;
;
;
;
function NewRetryPolicyFactory(retryOptions) {
    return {
        create: (nextPolicy, options)=>{
            return new StorageRetryPolicy(nextPolicy, options, retryOptions);
        }
    };
}
// Default values of StorageRetryOptions
const DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicyType"].EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
};
const RETRY_ABORT_ERROR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbortError"]("The operation was aborted.");
class StorageRetryPolicy extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseRequestPolicy"] {
    /**
     * RetryOptions.
     */ retryOptions;
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param retryOptions -
     */ constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS){
        super(nextPolicy, options);
        // Initialize retry options
        this.retryOptions = {
            retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
            maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
            tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
            retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
            maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
            secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
        };
    }
    /**
     * Sends request.
     *
     * @param request -
     */ async sendRequest(request) {
        return this.attemptSendRequest(request, false, 1);
    }
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @param request -
     * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     */ async attemptSendRequest(request, secondaryHas404, attempt) {
        const newRequest = request.clone();
        const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
        if (!isPrimaryRetry) {
            newRequest.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setURLHost"])(newRequest.url, this.retryOptions.secondaryHost);
        }
        // Set the server-side timeout query parameter "timeout=[seconds]"
        if (this.retryOptions.tryTimeoutInMs) {
            newRequest.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setURLParameter"])(newRequest.url, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URLConstants"].Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
        }
        let response;
        try {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
            response = await this._nextPolicy.sendRequest(newRequest);
            if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
                return response;
            }
            secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
        } catch (err) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
            if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
                throw err;
            }
        }
        await this.delay(isPrimaryRetry, attempt, request.abortSignal);
        return this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param response -
     * @param err -
     */ shouldRetry(isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
            return false;
        }
        // Handle network failures, you may need to customize the list when you implement
        // your own http client
        const retriableErrors = [
            "ETIMEDOUT",
            "ESOCKETTIMEDOUT",
            "ECONNREFUSED",
            "ECONNRESET",
            "ENOENT",
            "ENOTFOUND",
            "TIMEOUT",
            "EPIPE",
            "REQUEST_SEND_ERROR"
        ];
        if (err) {
            for (const retriableError of retriableErrors){
                if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
                    return true;
                }
            }
        }
        // If attempt was against the secondary & it returned a StatusNotFound (404), then
        // the resource was not found. This may be due to replication delay. So, in this
        // case, we'll never try the secondary again for this operation.
        if (response || err) {
            const statusCode = response ? response.status : err ? err.statusCode : 0;
            if (!isPrimaryRetry && statusCode === 404) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Secondary access with 404, will retry.`);
                return true;
            }
            // Server internal error or server timeout
            if (statusCode === 503 || statusCode === 500) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Will retry for status code ${statusCode}.`);
                return true;
            }
        }
        if (response) {
            // Retry select Copy Source Error Codes.
            if (response?.status >= 400) {
                const copySourceError = response.headers.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_CopySourceErrorCode);
                if (copySourceError !== undefined) {
                    switch(copySourceError){
                        case "InternalError":
                        case "OperationTimedOut":
                        case "ServerBusy":
                            return true;
                    }
                }
            }
        }
        if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
        }
        return false;
    }
    /**
     * Delay a calculated time between retries.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param abortSignal -
     */ async delay(isPrimaryRetry, attempt, abortSignal) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
            switch(this.retryOptions.retryPolicyType){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicyType"].EXPONENTIAL:
                    delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicyType"].FIXED:
                    delayTimeInMs = this.retryOptions.retryDelayInMs;
                    break;
            }
        } else {
            delayTimeInMs = Math.random() * 1000;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["delay"])(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR);
    }
} //# sourceMappingURL=StorageRetryPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/CredentialPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "CredentialPolicy",
    ()=>CredentialPolicy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/RequestPolicy.js [app-route] (ecmascript)");
;
class CredentialPolicy extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseRequestPolicy"] {
    /**
     * Sends out request.
     *
     * @param request -
     */ sendRequest(request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @param request -
     */ signRequest(request) {
        // Child classes must override this method with request signing. This method
        // will be executed in sendRequest().
        return request;
    }
} //# sourceMappingURL=CredentialPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageSharedKeyCredentialPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageSharedKeyCredentialPolicy",
    ()=>StorageSharedKeyCredentialPolicy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$CredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/CredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$SharedKeyComparator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/SharedKeyComparator.js [app-route] (ecmascript)");
;
;
;
;
class StorageSharedKeyCredentialPolicy extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$CredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CredentialPolicy"] {
    /**
     * Reference to StorageSharedKeyCredential which generates StorageSharedKeyCredentialPolicy
     */ factory;
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     * @param factory -
     */ constructor(nextPolicy, options, factory){
        super(nextPolicy, options);
        this.factory = factory;
    }
    /**
     * Signs request.
     *
     * @param request -
     */ signRequest(request) {
        request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_DATE, new Date().toUTCString());
        if (request.body && (typeof request.body === "string" || request.body !== undefined) && request.body.length > 0) {
            request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
            request.method.toUpperCase(),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LANGUAGE),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_ENCODING),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_MD5),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_TYPE),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].DATE),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_MATCH),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_NONE_MATCH),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_UNMODIFIED_SINCE),
            this.getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].RANGE)
        ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
        const signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
        // console.log(`[URL]:${request.url}`);
        // console.log(`[HEADERS]:${request.headers.toString()}`);
        // console.log(`[STRING TO SIGN]:${JSON.stringify(stringToSign)}`);
        // console.log(`[KEY]: ${request.headers.get(HeaderConstants.AUTHORIZATION)}`);
        return request;
    }
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
     *
     * @param request -
     * @param headerName -
     */ getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
            return "";
        }
        // When using version 2015-02-21 or later, if Content-Length is zero, then
        // set the Content-Length part of the StringToSign to an empty string.
        // https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
        if (headerName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH && value === "0") {
            return "";
        }
        return value;
    }
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @param request -
     */ getCanonicalizedHeadersString(request) {
        let headersArray = request.headers.headersArray().filter((value)=>{
            return value.name.toLowerCase().startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].PREFIX_FOR_STORAGE);
        });
        headersArray.sort((a, b)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$SharedKeyComparator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compareHeader"])(a.name.toLowerCase(), b.name.toLowerCase());
        });
        // Remove duplicate headers
        headersArray = headersArray.filter((value, index, array)=>{
            if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
                return false;
            }
            return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header)=>{
            canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
        });
        return canonicalizedHeadersStringToSign;
    }
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @param request -
     */ getCanonicalizedResourceString(request) {
        const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLPath"])(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${this.factory.accountName}${path}`;
        const queries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLQueries"])(request.url);
        const lowercaseQueries = {};
        if (queries) {
            const queryKeys = [];
            for(const key in queries){
                if (Object.prototype.hasOwnProperty.call(queries, key)) {
                    const lowercaseKey = key.toLowerCase();
                    lowercaseQueries[lowercaseKey] = queries[key];
                    queryKeys.push(lowercaseKey);
                }
            }
            queryKeys.sort();
            for (const key of queryKeys){
                canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
            }
        }
        return canonicalizedResourceString;
    }
} //# sourceMappingURL=StorageSharedKeyCredentialPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/AnonymousCredentialPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "AnonymousCredentialPolicy",
    ()=>AnonymousCredentialPolicy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$CredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/CredentialPolicy.js [app-route] (ecmascript)");
;
class AnonymousCredentialPolicy extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$CredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CredentialPolicy"] {
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     */ // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/ constructor(nextPolicy, options){
        super(nextPolicy, options);
    }
} //# sourceMappingURL=AnonymousCredentialPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageBrowserPolicyV2.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "storageBrowserPolicy",
    ()=>storageBrowserPolicy,
    "storageBrowserPolicyName",
    ()=>storageBrowserPolicyName
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
const storageBrowserPolicyName = "storageBrowserPolicy";
function storageBrowserPolicy() {
    return {
        name: storageBrowserPolicyName,
        async sendRequest (request, next) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"]) {
                return next(request);
            }
            if (request.method === "GET" || request.method === "HEAD") {
                request.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setURLParameter"])(request.url, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URLConstants"].Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
            }
            request.headers.delete(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].COOKIE);
            // According to XHR standards, content-length should be fully controlled by browsers
            request.headers.delete(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH);
            return next(request);
        }
    };
} //# sourceMappingURL=StorageBrowserPolicyV2.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicyV2.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "storageRetryPolicy",
    ()=>storageRetryPolicy,
    "storageRetryPolicyName",
    ()=>storageRetryPolicyName
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/AbortError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$restError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/restError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/error.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageRetryPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageRetryPolicyFactory.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicyType.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/log.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
const storageRetryPolicyName = "storageRetryPolicy";
// Default values of StorageRetryOptions
const DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicyType"].EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
};
const retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
];
const RETRY_ABORT_ERROR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbortError"]("The operation was aborted.");
function storageRetryPolicy(options = {}) {
    const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
    const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
    const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
    const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
    const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
    const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
        if (attempt >= maxTries) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
            return false;
        }
        if (error) {
            for (const retriableError of retriableErrors){
                if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
                    return true;
                }
            }
            if (error?.code === "PARSE_ERROR" && error?.message.startsWith(`Error "Error: Unclosed root tag`)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
                return true;
            }
        }
        // If attempt was against the secondary & it returned a StatusNotFound (404), then
        // the resource was not found. This may be due to replication delay. So, in this
        // case, we'll never try the secondary again for this operation.
        if (response || error) {
            const statusCode = response?.status ?? error?.statusCode ?? 0;
            if (!isPrimaryRetry && statusCode === 404) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Secondary access with 404, will retry.`);
                return true;
            }
            // Server internal error or server timeout
            if (statusCode === 503 || statusCode === 500) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Will retry for status code ${statusCode}.`);
                return true;
            }
        }
        if (response) {
            // Retry select Copy Source Error Codes.
            if (response?.status >= 400) {
                const copySourceError = response.headers.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_CopySourceErrorCode);
                if (copySourceError !== undefined) {
                    switch(copySourceError){
                        case "InternalError":
                        case "OperationTimedOut":
                        case "ServerBusy":
                            return true;
                    }
                }
            }
        }
        return false;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
            switch(retryPolicyType){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicyType"].EXPONENTIAL:
                    delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicyType"].FIXED:
                    delayTimeInMs = retryDelayInMs;
                    break;
            }
        } else {
            delayTimeInMs = Math.random() * 1000;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return delayTimeInMs;
    }
    return {
        name: storageRetryPolicyName,
        async sendRequest (request, next) {
            // Set the server-side timeout query parameter "timeout=[seconds]"
            if (tryTimeoutInMs) {
                request.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setURLParameter"])(request.url, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URLConstants"].Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
            }
            const primaryUrl = request.url;
            const secondaryUrl = secondaryHost ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setURLHost"])(request.url, secondaryHost) : undefined;
            let secondaryHas404 = false;
            let attempt = 1;
            let retryAgain = true;
            let response;
            let error;
            while(retryAgain){
                const isPrimaryRetry = secondaryHas404 || !secondaryUrl || ![
                    "GET",
                    "HEAD",
                    "OPTIONS"
                ].includes(request.method) || attempt % 2 === 1;
                request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
                response = undefined;
                error = undefined;
                try {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
                    response = await next(request);
                    secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
                } catch (e) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$restError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRestError"])(e)) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
                        error = e;
                    } else {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(`RetryPolicy: Caught error, message: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(e)}`);
                        throw e;
                    }
                }
                retryAgain = shouldRetry({
                    isPrimaryRetry,
                    attempt,
                    response,
                    error
                });
                if (retryAgain) {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["delay"])(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
                }
                attempt++;
            }
            if (response) {
                return response;
            }
            throw error ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$restError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RestError"]("RetryPolicy failed without known error.");
        }
    };
} //# sourceMappingURL=StorageRetryPolicyV2.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageSharedKeyCredentialPolicyV2.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "storageSharedKeyCredentialPolicy",
    ()=>storageSharedKeyCredentialPolicy,
    "storageSharedKeyCredentialPolicyName",
    ()=>storageSharedKeyCredentialPolicyName
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$SharedKeyComparator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/SharedKeyComparator.js [app-route] (ecmascript)");
;
;
;
;
const storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
function storageSharedKeyCredentialPolicy(options) {
    function signRequest(request) {
        request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_DATE, new Date().toUTCString());
        if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
            request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
            request.method.toUpperCase(),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LANGUAGE),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_ENCODING),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_MD5),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_TYPE),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].DATE),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_MODIFIED_SINCE),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_MATCH),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_NONE_MATCH),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].IF_UNMODIFIED_SINCE),
            getHeaderValueToSign(request, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].RANGE)
        ].join("\n") + "\n" + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request);
        const signature = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHmac"])("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
        request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
    // console.log(`[URL]:${request.url}`);
    // console.log(`[HEADERS]:${request.headers.toString()}`);
    // console.log(`[STRING TO SIGN]:${JSON.stringify(stringToSign)}`);
    // console.log(`[KEY]: ${request.headers.get(HeaderConstants.AUTHORIZATION)}`);
    }
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
     */ function getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
            return "";
        }
        // When using version 2015-02-21 or later, if Content-Length is zero, then
        // set the Content-Length part of the StringToSign to an empty string.
        // https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
        if (headerName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH && value === "0") {
            return "";
        }
        return value;
    }
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     */ function getCanonicalizedHeadersString(request) {
        let headersArray = [];
        for (const [name, value] of request.headers){
            if (name.toLowerCase().startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].PREFIX_FOR_STORAGE)) {
                headersArray.push({
                    name,
                    value
                });
            }
        }
        headersArray.sort((a, b)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$SharedKeyComparator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compareHeader"])(a.name.toLowerCase(), b.name.toLowerCase());
        });
        // Remove duplicate headers
        headersArray = headersArray.filter((value, index, array)=>{
            if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
                return false;
            }
            return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header)=>{
            canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
        });
        return canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request) {
        const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLPath"])(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${options.accountName}${path}`;
        const queries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLQueries"])(request.url);
        const lowercaseQueries = {};
        if (queries) {
            const queryKeys = [];
            for(const key in queries){
                if (Object.prototype.hasOwnProperty.call(queries, key)) {
                    const lowercaseKey = key.toLowerCase();
                    lowercaseQueries[lowercaseKey] = queries[key];
                    queryKeys.push(lowercaseKey);
                }
            }
            queryKeys.sort();
            for (const key of queryKeys){
                canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
            }
        }
        return canonicalizedResourceString;
    }
    return {
        name: storageSharedKeyCredentialPolicyName,
        async sendRequest (request, next) {
            signRequest(request);
            return next(request);
        }
    };
} //# sourceMappingURL=StorageSharedKeyCredentialPolicyV2.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageBrowserPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageBrowserPolicy",
    ()=>StorageBrowserPolicy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/RequestPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
;
class StorageBrowserPolicy extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseRequestPolicy"] {
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param nextPolicy -
     * @param options -
     */ // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/ constructor(nextPolicy, options){
        super(nextPolicy, options);
    }
    /**
     * Sends out request.
     *
     * @param request -
     */ async sendRequest(request) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"]) {
            return this._nextPolicy.sendRequest(request);
        }
        if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") {
            request.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setURLParameter"])(request.url, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URLConstants"].Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
        }
        request.headers.remove(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].COOKIE);
        // According to XHR standards, content-length should be fully controlled by browsers
        request.headers.remove(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH);
        return this._nextPolicy.sendRequest(request);
    }
} //# sourceMappingURL=StorageBrowserPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageCorrectContentLengthPolicy.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "storageCorrectContentLengthPolicy",
    ()=>storageCorrectContentLengthPolicy,
    "storageCorrectContentLengthPolicyName",
    ()=>storageCorrectContentLengthPolicyName
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
;
const storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
function storageCorrectContentLengthPolicy() {
    function correctContentLength(request) {
        if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
            request.headers.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
    }
    return {
        name: storageCorrectContentLengthPolicyName,
        async sendRequest (request, next) {
            correctContentLength(request);
            return next(request);
        }
    };
} //# sourceMappingURL=StorageCorrectContentLengthPolicy.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BATCH_MAX_PAYLOAD_IN_BYTES",
    ()=>BATCH_MAX_PAYLOAD_IN_BYTES,
    "BATCH_MAX_REQUEST",
    ()=>BATCH_MAX_REQUEST,
    "BLOCK_BLOB_MAX_BLOCKS",
    ()=>BLOCK_BLOB_MAX_BLOCKS,
    "BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES",
    ()=>BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES,
    "BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES",
    ()=>BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES,
    "BlobDoesNotUseCustomerSpecifiedEncryption",
    ()=>BlobDoesNotUseCustomerSpecifiedEncryption,
    "BlobUsesCustomerSpecifiedEncryptionMsg",
    ()=>BlobUsesCustomerSpecifiedEncryptionMsg,
    "DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES",
    ()=>DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES,
    "DEFAULT_BLOCK_BUFFER_SIZE_BYTES",
    ()=>DEFAULT_BLOCK_BUFFER_SIZE_BYTES,
    "DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS",
    ()=>DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS,
    "DevelopmentConnectionString",
    ()=>DevelopmentConnectionString,
    "ETagAny",
    ()=>ETagAny,
    "ETagNone",
    ()=>ETagNone,
    "EncryptionAlgorithmAES25",
    ()=>EncryptionAlgorithmAES25,
    "HTTPURLConnection",
    ()=>HTTPURLConnection,
    "HTTP_LINE_ENDING",
    ()=>HTTP_LINE_ENDING,
    "HTTP_VERSION_1_1",
    ()=>HTTP_VERSION_1_1,
    "HeaderConstants",
    ()=>HeaderConstants,
    "PathStylePorts",
    ()=>PathStylePorts,
    "REQUEST_TIMEOUT",
    ()=>REQUEST_TIMEOUT,
    "SDK_VERSION",
    ()=>SDK_VERSION,
    "SERVICE_VERSION",
    ()=>SERVICE_VERSION,
    "SIZE_1_MB",
    ()=>SIZE_1_MB,
    "StorageBlobLoggingAllowedHeaderNames",
    ()=>StorageBlobLoggingAllowedHeaderNames,
    "StorageBlobLoggingAllowedQueryParameters",
    ()=>StorageBlobLoggingAllowedQueryParameters,
    "StorageOAuthScopes",
    ()=>StorageOAuthScopes,
    "URLConstants",
    ()=>URLConstants
]);
const SDK_VERSION = "12.29.1";
const SERVICE_VERSION = "2025-11-05";
const BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024; // 256MB
const BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4000 * 1024 * 1024; // 4000MB
const BLOCK_BLOB_MAX_BLOCKS = 50000;
const DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024; // 8MB
const DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024; // 4MB
const DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
const REQUEST_TIMEOUT = 100 * 1000; // In ms
const StorageOAuthScopes = "https://storage.azure.com/.default";
const URLConstants = {
    Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SIGNATURE: "sig",
        SNAPSHOT: "snapshot",
        VERSIONID: "versionid",
        TIMEOUT: "timeout"
    }
};
const HTTPURLConnection = {
    HTTP_ACCEPTED: 202,
    HTTP_CONFLICT: 409,
    HTTP_NOT_FOUND: 404,
    HTTP_PRECON_FAILED: 412,
    HTTP_RANGE_NOT_SATISFIABLE: 416
};
const HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
};
const ETagNone = "";
const ETagAny = "*";
const SIZE_1_MB = 1 * 1024 * 1024;
const BATCH_MAX_REQUEST = 256;
const BATCH_MAX_PAYLOAD_IN_BYTES = 4 * SIZE_1_MB;
const HTTP_LINE_ENDING = "\r\n";
const HTTP_VERSION_1_1 = "HTTP/1.1";
const EncryptionAlgorithmAES25 = "AES256";
const DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
const StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags"
];
const StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
];
const BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
const BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
const PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
]; //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobNameToString",
    ()=>BlobNameToString,
    "ConvertInternalResponseOfListBlobFlat",
    ()=>ConvertInternalResponseOfListBlobFlat,
    "ConvertInternalResponseOfListBlobHierarchy",
    ()=>ConvertInternalResponseOfListBlobHierarchy,
    "EscapePath",
    ()=>EscapePath,
    "ExtractPageRangeInfoItems",
    ()=>ExtractPageRangeInfoItems,
    "appendToURLPath",
    ()=>appendToURLPath,
    "appendToURLQuery",
    ()=>appendToURLQuery,
    "assertResponse",
    ()=>assertResponse,
    "attachCredential",
    ()=>attachCredential,
    "base64decode",
    ()=>base64decode,
    "base64encode",
    ()=>base64encode,
    "delay",
    ()=>delay,
    "escapeURLPath",
    ()=>escapeURLPath,
    "extractConnectionStringParts",
    ()=>extractConnectionStringParts,
    "generateBlockID",
    ()=>generateBlockID,
    "getAccountNameFromUrl",
    ()=>getAccountNameFromUrl,
    "getURLParameter",
    ()=>getURLParameter,
    "getURLPath",
    ()=>getURLPath,
    "getURLPathAndQuery",
    ()=>getURLPathAndQuery,
    "getURLQueries",
    ()=>getURLQueries,
    "getURLScheme",
    ()=>getURLScheme,
    "getValueInConnString",
    ()=>getValueInConnString,
    "httpAuthorizationToString",
    ()=>httpAuthorizationToString,
    "iEqual",
    ()=>iEqual,
    "isIpEndpointStyle",
    ()=>isIpEndpointStyle,
    "padStart",
    ()=>padStart,
    "parseObjectReplicationRecord",
    ()=>parseObjectReplicationRecord,
    "sanitizeHeaders",
    ()=>sanitizeHeaders,
    "sanitizeURL",
    ()=>sanitizeURL,
    "setURLHost",
    ()=>setURLHost,
    "setURLParameter",
    ()=>setURLParameter,
    "toBlobTags",
    ()=>toBlobTags,
    "toBlobTagsString",
    ()=>toBlobTagsString,
    "toQuerySerialization",
    ()=>toQuerySerialization,
    "toTags",
    ()=>toTags,
    "truncatedISO8061Date",
    ()=>truncatedISO8061Date
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$httpHeaders$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/httpHeaders.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
;
;
;
function escapeURLPath(url) {
    const urlParsed = new URL(url);
    let path = urlParsed.pathname;
    path = path || "/";
    path = escape(path);
    urlParsed.pathname = path;
    return urlParsed.toString();
}
function getProxyUriFromDevConnString(connectionString) {
    // Development Connection String
    // https://learn.microsoft.com/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
        // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri
        const matchCredentials = connectionString.split(";");
        for (const element of matchCredentials){
            if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
                proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
            }
        }
    }
    return proxyUri;
}
function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements){
        if (element.trim().startsWith(argument)) {
            return element.trim().match(argument + "=(.*)")[1];
        }
    }
    return "";
}
function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
        // Development connection string
        proxyUri = getProxyUriFromDevConnString(connectionString);
        connectionString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DevelopmentConnectionString"];
    }
    // Matching BlobEndpoint in the Account connection string
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    // Slicing off '/' at the end if exists
    // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
        // Account connection string
        let defaultEndpointsProtocol = "";
        let accountName = "";
        let accountKey = Buffer.from("accountKey", "base64");
        let endpointSuffix = "";
        // Get account name and key
        accountName = getValueInConnString(connectionString, "AccountName");
        accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
        if (!blobEndpoint) {
            // BlobEndpoint is not present in the Account connection string
            // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`
            defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
            const protocol = defaultEndpointsProtocol.toLowerCase();
            if (protocol !== "https" && protocol !== "http") {
                throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
            }
            endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
            if (!endpointSuffix) {
                throw new Error("Invalid EndpointSuffix in the provided Connection String");
            }
            blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
        }
        if (!accountName) {
            throw new Error("Invalid AccountName in the provided Connection String");
        } else if (accountKey.length === 0) {
            throw new Error("Invalid AccountKey in the provided Connection String");
        }
        return {
            kind: "AccountConnString",
            url: blobEndpoint,
            accountName,
            accountKey,
            proxyUri
        };
    } else {
        // SAS connection string
        let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
        let accountName = getValueInConnString(connectionString, "AccountName");
        // if accountName is empty, try to read it from BlobEndpoint
        if (!accountName) {
            accountName = getAccountNameFromUrl(blobEndpoint);
        }
        if (!blobEndpoint) {
            throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
        } else if (!accountSas) {
            throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
        }
        // client constructors assume accountSas does *not* start with ?
        if (accountSas.startsWith("?")) {
            accountSas = accountSas.substring(1);
        }
        return {
            kind: "SASConnString",
            url: blobEndpoint,
            accountName,
            accountSas
        };
    }
}
/**
 * Internal escape method implemented Strategy Two mentioned in escapeURL() description.
 *
 * @param text -
 */ function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/") // Don't escape for "/"
    .replace(/'/g, "%27") // Escape for "'"
    .replace(/\+/g, "%20").replace(/%25/g, "%"); // Revert encoded "%"
}
function appendToURLPath(url, name) {
    const urlParsed = new URL(url);
    let path = urlParsed.pathname;
    path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name;
    urlParsed.pathname = path;
    return urlParsed.toString();
}
function setURLParameter(url, name, value) {
    const urlParsed = new URL(url);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : undefined;
    // mutating searchParams will change the encoding, so we have to do this ourselves
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")){
        if (pair) {
            const [key] = pair.split("=", 2);
            if (key !== encodedName) {
                searchPieces.push(pair);
            }
        }
    }
    if (encodedValue) {
        searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
}
function getURLParameter(url, name) {
    const urlParsed = new URL(url);
    return urlParsed.searchParams.get(name) ?? undefined;
}
function setURLHost(url, host) {
    const urlParsed = new URL(url);
    urlParsed.hostname = host;
    return urlParsed.toString();
}
function getURLPath(url) {
    try {
        const urlParsed = new URL(url);
        return urlParsed.pathname;
    } catch (e) {
        return undefined;
    }
}
function getURLScheme(url) {
    try {
        const urlParsed = new URL(url);
        return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
        return undefined;
    }
}
function getURLPathAndQuery(url) {
    const urlParsed = new URL(url);
    const pathString = urlParsed.pathname;
    if (!pathString) {
        throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
        queryString = queryString.startsWith("?") ? queryString : `?${queryString}`; // Ensure query string start with '?'
    }
    return `${pathString}${queryString}`;
}
function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString) {
        return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value)=>{
        const indexOfEqual = value.indexOf("=");
        const lastIndexOfEqual = value.lastIndexOf("=");
        return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings){
        const splitResults = querySubString.split("=");
        const key = splitResults[0];
        const value = splitResults[1];
        queries[key] = value;
    }
    return queries;
}
function appendToURLQuery(url, queryParts) {
    const urlParsed = new URL(url);
    let query = urlParsed.search;
    if (query) {
        query += "&" + queryParts;
    } else {
        query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
}
function truncatedISO8061Date(date, withMilliseconds = true) {
    // Date.toISOString() will return like "2018-10-29T06:34:36.139Z"
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000" + "Z" : dateString.substring(0, dateString.length - 5) + "Z";
}
function base64encode(content) {
    return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] ? btoa(content) : Buffer.from(content).toString("base64");
}
function base64decode(encodedString) {
    return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
}
function generateBlockID(blockIDPrefix, blockIndex) {
    // To generate a 64 bytes base64 string, source string should be 48
    const maxSourceStringLength = 48;
    // A blob can have a maximum of 100,000 uncommitted blocks at any given time
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
        blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode(res);
}
async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject)=>{
        /* eslint-disable-next-line prefer-const */ let timeout;
        const abortHandler = ()=>{
            if (timeout !== undefined) {
                clearTimeout(timeout);
            }
            reject(abortError);
        };
        const resolveHandler = ()=>{
            if (aborter !== undefined) {
                aborter.removeEventListener("abort", abortHandler);
            }
            resolve();
        };
        timeout = setTimeout(resolveHandler, timeInMs);
        if (aborter !== undefined) {
            aborter.addEventListener("abort", abortHandler);
        }
    });
}
function padStart(currentString, targetLength, padString = " ") {
    // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes
    if (String.prototype.padStart) {
        return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
        return currentString;
    } else {
        targetLength = targetLength - currentString.length;
        if (targetLength > padString.length) {
            padString += padString.repeat(targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + currentString;
    }
}
function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URLConstants"].Parameters.SIGNATURE)) {
        safeURL = setURLParameter(safeURL, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["URLConstants"].Parameters.SIGNATURE, "*****");
    }
    return safeURL;
}
function sanitizeHeaders(originalHeader) {
    const headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$httpHeaders$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHttpHeaders"])();
    for (const [name, value] of originalHeader){
        if (name.toLowerCase() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].AUTHORIZATION.toLowerCase()) {
            headers.set(name, "*****");
        } else if (name.toLowerCase() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_COPY_SOURCE) {
            headers.set(name, sanitizeURL(value));
        } else {
            headers.set(name, value);
        }
    }
    return headers;
}
function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
}
function getAccountNameFromUrl(url) {
    const parsedUrl = new URL(url);
    let accountName;
    try {
        if (parsedUrl.hostname.split(".")[1] === "blob") {
            // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
            accountName = parsedUrl.hostname.split(".")[0];
        } else if (isIpEndpointStyle(parsedUrl)) {
            // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/
            // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/
            // .getPath() -> /devstoreaccount1/
            accountName = parsedUrl.pathname.split("/")[1];
        } else {
            // Custom domain case: "https://customdomain.com/containername/blob".
            accountName = "";
        }
        return accountName;
    } catch (error) {
        throw new Error("Unable to extract accountName with provided information.");
    }
}
function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.
    // Case 2: localhost(:port) or host.docker.internal, use broad regex to match port part.
    // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.
    // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PathStylePorts"].includes(parsedUrl.port);
}
function toBlobTagsString(tags) {
    if (tags === undefined) {
        return undefined;
    }
    const tagPairs = [];
    for(const key in tags){
        if (Object.prototype.hasOwnProperty.call(tags, key)) {
            const value = tags[key];
            tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
        }
    }
    return tagPairs.join("&");
}
function toBlobTags(tags) {
    if (tags === undefined) {
        return undefined;
    }
    const res = {
        blobTagSet: []
    };
    for(const key in tags){
        if (Object.prototype.hasOwnProperty.call(tags, key)) {
            const value = tags[key];
            res.blobTagSet.push({
                key,
                value
            });
        }
    }
    return res;
}
function toTags(tags) {
    if (tags === undefined) {
        return undefined;
    }
    const res = {};
    for (const blobTag of tags.blobTagSet){
        res[blobTag.key] = blobTag.value;
    }
    return res;
}
function toQuerySerialization(textConfiguration) {
    if (textConfiguration === undefined) {
        return undefined;
    }
    switch(textConfiguration.kind){
        case "csv":
            return {
                format: {
                    type: "delimited",
                    delimitedTextConfiguration: {
                        columnSeparator: textConfiguration.columnSeparator || ",",
                        fieldQuote: textConfiguration.fieldQuote || "",
                        recordSeparator: textConfiguration.recordSeparator,
                        escapeChar: textConfiguration.escapeCharacter || "",
                        headersPresent: textConfiguration.hasHeaders || false
                    }
                }
            };
        case "json":
            return {
                format: {
                    type: "json",
                    jsonTextConfiguration: {
                        recordSeparator: textConfiguration.recordSeparator
                    }
                }
            };
        case "arrow":
            return {
                format: {
                    type: "arrow",
                    arrowConfiguration: {
                        schema: textConfiguration.schema
                    }
                }
            };
        case "parquet":
            return {
                format: {
                    type: "parquet"
                }
            };
        default:
            throw Error("Invalid BlobQueryTextConfiguration.");
    }
}
function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord) {
        return undefined;
    }
    if ("policy-id" in objectReplicationRecord) {
        // If the dictionary contains a key with policy id, we are not required to do any parsing since
        // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.
        return undefined;
    }
    const orProperties = [];
    for(const key in objectReplicationRecord){
        const ids = key.split("_");
        const policyPrefix = "or-";
        if (ids[0].startsWith(policyPrefix)) {
            ids[0] = ids[0].substring(policyPrefix.length);
        }
        const rule = {
            ruleId: ids[1],
            replicationStatus: objectReplicationRecord[key]
        };
        const policyIndex = orProperties.findIndex((policy)=>policy.policyId === ids[0]);
        if (policyIndex > -1) {
            orProperties[policyIndex].rules.push(rule);
        } else {
            orProperties.push({
                policyId: ids[0],
                rules: [
                    rule
                ]
            });
        }
    }
    return orProperties;
}
function attachCredential(thing, credential) {
    thing.credential = credential;
    return thing;
}
function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
}
function BlobNameToString(name) {
    if (name.encoded) {
        return decodeURIComponent(name.content);
    } else {
        return name.content;
    }
}
function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return {
        ...internalResponse,
        segment: {
            blobItems: internalResponse.segment.blobItems.map((blobItemInteral)=>{
                const blobItem = {
                    ...blobItemInteral,
                    name: BlobNameToString(blobItemInteral.name)
                };
                return blobItem;
            })
        }
    };
}
function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    return {
        ...internalResponse,
        segment: {
            blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal)=>{
                const blobPrefix = {
                    ...blobPrefixInternal,
                    name: BlobNameToString(blobPrefixInternal.name)
                };
                return blobPrefix;
            }),
            blobItems: internalResponse.segment.blobItems.map((blobItemInteral)=>{
                const blobItem = {
                    ...blobItemInteral,
                    name: BlobNameToString(blobItemInteral.name)
                };
                return blobItem;
            })
        }
    };
}
function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [];
    let clearRange = [];
    if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0;
    let clearRangeIndex = 0;
    while(pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length){
        if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
            yield {
                start: pageRange[pageRangeIndex].start,
                end: pageRange[pageRangeIndex].end,
                isClear: false
            };
            ++pageRangeIndex;
        } else {
            yield {
                start: clearRange[clearRangeIndex].start,
                end: clearRange[clearRangeIndex].end,
                isClear: true
            };
            ++clearRangeIndex;
        }
    }
    for(; pageRangeIndex < pageRange.length; ++pageRangeIndex){
        yield {
            start: pageRange[pageRangeIndex].start,
            end: pageRange[pageRangeIndex].end,
            isClear: false
        };
    }
    for(; clearRangeIndex < clearRange.length; ++clearRangeIndex){
        yield {
            start: clearRange[clearRangeIndex].start,
            end: clearRange[clearRangeIndex].end,
            isClear: true
        };
    }
}
function EscapePath(blobName) {
    const split = blobName.split("/");
    for(let i = 0; i < split.length; i++){
        split[i] = encodeURIComponent(split[i]);
    }
    return split.join("/");
}
function assertResponse(response) {
    if (`_response` in response) {
        return response;
    }
    throw new TypeError(`Unexpected response object ${response}`);
} //# sourceMappingURL=utils.common.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/SharedKeyComparator.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/*
 * We need to imitate .Net culture-aware sorting, which is used in storage service.
 * Below tables contain sort-keys for en-US culture.
 */ __turbopack_context__.s([
    "compareHeader",
    ()=>compareHeader
]);
const table_lv0 = new Uint32Array([
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x71c,
    0x0,
    0x71f,
    0x721,
    0x723,
    0x725,
    0x0,
    0x0,
    0x0,
    0x72d,
    0x803,
    0x0,
    0x0,
    0x733,
    0x0,
    0xd03,
    0xd1a,
    0xd1c,
    0xd1e,
    0xd20,
    0xd22,
    0xd24,
    0xd26,
    0xd28,
    0xd2a,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0xe02,
    0xe09,
    0xe0a,
    0xe1a,
    0xe21,
    0xe23,
    0xe25,
    0xe2c,
    0xe32,
    0xe35,
    0xe36,
    0xe48,
    0xe51,
    0xe70,
    0xe7c,
    0xe7e,
    0xe89,
    0xe8a,
    0xe91,
    0xe99,
    0xe9f,
    0xea2,
    0xea4,
    0xea6,
    0xea7,
    0xea9,
    0x0,
    0x0,
    0x0,
    0x743,
    0x744,
    0x748,
    0xe02,
    0xe09,
    0xe0a,
    0xe1a,
    0xe21,
    0xe23,
    0xe25,
    0xe2c,
    0xe32,
    0xe35,
    0xe36,
    0xe48,
    0xe51,
    0xe70,
    0xe7c,
    0xe7e,
    0xe89,
    0xe8a,
    0xe91,
    0xe99,
    0xe9f,
    0xea2,
    0xea4,
    0xea6,
    0xea7,
    0xea9,
    0x0,
    0x74c,
    0x0,
    0x750,
    0x0
]);
const table_lv2 = new Uint32Array([
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x12,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0
]);
const table_lv4 = new Uint32Array([
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x8012,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x8212,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0
]);
function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs)) return -1;
    return 1;
}
function isLessThan(lhs, rhs) {
    const tables = [
        table_lv0,
        table_lv2,
        table_lv4
    ];
    let curr_level = 0;
    let i = 0;
    let j = 0;
    while(curr_level < tables.length){
        if (curr_level === tables.length - 1 && i !== j) {
            return i > j;
        }
        const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 0x1;
        const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 0x1;
        if (weight1 === 0x1 && weight2 === 0x1) {
            i = 0;
            j = 0;
            ++curr_level;
        } else if (weight1 === weight2) {
            ++i;
            ++j;
        } else if (weight1 === 0) {
            ++i;
        } else if (weight2 === 0) {
            ++j;
        } else {
            return weight1 < weight2;
        }
    }
    return false;
} //# sourceMappingURL=SharedKeyComparator.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/tracing.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "tracingClient",
    ()=>tracingClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$tracing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-tracing/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$tracing$2f$dist$2f$esm$2f$tracingClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-tracing/dist/esm/tracingClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
;
;
const tracingClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$tracing$2f$dist$2f$esm$2f$tracingClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTracingClient"])({
    packageName: "@azure/storage-blob",
    packageVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SDK_VERSION"],
    namespace: "Microsoft.Storage"
}); //# sourceMappingURL=tracing.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/RetriableReadableStream.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "RetriableReadableStream",
    ()=>RetriableReadableStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/AbortError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
;
;
class RetriableReadableStream extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"] {
    start;
    offset;
    end;
    getter;
    source;
    retries = 0;
    maxRetryRequests;
    onProgress;
    options;
    /**
     * Creates an instance of RetriableReadableStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param getter - A method calling downloading request returning
     *                                      a new ReadableStream from specified offset
     * @param offset - Offset position in original data source to read
     * @param count - How much data in original data source to read
     * @param options -
     */ constructor(source, getter, offset, count, options = {}){
        super({
            highWaterMark: options.highWaterMark
        });
        this.getter = getter;
        this.source = source;
        this.start = offset;
        this.offset = offset;
        this.end = offset + count - 1;
        this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
        this.onProgress = options.onProgress;
        this.options = options;
        this.setSourceEventHandlers();
    }
    _read() {
        this.source.resume();
    }
    setSourceEventHandlers() {
        this.source.on("data", this.sourceDataHandler);
        this.source.on("end", this.sourceErrorOrEndHandler);
        this.source.on("error", this.sourceErrorOrEndHandler);
        // needed for Node14
        this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
        this.source.removeListener("data", this.sourceDataHandler);
        this.source.removeListener("end", this.sourceErrorOrEndHandler);
        this.source.removeListener("error", this.sourceErrorOrEndHandler);
        this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    sourceDataHandler = (data)=>{
        if (this.options.doInjectErrorOnce) {
            this.options.doInjectErrorOnce = undefined;
            this.source.pause();
            this.sourceErrorOrEndHandler();
            this.source.destroy();
            return;
        }
        // console.log(
        //   `Offset: ${this.offset}, Received ${data.length} from internal stream`
        // );
        this.offset += data.length;
        if (this.onProgress) {
            this.onProgress({
                loadedBytes: this.offset - this.start
            });
        }
        if (!this.push(data)) {
            this.source.pause();
        }
    };
    sourceAbortedHandler = ()=>{
        const abortError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbortError"]("The operation was aborted.");
        this.destroy(abortError);
    };
    sourceErrorOrEndHandler = (err)=>{
        if (err && err.name === "AbortError") {
            this.destroy(err);
            return;
        }
        // console.log(
        //   `Source stream emits end or error, offset: ${
        //     this.offset
        //   }, dest end : ${this.end}`
        // );
        this.removeSourceEventHandlers();
        if (this.offset - 1 === this.end) {
            this.push(null);
        } else if (this.offset <= this.end) {
            // console.log(
            //   `retries: ${this.retries}, max retries: ${this.maxRetries}`
            // );
            if (this.retries < this.maxRetryRequests) {
                this.retries += 1;
                this.getter(this.offset).then((newSource)=>{
                    this.source = newSource;
                    this.setSourceEventHandlers();
                    return;
                }).catch((error)=>{
                    this.destroy(error);
                });
            } else {
                this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
            }
        } else {
            this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
        }
    };
    _destroy(error, callback) {
        // remove listener from source and release source
        this.removeSourceEventHandlers();
        this.source.destroy();
        callback(error === null ? undefined : error);
    }
} //# sourceMappingURL=RetriableReadableStream.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/BlobQuickQueryStream.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobQuickQueryStream",
    ()=>BlobQuickQueryStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReadableFromStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReadableFromStream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReader.js [app-route] (ecmascript)");
;
;
class BlobQuickQueryStream extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"] {
    source;
    avroReader;
    avroIter;
    avroPaused = true;
    onProgress;
    onError;
    /**
     * Creates an instance of BlobQuickQueryStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param options -
     */ constructor(source, options = {}){
        super();
        this.source = source;
        this.onProgress = options.onProgress;
        this.onError = options.onError;
        this.avroReader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroReader"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReadableFromStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroReadableFromStream"](this.source));
        this.avroIter = this.avroReader.parseObjects({
            abortSignal: options.abortSignal
        });
    }
    _read() {
        if (this.avroPaused) {
            this.readInternal().catch((err)=>{
                this.emit("error", err);
            });
        }
    }
    async readInternal() {
        this.avroPaused = false;
        let avroNext;
        do {
            avroNext = await this.avroIter.next();
            if (avroNext.done) {
                break;
            }
            const obj = avroNext.value;
            const schema = obj.$schema;
            if (typeof schema !== "string") {
                throw Error("Missing schema in avro record.");
            }
            switch(schema){
                case "com.microsoft.azure.storage.queryBlobContents.resultData":
                    {
                        const data = obj.data;
                        if (data instanceof Uint8Array === false) {
                            throw Error("Invalid data in avro result record.");
                        }
                        if (!this.push(Buffer.from(data))) {
                            this.avroPaused = true;
                        }
                    }
                    break;
                case "com.microsoft.azure.storage.queryBlobContents.progress":
                    {
                        const bytesScanned = obj.bytesScanned;
                        if (typeof bytesScanned !== "number") {
                            throw Error("Invalid bytesScanned in avro progress record.");
                        }
                        if (this.onProgress) {
                            this.onProgress({
                                loadedBytes: bytesScanned
                            });
                        }
                    }
                    break;
                case "com.microsoft.azure.storage.queryBlobContents.end":
                    if (this.onProgress) {
                        const totalBytes = obj.totalBytes;
                        if (typeof totalBytes !== "number") {
                            throw Error("Invalid totalBytes in avro end record.");
                        }
                        this.onProgress({
                            loadedBytes: totalBytes
                        });
                    }
                    this.push(null);
                    break;
                case "com.microsoft.azure.storage.queryBlobContents.error":
                    if (this.onError) {
                        const fatal = obj.fatal;
                        if (typeof fatal !== "boolean") {
                            throw Error("Invalid fatal in avro error record.");
                        }
                        const name = obj.name;
                        if (typeof name !== "string") {
                            throw Error("Invalid name in avro error record.");
                        }
                        const description = obj.description;
                        if (typeof description !== "string") {
                            throw Error("Invalid description in avro error record.");
                        }
                        const position = obj.position;
                        if (typeof position !== "number") {
                            throw Error("Invalid position in avro error record.");
                        }
                        this.onError({
                            position,
                            name,
                            isFatal: fatal,
                            description
                        });
                    }
                    break;
                default:
                    throw Error(`Unknown schema ${schema} in avro progress record.`);
            }
        }while (!avroNext.done && !this.avroPaused)
    }
} //# sourceMappingURL=BlobQuickQueryStream.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/Batch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// In browser, during webpack or browserify bundling, this module will be replaced by 'events'
// https://github.com/Gozala/events
__turbopack_context__.s([
    "Batch",
    ()=>Batch
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$events__$5b$external$5d$__$28$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/events [external] (events, cjs)");
;
/**
 * States for Batch.
 */ var BatchStates;
(function(BatchStates) {
    BatchStates[BatchStates["Good"] = 0] = "Good";
    BatchStates[BatchStates["Error"] = 1] = "Error";
})(BatchStates || (BatchStates = {}));
class Batch {
    /**
     * Concurrency. Must be lager than 0.
     */ concurrency;
    /**
     * Number of active operations under execution.
     */ actives = 0;
    /**
     * Number of completed operations under execution.
     */ completed = 0;
    /**
     * Offset of next operation to be executed.
     */ offset = 0;
    /**
     * Operation array to be executed.
     */ operations = [];
    /**
     * States of Batch. When an error happens, state will turn into error.
     * Batch will stop execute left operations.
     */ state = BatchStates.Good;
    /**
     * A private emitter used to pass events inside this class.
     */ emitter;
    /**
     * Creates an instance of Batch.
     * @param concurrency -
     */ constructor(concurrency = 5){
        if (concurrency < 1) {
            throw new RangeError("concurrency must be larger than 0");
        }
        this.concurrency = concurrency;
        this.emitter = new __TURBOPACK__imported__module__$5b$externals$5d2f$events__$5b$external$5d$__$28$events$2c$__cjs$29$__["EventEmitter"]();
    }
    /**
     * Add a operation into queue.
     *
     * @param operation -
     */ addOperation(operation) {
        this.operations.push(async ()=>{
            try {
                this.actives++;
                await operation();
                this.actives--;
                this.completed++;
                this.parallelExecute();
            } catch (error) {
                this.emitter.emit("error", error);
            }
        });
    }
    /**
     * Start execute operations in the queue.
     *
     */ async do() {
        if (this.operations.length === 0) {
            return Promise.resolve();
        }
        this.parallelExecute();
        return new Promise((resolve, reject)=>{
            this.emitter.on("finish", resolve);
            this.emitter.on("error", (error)=>{
                this.state = BatchStates.Error;
                reject(error);
            });
        });
    }
    /**
     * Get next operation to be executed. Return null when reaching ends.
     *
     */ nextOperation() {
        if (this.offset < this.operations.length) {
            return this.operations[this.offset++];
        }
        return null;
    }
    /**
     * Start execute operations. One one the most important difference between
     * this method with do() is that do() wraps as an sync method.
     *
     */ parallelExecute() {
        if (this.state === BatchStates.Error) {
            return;
        }
        if (this.completed >= this.operations.length) {
            this.emitter.emit("finish");
            return;
        }
        while(this.actives < this.concurrency){
            const operation = this.nextOperation();
            if (operation) {
                operation();
            } else {
                return;
            }
        }
    }
} //# sourceMappingURL=Batch.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "fsCreateReadStream",
    ()=>fsCreateReadStream,
    "fsStat",
    ()=>fsStat,
    "readStreamToLocalFile",
    ()=>readStreamToLocalFile,
    "streamToBuffer",
    ()=>streamToBuffer,
    "streamToBuffer2",
    ()=>streamToBuffer2,
    "streamToBuffer3",
    ()=>streamToBuffer3
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
;
;
;
async function streamToBuffer(stream, buffer, offset, end, encoding) {
    let pos = 0; // Position in stream
    const count = end - offset; // Total amount of data needed in stream
    return new Promise((resolve, reject)=>{
        const timeout = setTimeout(()=>reject(new Error(`The operation cannot be completed in timeout.`)), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["REQUEST_TIMEOUT"]);
        stream.on("readable", ()=>{
            if (pos >= count) {
                clearTimeout(timeout);
                resolve();
                return;
            }
            let chunk = stream.read();
            if (!chunk) {
                return;
            }
            if (typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding);
            }
            // How much data needed in this chunk
            const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
            buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
            pos += chunkLength;
        });
        stream.on("end", ()=>{
            clearTimeout(timeout);
            if (pos < count) {
                reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
            }
            resolve();
        });
        stream.on("error", (msg)=>{
            clearTimeout(timeout);
            reject(msg);
        });
    });
}
async function streamToBuffer2(stream, buffer, encoding) {
    let pos = 0; // Position in stream
    const bufferSize = buffer.length;
    return new Promise((resolve, reject)=>{
        stream.on("readable", ()=>{
            let chunk = stream.read();
            if (!chunk) {
                return;
            }
            if (typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding);
            }
            if (pos + chunk.length > bufferSize) {
                reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
                return;
            }
            buffer.fill(chunk, pos, pos + chunk.length);
            pos += chunk.length;
        });
        stream.on("end", ()=>{
            resolve(pos);
        });
        stream.on("error", reject);
    });
}
async function streamToBuffer3(readableStream, encoding) {
    return new Promise((resolve, reject)=>{
        const chunks = [];
        readableStream.on("data", (data)=>{
            chunks.push(typeof data === "string" ? Buffer.from(data, encoding) : data);
        });
        readableStream.on("end", ()=>{
            resolve(Buffer.concat(chunks));
        });
        readableStream.on("error", reject);
    });
}
async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve, reject)=>{
        const ws = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].createWriteStream(file);
        rs.on("error", (err)=>{
            reject(err);
        });
        ws.on("error", (err)=>{
            reject(err);
        });
        ws.on("close", resolve);
        rs.pipe(ws);
    });
}
const fsStat = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["default"].promisify(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].stat);
const fsCreateReadStream = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].createReadStream; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/utils/Mutex.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "Mutex",
    ()=>Mutex
]);
var MutexLockStatus;
(function(MutexLockStatus) {
    MutexLockStatus[MutexLockStatus["LOCKED"] = 0] = "LOCKED";
    MutexLockStatus[MutexLockStatus["UNLOCKED"] = 1] = "UNLOCKED";
})(MutexLockStatus || (MutexLockStatus = {}));
class Mutex {
    /**
     * Lock for a specific key. If the lock has been acquired by another customer, then
     * will wait until getting the lock.
     *
     * @param key - lock key
     */ static async lock(key) {
        return new Promise((resolve)=>{
            if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {
                this.keys[key] = MutexLockStatus.LOCKED;
                resolve();
            } else {
                this.onUnlockEvent(key, ()=>{
                    this.keys[key] = MutexLockStatus.LOCKED;
                    resolve();
                });
            }
        });
    }
    /**
     * Unlock a key.
     *
     * @param key -
     */ static async unlock(key) {
        return new Promise((resolve)=>{
            if (this.keys[key] === MutexLockStatus.LOCKED) {
                this.emitUnlockEvent(key);
            }
            delete this.keys[key];
            resolve();
        });
    }
    static keys = {};
    static listeners = {};
    static onUnlockEvent(key, handler) {
        if (this.listeners[key] === undefined) {
            this.listeners[key] = [
                handler
            ];
        } else {
            this.listeners[key].push(handler);
        }
    }
    static emitUnlockEvent(key) {
        if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {
            const handler = this.listeners[key].shift();
            setImmediate(()=>{
                handler.call(this);
            });
        }
    }
} //# sourceMappingURL=Mutex.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/StorageRetryPolicyFactory.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageRetryPolicyFactory",
    ()=>StorageRetryPolicyFactory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyType$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicyType.js [app-route] (ecmascript)");
;
;
;
class StorageRetryPolicyFactory {
    retryOptions;
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param retryOptions -
     */ constructor(retryOptions){
        this.retryOptions = retryOptions;
    }
    /**
     * Creates a StorageRetryPolicy object.
     *
     * @param nextPolicy -
     * @param options -
     */ create(nextPolicy, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageRetryPolicy"](nextPolicy, options, this.retryOptions);
    }
} //# sourceMappingURL=StorageRetryPolicyFactory.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/credentials/Credential.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 */ __turbopack_context__.s([
    "Credential",
    ()=>Credential
]);
class Credential {
    /**
     * Creates a RequestPolicy object.
     *
     * @param _nextPolicy -
     * @param _options -
     */ create(_nextPolicy, _options) {
        throw new Error("Method should be implemented in children classes.");
    }
} //# sourceMappingURL=Credential.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageSharedKeyCredential",
    ()=>StorageSharedKeyCredential
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageSharedKeyCredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$Credential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/Credential.js [app-route] (ecmascript)");
;
;
;
class StorageSharedKeyCredential extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$Credential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Credential"] {
    /**
     * Azure Storage account name; readonly.
     */ accountName;
    /**
     * Azure Storage account key; readonly.
     */ accountKey;
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param accountName -
     * @param accountKey -
     */ constructor(accountName, accountKey){
        super();
        this.accountName = accountName;
        this.accountKey = Buffer.from(accountKey, "base64");
    }
    /**
     * Creates a StorageSharedKeyCredentialPolicy object.
     *
     * @param nextPolicy -
     * @param options -
     */ create(nextPolicy, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredentialPolicy"](nextPolicy, options, this);
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */ computeHMACSHA256(stringToSign) {
        return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHmac"])("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
} //# sourceMappingURL=StorageSharedKeyCredential.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "AnonymousCredential",
    ()=>AnonymousCredential
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$AnonymousCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/AnonymousCredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$Credential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/Credential.js [app-route] (ecmascript)");
;
;
class AnonymousCredential extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$Credential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Credential"] {
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */ create(nextPolicy, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$AnonymousCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredentialPolicy"](nextPolicy, options);
    }
} //# sourceMappingURL=AnonymousCredential.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/credentials/UserDelegationKeyCredential.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "UserDelegationKeyCredential",
    ()=>UserDelegationKeyCredential
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
class UserDelegationKeyCredential {
    /**
     * Azure Storage account name; readonly.
     */ accountName;
    /**
     * Azure Storage user delegation key; readonly.
     */ userDelegationKey;
    /**
     * Key value in Buffer type.
     */ key;
    /**
     * Creates an instance of UserDelegationKeyCredential.
     * @param accountName -
     * @param userDelegationKey -
     */ constructor(accountName, userDelegationKey){
        this.accountName = accountName;
        this.userDelegationKey = userDelegationKey;
        this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */ computeHMACSHA256(stringToSign) {
        // console.log(`stringToSign: ${JSON.stringify(stringToSign)}`);
        return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHmac"])("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
} //# sourceMappingURL=UserDelegationKeyCredential.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/StorageBrowserPolicyFactory.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageBrowserPolicyFactory",
    ()=>StorageBrowserPolicyFactory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageBrowserPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageBrowserPolicy.js [app-route] (ecmascript)");
;
;
class StorageBrowserPolicyFactory {
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param nextPolicy -
     * @param options -
     */ create(nextPolicy, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageBrowserPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageBrowserPolicy"](nextPolicy, options);
    }
} //# sourceMappingURL=StorageBrowserPolicyFactory.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "Pipeline",
    ()=>Pipeline,
    "getCoreClientOptions",
    ()=>getCoreClientOptions,
    "getCredentialFromPipeline",
    ()=>getCredentialFromPipeline,
    "isPipelineLike",
    ()=>isPipelineLike,
    "newPipeline",
    ()=>newPipeline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$httpClientAdapter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/httpClientAdapter.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$policies$2f$requestPolicyFactoryPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/policies/requestPolicyFactoryPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$bearerTokenAuthenticationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/policies/bearerTokenAuthenticationPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$decompressResponsePolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/policies/decompressResponsePolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$authorizeRequestOnTenantChallenge$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/authorizeRequestOnTenantChallenge.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/pipeline.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-xml/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$xml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-xml/dist/esm/xml.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/tokenCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/log.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageRetryPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageRetryPolicyFactory.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-common/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$common$2f$dist$2f$esm$2f$cache$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-common/dist/esm/cache.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$common$2f$dist$2f$esm$2f$policies$2f$StorageRequestFailureDetailsParserPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-common/dist/esm/policies/StorageRequestFailureDetailsParserPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageBrowserPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageBrowserPolicyV2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageRetryPolicyV2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageSharedKeyCredentialPolicyV2.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageBrowserPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageBrowserPolicyFactory.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageCorrectContentLengthPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageCorrectContentLengthPolicy.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function isPipelineLike(pipeline) {
    if (!pipeline || typeof pipeline !== "object") {
        return false;
    }
    const castPipeline = pipeline;
    return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
}
class Pipeline {
    /**
     * A list of chained request policy factories.
     */ factories;
    /**
     * Configures pipeline logger and HTTP client.
     */ options;
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param factories -
     * @param options -
     */ constructor(factories, options = {}){
        this.factories = factories;
        this.options = options;
    }
    /**
     * Transfer Pipeline object to ServiceClientOptions object which is required by
     * ServiceClient constructor.
     *
     * @returns The ServiceClientOptions object from this Pipeline.
     */ toServiceClientOptions() {
        return {
            httpClient: this.options.httpClient,
            requestPolicyFactories: this.factories
        };
    }
}
function newPipeline(credential, pipelineOptions = {}) {
    if (!credential) {
        credential = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"]();
    }
    const pipeline = new Pipeline([], pipelineOptions);
    pipeline._credential = credential;
    return pipeline;
}
function processDownlevelPipeline(pipeline) {
    const knownFactoryFunctions = [
        isAnonymousCredential,
        isStorageSharedKeyCredential,
        isCoreHttpBearerTokenFactory,
        isStorageBrowserPolicyFactory,
        isStorageRetryPolicyFactory,
        isStorageTelemetryPolicyFactory,
        isCoreHttpPolicyFactory
    ];
    if (pipeline.factories.length) {
        const novelFactories = pipeline.factories.filter((factory)=>{
            return !knownFactoryFunctions.some((knownFactory)=>knownFactory(factory));
        });
        if (novelFactories.length) {
            const hasInjector = novelFactories.some((factory)=>isInjectorPolicyFactory(factory));
            // if there are any left over, wrap in a requestPolicyFactoryPolicy
            return {
                wrappedPolicies: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$policies$2f$requestPolicyFactoryPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRequestPolicyFactoryPolicy"])(novelFactories),
                afterRetry: hasInjector
            };
        }
    }
    return undefined;
}
function getCoreClientOptions(pipeline) {
    const { httpClient: v1Client, ...restOptions } = pipeline.options;
    let httpClient = pipeline._coreHttpClient;
    if (!httpClient) {
        httpClient = v1Client ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$httpClientAdapter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["convertHttpClient"])(v1Client) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$common$2f$dist$2f$esm$2f$cache$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCachedDefaultHttpClient"])();
        pipeline._coreHttpClient = httpClient;
    }
    let corePipeline = pipeline._corePipeline;
    if (!corePipeline) {
        const packageDetails = `azsdk-js-azure-storage-blob/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SDK_VERSION"]}`;
        const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        corePipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClientPipeline"])({
            ...restOptions,
            loggingOptions: {
                additionalAllowedHeaderNames: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageBlobLoggingAllowedHeaderNames"],
                additionalAllowedQueryParameters: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageBlobLoggingAllowedQueryParameters"],
                logger: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].info
            },
            userAgentOptions: {
                userAgentPrefix
            },
            serializationOptions: {
                stringifyXML: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$xml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringifyXML"],
                serializerOptions: {
                    xml: {
                        // Use customized XML char key of "#" so we can deserialize metadata
                        // with "_" key
                        xmlCharKey: "#"
                    }
                }
            },
            deserializationOptions: {
                parseXML: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$xml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseXML"],
                serializerOptions: {
                    xml: {
                        // Use customized XML char key of "#" so we can deserialize metadata
                        // with "_" key
                        xmlCharKey: "#"
                    }
                }
            }
        });
        corePipeline.removePolicy({
            phase: "Retry"
        });
        corePipeline.removePolicy({
            name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$decompressResponsePolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decompressResponsePolicyName"]
        });
        corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageCorrectContentLengthPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storageCorrectContentLengthPolicy"])());
        corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageRetryPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storageRetryPolicy"])(restOptions.retryOptions), {
            phase: "Retry"
        });
        corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$common$2f$dist$2f$esm$2f$policies$2f$StorageRequestFailureDetailsParserPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storageRequestFailureDetailsParserPolicy"])());
        corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageBrowserPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storageBrowserPolicy"])());
        const downlevelResults = processDownlevelPipeline(pipeline);
        if (downlevelResults) {
            corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? {
                afterPhase: "Retry"
            } : undefined);
        }
        const credential = getCredentialFromPipeline(pipeline);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credential)) {
            corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$bearerTokenAuthenticationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bearerTokenAuthenticationPolicy"])({
                credential,
                scopes: restOptions.audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageOAuthScopes"],
                challengeCallbacks: {
                    authorizeRequestOnChallenge: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$authorizeRequestOnTenantChallenge$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authorizeRequestOnTenantChallenge"]
                }
            }), {
                phase: "Sign"
            });
        } else if (credential instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"]) {
            corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storageSharedKeyCredentialPolicy"])({
                accountName: credential.accountName,
                accountKey: credential.accountKey
            }), {
                phase: "Sign"
            });
        }
        pipeline._corePipeline = corePipeline;
    }
    return {
        ...restOptions,
        allowInsecureConnection: true,
        httpClient,
        pipeline: corePipeline
    };
}
function getCredentialFromPipeline(pipeline) {
    // see if we squirreled one away on the type itself
    if (pipeline._credential) {
        return pipeline._credential;
    }
    // if it came from another package, loop over the factories and look for one like before
    let credential = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"]();
    for (const factory of pipeline.factories){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(factory.credential)) {
            // Only works if the factory has been attached a "credential" property.
            // We do that in newPipeline() when using TokenCredential.
            credential = factory.credential;
        } else if (isStorageSharedKeyCredential(factory)) {
            return factory;
        }
    }
    return credential;
}
function isStorageSharedKeyCredential(factory) {
    if (factory instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"]) {
        return true;
    }
    return factory.constructor.name === "StorageSharedKeyCredential";
}
function isAnonymousCredential(factory) {
    if (factory instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"]) {
        return true;
    }
    return factory.constructor.name === "AnonymousCredential";
}
function isCoreHttpBearerTokenFactory(factory) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(factory.credential);
}
function isStorageBrowserPolicyFactory(factory) {
    if (factory instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageBrowserPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["StorageBrowserPolicyFactory"]) {
        return true;
    }
    return factory.constructor.name === "StorageBrowserPolicyFactory";
}
function isStorageRetryPolicyFactory(factory) {
    if (factory instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageRetryPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["StorageRetryPolicyFactory"]) {
        return true;
    }
    return factory.constructor.name === "StorageRetryPolicyFactory";
}
function isStorageTelemetryPolicyFactory(factory) {
    return factory.constructor.name === "TelemetryPolicyFactory";
}
function isInjectorPolicyFactory(factory) {
    return factory.constructor.name === "InjectorPolicyFactory";
}
function isCoreHttpPolicyFactory(factory) {
    const knownPolicies = [
        "GenerateClientRequestIdPolicy",
        "TracingPolicy",
        "LogPolicy",
        "ProxyPolicy",
        "DisableResponseDecompressionPolicy",
        "KeepAlivePolicy",
        "DeserializationPolicy"
    ];
    const mockHttpClient = {
        sendRequest: async (request)=>{
            return {
                request,
                headers: request.headers.clone(),
                status: 500
            };
        }
    };
    const mockRequestPolicyOptions = {
        log (_logLevel, _message) {
        /* do nothing */ },
        shouldLog (_logLevel) {
            return false;
        }
    };
    const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
    const policyName = policyInstance.constructor.name;
    // bundlers sometimes add a custom suffix to the class name to make it unique
    return knownPolicies.some((knownPolicyName)=>{
        return policyName.startsWith(knownPolicyName);
    });
} //# sourceMappingURL=Pipeline.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/StorageContextClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageContextClient",
    ()=>StorageContextClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$generated$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/generated/src/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$generated$2f$src$2f$storageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/generated/src/storageClient.js [app-route] (ecmascript)");
;
class StorageContextClient extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$generated$2f$src$2f$storageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageClient"] {
    async sendOperationRequest(operationArguments, operationSpec) {
        const operationSpecToSend = {
            ...operationSpec
        };
        if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
            operationSpecToSend.path = "";
        }
        return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
} //# sourceMappingURL=StorageContextClient.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/StorageClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "StorageClient",
    ()=>StorageClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageContextClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageContextClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
class StorageClient {
    /**
     * Encoded URL string value.
     */ url;
    accountName;
    /**
     * Request policy pipeline.
     *
     * @internal
     */ pipeline;
    /**
     * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
     */ credential;
    /**
     * StorageClient is a reference to protocol layer operations entry, which is
     * generated by AutoRest generator.
     */ storageClientContext;
    /**
     */ isHttps;
    /**
     * Creates an instance of StorageClient.
     * @param url - url to resource
     * @param pipeline - request policy pipeline.
     */ constructor(url, pipeline){
        // URL should be encoded and only once, protocol layer shouldn't encode URL again
        this.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["escapeURLPath"])(url);
        this.accountName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAccountNameFromUrl"])(url);
        this.pipeline = pipeline;
        this.storageClientContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageContextClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageContextClient"](this.url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getCoreClientOptions"])(pipeline));
        this.isHttps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["iEqual"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLScheme"])(this.url) || "", "https");
        this.credential = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getCredentialFromPipeline"])(pipeline);
        // Override protocol layer's default content-type
        const storageClientContext = this.storageClientContext;
        storageClientContext.requestContentType = undefined;
    }
} //# sourceMappingURL=StorageClient.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/BlobSASPermissions.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a blob. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link BlobSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */ __turbopack_context__.s([
    "BlobSASPermissions",
    ()=>BlobSASPermissions
]);
class BlobSASPermissions {
    /**
     * Creates a {@link BlobSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */ static parse(permissions) {
        const blobSASPermissions = new BlobSASPermissions();
        for (const char of permissions){
            switch(char){
                case "r":
                    blobSASPermissions.read = true;
                    break;
                case "a":
                    blobSASPermissions.add = true;
                    break;
                case "c":
                    blobSASPermissions.create = true;
                    break;
                case "w":
                    blobSASPermissions.write = true;
                    break;
                case "d":
                    blobSASPermissions.delete = true;
                    break;
                case "x":
                    blobSASPermissions.deleteVersion = true;
                    break;
                case "t":
                    blobSASPermissions.tag = true;
                    break;
                case "m":
                    blobSASPermissions.move = true;
                    break;
                case "e":
                    blobSASPermissions.execute = true;
                    break;
                case "i":
                    blobSASPermissions.setImmutabilityPolicy = true;
                    break;
                case "y":
                    blobSASPermissions.permanentDelete = true;
                    break;
                default:
                    throw new RangeError(`Invalid permission: ${char}`);
            }
        }
        return blobSASPermissions;
    }
    /**
     * Creates a {@link BlobSASPermissions} from a raw object which contains same keys as it
     * and boolean values for them.
     *
     * @param permissionLike -
     */ static from(permissionLike) {
        const blobSASPermissions = new BlobSASPermissions();
        if (permissionLike.read) {
            blobSASPermissions.read = true;
        }
        if (permissionLike.add) {
            blobSASPermissions.add = true;
        }
        if (permissionLike.create) {
            blobSASPermissions.create = true;
        }
        if (permissionLike.write) {
            blobSASPermissions.write = true;
        }
        if (permissionLike.delete) {
            blobSASPermissions.delete = true;
        }
        if (permissionLike.deleteVersion) {
            blobSASPermissions.deleteVersion = true;
        }
        if (permissionLike.tag) {
            blobSASPermissions.tag = true;
        }
        if (permissionLike.move) {
            blobSASPermissions.move = true;
        }
        if (permissionLike.execute) {
            blobSASPermissions.execute = true;
        }
        if (permissionLike.setImmutabilityPolicy) {
            blobSASPermissions.setImmutabilityPolicy = true;
        }
        if (permissionLike.permanentDelete) {
            blobSASPermissions.permanentDelete = true;
        }
        return blobSASPermissions;
    }
    /**
     * Specifies Read access granted.
     */ read = false;
    /**
     * Specifies Add access granted.
     */ add = false;
    /**
     * Specifies Create access granted.
     */ create = false;
    /**
     * Specifies Write access granted.
     */ write = false;
    /**
     * Specifies Delete access granted.
     */ delete = false;
    /**
     * Specifies Delete version access granted.
     */ deleteVersion = false;
    /**
     * Specfies Tag access granted.
     */ tag = false;
    /**
     * Specifies Move access granted.
     */ move = false;
    /**
     * Specifies Execute access granted.
     */ execute = false;
    /**
     * Specifies SetImmutabilityPolicy access granted.
     */ setImmutabilityPolicy = false;
    /**
     * Specifies that Permanent Delete is permitted.
     */ permanentDelete = false;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns A string which represents the BlobSASPermissions
     */ toString() {
        const permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.deleteVersion) {
            permissions.push("x");
        }
        if (this.tag) {
            permissions.push("t");
        }
        if (this.move) {
            permissions.push("m");
        }
        if (this.execute) {
            permissions.push("e");
        }
        if (this.setImmutabilityPolicy) {
            permissions.push("i");
        }
        if (this.permanentDelete) {
            permissions.push("y");
        }
        return permissions.join("");
    }
} //# sourceMappingURL=BlobSASPermissions.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/ContainerSASPermissions.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a container.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link BlobSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */ __turbopack_context__.s([
    "ContainerSASPermissions",
    ()=>ContainerSASPermissions
]);
class ContainerSASPermissions {
    /**
     * Creates an {@link ContainerSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */ static parse(permissions) {
        const containerSASPermissions = new ContainerSASPermissions();
        for (const char of permissions){
            switch(char){
                case "r":
                    containerSASPermissions.read = true;
                    break;
                case "a":
                    containerSASPermissions.add = true;
                    break;
                case "c":
                    containerSASPermissions.create = true;
                    break;
                case "w":
                    containerSASPermissions.write = true;
                    break;
                case "d":
                    containerSASPermissions.delete = true;
                    break;
                case "l":
                    containerSASPermissions.list = true;
                    break;
                case "t":
                    containerSASPermissions.tag = true;
                    break;
                case "x":
                    containerSASPermissions.deleteVersion = true;
                    break;
                case "m":
                    containerSASPermissions.move = true;
                    break;
                case "e":
                    containerSASPermissions.execute = true;
                    break;
                case "i":
                    containerSASPermissions.setImmutabilityPolicy = true;
                    break;
                case "y":
                    containerSASPermissions.permanentDelete = true;
                    break;
                case "f":
                    containerSASPermissions.filterByTags = true;
                    break;
                default:
                    throw new RangeError(`Invalid permission ${char}`);
            }
        }
        return containerSASPermissions;
    }
    /**
     * Creates a {@link ContainerSASPermissions} from a raw object which contains same keys as it
     * and boolean values for them.
     *
     * @param permissionLike -
     */ static from(permissionLike) {
        const containerSASPermissions = new ContainerSASPermissions();
        if (permissionLike.read) {
            containerSASPermissions.read = true;
        }
        if (permissionLike.add) {
            containerSASPermissions.add = true;
        }
        if (permissionLike.create) {
            containerSASPermissions.create = true;
        }
        if (permissionLike.write) {
            containerSASPermissions.write = true;
        }
        if (permissionLike.delete) {
            containerSASPermissions.delete = true;
        }
        if (permissionLike.list) {
            containerSASPermissions.list = true;
        }
        if (permissionLike.deleteVersion) {
            containerSASPermissions.deleteVersion = true;
        }
        if (permissionLike.tag) {
            containerSASPermissions.tag = true;
        }
        if (permissionLike.move) {
            containerSASPermissions.move = true;
        }
        if (permissionLike.execute) {
            containerSASPermissions.execute = true;
        }
        if (permissionLike.setImmutabilityPolicy) {
            containerSASPermissions.setImmutabilityPolicy = true;
        }
        if (permissionLike.permanentDelete) {
            containerSASPermissions.permanentDelete = true;
        }
        if (permissionLike.filterByTags) {
            containerSASPermissions.filterByTags = true;
        }
        return containerSASPermissions;
    }
    /**
     * Specifies Read access granted.
     */ read = false;
    /**
     * Specifies Add access granted.
     */ add = false;
    /**
     * Specifies Create access granted.
     */ create = false;
    /**
     * Specifies Write access granted.
     */ write = false;
    /**
     * Specifies Delete access granted.
     */ delete = false;
    /**
     * Specifies Delete version access granted.
     */ deleteVersion = false;
    /**
     * Specifies List access granted.
     */ list = false;
    /**
     * Specfies Tag access granted.
     */ tag = false;
    /**
     * Specifies Move access granted.
     */ move = false;
    /**
     * Specifies Execute access granted.
     */ execute = false;
    /**
     * Specifies SetImmutabilityPolicy access granted.
     */ setImmutabilityPolicy = false;
    /**
     * Specifies that Permanent Delete is permitted.
     */ permanentDelete = false;
    /**
     * Specifies that Filter Blobs by Tags is permitted.
     */ filterByTags = false;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     */ toString() {
        const permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.deleteVersion) {
            permissions.push("x");
        }
        if (this.list) {
            permissions.push("l");
        }
        if (this.tag) {
            permissions.push("t");
        }
        if (this.move) {
            permissions.push("m");
        }
        if (this.execute) {
            permissions.push("e");
        }
        if (this.setImmutabilityPolicy) {
            permissions.push("i");
        }
        if (this.permanentDelete) {
            permissions.push("y");
        }
        if (this.filterByTags) {
            permissions.push("f");
        }
        return permissions.join("");
    }
} //# sourceMappingURL=ContainerSASPermissions.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/SasIPRange.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Generate SasIPRange format string. For example:
 *
 * "8.8.8.8" or "1.1.1.1-255.255.255.255"
 *
 * @param ipRange -
 */ __turbopack_context__.s([
    "ipRangeToString",
    ()=>ipRangeToString
]);
function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
} //# sourceMappingURL=SasIPRange.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/SASQueryParameters.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "SASProtocol",
    ()=>SASProtocol,
    "SASQueryParameters",
    ()=>SASQueryParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/SasIPRange.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
var SASProtocol;
(function(SASProtocol) {
    /**
     * Protocol that allows HTTPS only
     */ SASProtocol["Https"] = "https";
    /**
     * Protocol that allows both HTTPS and HTTP
     */ SASProtocol["HttpsAndHttp"] = "https,http";
})(SASProtocol || (SASProtocol = {}));
class SASQueryParameters {
    /**
     * The storage API version.
     */ version;
    /**
     * Optional. The allowed HTTP protocol(s).
     */ protocol;
    /**
     * Optional. The start time for this SAS token.
     */ startsOn;
    /**
     * Optional only when identifier is provided. The expiry time for this SAS token.
     */ expiresOn;
    /**
     * Optional only when identifier is provided.
     * Please refer to {@link AccountSASPermissions}, {@link BlobSASPermissions}, or {@link ContainerSASPermissions} for
     * more details.
     */ permissions;
    /**
     * Optional. The storage services being accessed (only for Account SAS). Please refer to {@link AccountSASServices}
     * for more details.
     */ services;
    /**
     * Optional. The storage resource types being accessed (only for Account SAS). Please refer to
     * {@link AccountSASResourceTypes} for more details.
     */ resourceTypes;
    /**
     * Optional. The signed identifier (only for {@link BlobSASSignatureValues}).
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/establishing-a-stored-access-policy
     */ identifier;
    /**
     * Optional. Encryption scope to use when sending requests authorized with this SAS URI.
     */ encryptionScope;
    /**
     * Optional. Specifies which resources are accessible via the SAS (only for {@link BlobSASSignatureValues}).
     * @see https://learn.microsoft.com/rest/api/storageservices/create-service-sas#specifying-the-signed-resource-blob-service-only
     */ resource;
    /**
     * The signature for the SAS token.
     */ signature;
    /**
     * Value for cache-control header in Blob/File Service SAS.
     */ cacheControl;
    /**
     * Value for content-disposition header in Blob/File Service SAS.
     */ contentDisposition;
    /**
     * Value for content-encoding header in Blob/File Service SAS.
     */ contentEncoding;
    /**
     * Value for content-length header in Blob/File Service SAS.
     */ contentLanguage;
    /**
     * Value for content-type header in Blob/File Service SAS.
     */ contentType;
    /**
     * Inner value of getter ipRange.
     */ ipRangeInner;
    /**
     * The Azure Active Directory object ID in GUID format.
     * Property of user delegation key.
     */ signedOid;
    /**
     * The Azure Active Directory tenant ID in GUID format.
     * Property of user delegation key.
     */ signedTenantId;
    /**
     * The date-time the key is active.
     * Property of user delegation key.
     */ signedStartsOn;
    /**
     * The date-time the key expires.
     * Property of user delegation key.
     */ signedExpiresOn;
    /**
     * Abbreviation of the Azure Storage service that accepts the user delegation key.
     * Property of user delegation key.
     */ signedService;
    /**
     * The service version that created the user delegation key.
     * Property of user delegation key.
     */ signedVersion;
    /**
     * Authorized AAD Object ID in GUID format. The AAD Object ID of a user authorized by the owner of the User Delegation Key
     * to perform the action granted by the SAS. The Azure Storage service will ensure that the owner of the user delegation key
     * has the required permissions before granting access but no additional permission check for the user specified in
     * this value will be performed. This is only used for User Delegation SAS.
     */ preauthorizedAgentObjectId;
    /**
     * A GUID value that will be logged in the storage diagnostic logs and can be used to correlate SAS generation with storage resource access.
     * This is only used for User Delegation SAS.
     */ correlationId;
    /**
     * Optional. IP range allowed for this SAS.
     *
     * @readonly
     */ get ipRange() {
        if (this.ipRangeInner) {
            return {
                end: this.ipRangeInner.end,
                start: this.ipRangeInner.start
            };
        }
        return undefined;
    }
    constructor(version, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope){
        this.version = version;
        this.signature = signature;
        if (permissionsOrOptions !== undefined && typeof permissionsOrOptions !== "string") {
            // SASQueryParametersOptions
            this.permissions = permissionsOrOptions.permissions;
            this.services = permissionsOrOptions.services;
            this.resourceTypes = permissionsOrOptions.resourceTypes;
            this.protocol = permissionsOrOptions.protocol;
            this.startsOn = permissionsOrOptions.startsOn;
            this.expiresOn = permissionsOrOptions.expiresOn;
            this.ipRangeInner = permissionsOrOptions.ipRange;
            this.identifier = permissionsOrOptions.identifier;
            this.encryptionScope = permissionsOrOptions.encryptionScope;
            this.resource = permissionsOrOptions.resource;
            this.cacheControl = permissionsOrOptions.cacheControl;
            this.contentDisposition = permissionsOrOptions.contentDisposition;
            this.contentEncoding = permissionsOrOptions.contentEncoding;
            this.contentLanguage = permissionsOrOptions.contentLanguage;
            this.contentType = permissionsOrOptions.contentType;
            if (permissionsOrOptions.userDelegationKey) {
                this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
                this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
                this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
                this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
                this.signedService = permissionsOrOptions.userDelegationKey.signedService;
                this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
                this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
                this.correlationId = permissionsOrOptions.correlationId;
            }
        } else {
            this.services = services;
            this.resourceTypes = resourceTypes;
            this.expiresOn = expiresOn;
            this.permissions = permissionsOrOptions;
            this.protocol = protocol;
            this.startsOn = startsOn;
            this.ipRangeInner = ipRange;
            this.encryptionScope = encryptionScope;
            this.identifier = identifier;
            this.resource = resource;
            this.cacheControl = cacheControl;
            this.contentDisposition = contentDisposition;
            this.contentEncoding = contentEncoding;
            this.contentLanguage = contentLanguage;
            this.contentType = contentType;
            if (userDelegationKey) {
                this.signedOid = userDelegationKey.signedObjectId;
                this.signedTenantId = userDelegationKey.signedTenantId;
                this.signedStartsOn = userDelegationKey.signedStartsOn;
                this.signedExpiresOn = userDelegationKey.signedExpiresOn;
                this.signedService = userDelegationKey.signedService;
                this.signedVersion = userDelegationKey.signedVersion;
                this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
                this.correlationId = correlationId;
            }
        }
    }
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     */ toString() {
        const params = [
            "sv",
            "ss",
            "srt",
            "spr",
            "st",
            "se",
            "sip",
            "si",
            "ses",
            "skoid",
            "sktid",
            "skt",
            "ske",
            "sks",
            "skv",
            "sr",
            "sp",
            "sig",
            "rscc",
            "rscd",
            "rsce",
            "rscl",
            "rsct",
            "saoid",
            "scid"
        ];
        const queries = [];
        for (const param of params){
            switch(param){
                case "sv":
                    this.tryAppendQueryParameter(queries, param, this.version);
                    break;
                case "ss":
                    this.tryAppendQueryParameter(queries, param, this.services);
                    break;
                case "srt":
                    this.tryAppendQueryParameter(queries, param, this.resourceTypes);
                    break;
                case "spr":
                    this.tryAppendQueryParameter(queries, param, this.protocol);
                    break;
                case "st":
                    this.tryAppendQueryParameter(queries, param, this.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(this.startsOn, false) : undefined);
                    break;
                case "se":
                    this.tryAppendQueryParameter(queries, param, this.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(this.expiresOn, false) : undefined);
                    break;
                case "sip":
                    this.tryAppendQueryParameter(queries, param, this.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(this.ipRange) : undefined);
                    break;
                case "si":
                    this.tryAppendQueryParameter(queries, param, this.identifier);
                    break;
                case "ses":
                    this.tryAppendQueryParameter(queries, param, this.encryptionScope);
                    break;
                case "skoid":
                    this.tryAppendQueryParameter(queries, param, this.signedOid);
                    break;
                case "sktid":
                    this.tryAppendQueryParameter(queries, param, this.signedTenantId);
                    break;
                case "skt":
                    this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(this.signedStartsOn, false) : undefined);
                    break;
                case "ske":
                    this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(this.signedExpiresOn, false) : undefined);
                    break;
                case "sks":
                    this.tryAppendQueryParameter(queries, param, this.signedService);
                    break;
                case "skv":
                    this.tryAppendQueryParameter(queries, param, this.signedVersion);
                    break;
                case "sr":
                    this.tryAppendQueryParameter(queries, param, this.resource);
                    break;
                case "sp":
                    this.tryAppendQueryParameter(queries, param, this.permissions);
                    break;
                case "sig":
                    this.tryAppendQueryParameter(queries, param, this.signature);
                    break;
                case "rscc":
                    this.tryAppendQueryParameter(queries, param, this.cacheControl);
                    break;
                case "rscd":
                    this.tryAppendQueryParameter(queries, param, this.contentDisposition);
                    break;
                case "rsce":
                    this.tryAppendQueryParameter(queries, param, this.contentEncoding);
                    break;
                case "rscl":
                    this.tryAppendQueryParameter(queries, param, this.contentLanguage);
                    break;
                case "rsct":
                    this.tryAppendQueryParameter(queries, param, this.contentType);
                    break;
                case "saoid":
                    this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
                    break;
                case "scid":
                    this.tryAppendQueryParameter(queries, param, this.correlationId);
                    break;
            }
        }
        return queries.join("&");
    }
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @param queries -
     * @param key -
     * @param value -
     */ tryAppendQueryParameter(queries, key, value) {
        if (!value) {
            return;
        }
        key = encodeURIComponent(key);
        value = encodeURIComponent(value);
        if (key.length > 0 && value.length > 0) {
            queries.push(`${key}=${value}`);
        }
    }
} //# sourceMappingURL=SASQueryParameters.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/BlobSASSignatureValues.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "generateBlobSASQueryParameters",
    ()=>generateBlobSASQueryParameters,
    "generateBlobSASQueryParametersInternal",
    ()=>generateBlobSASQueryParametersInternal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/BlobSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/ContainerSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$UserDelegationKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/UserDelegationKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/SasIPRange.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/SASQueryParameters.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
}
function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SERVICE_VERSION"];
    const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"] ? sharedKeyCredentialOrUserDelegationKey : undefined;
    let userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
        userDelegationKeyCredential = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$UserDelegationKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UserDelegationKeyCredential"](accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
        throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    // Version 2020-12-06 adds support for encryptionscope in SAS.
    if (version >= "2020-12-06") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
        } else {
            if (version >= "2025-07-05") {
                return generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential);
            } else {
                return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
            }
        }
    }
    // Version 2019-12-12 adds support for the blob tags permission.
    // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.
    // https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string
    if (version >= "2018-11-09") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
        } else {
            // Version 2020-02-10 delegation SAS signature construction includes preauthorizedAgentObjectId, agentObjectId, correlationId.
            if (version >= "2020-02-10") {
                return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
            } else {
                return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
            }
        }
    }
    if (version >= "2015-04-05") {
        if (sharedKeyCredential !== undefined) {
            return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
        } else {
            throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
        }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param blobSASSignatureValues -
 * @param sharedKeyCredential -
 */ function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    if (blobSASSignatureValues.blobName) {
        resource = "b";
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        blobSASSignatureValues.identifier,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
        blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
        blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
        blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
        blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
        stringToSign: stringToSign
    };
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param blobSASSignatureValues -
 * @param sharedKeyCredential -
 */ function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
            resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
            resource = "bv";
            timestamp = blobSASSignatureValues.versionId;
        }
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        blobSASSignatureValues.identifier,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
        blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
        blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
        blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
        blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
        stringToSign: stringToSign
    };
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param blobSASSignatureValues -
 * @param sharedKeyCredential -
 */ function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
            resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
            resource = "bv";
            timestamp = blobSASSignatureValues.versionId;
        }
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        blobSASSignatureValues.identifier,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.encryptionScope,
        blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
        blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
        blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
        blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
        blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope),
        stringToSign: stringToSign
    };
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn.
 *
 * WARNING: identifier will be ignored, permissions and expiresOn are required.
 *
 * @param blobSASSignatureValues -
 * @param userDelegationKeyCredential -
 */ function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    // Stored access policies are not supported for a user delegation SAS.
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
            resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
            resource = "bv";
            timestamp = blobSASSignatureValues.versionId;
        }
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
        stringToSign: stringToSign
    };
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2020-02-10.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn.
 *
 * WARNING: identifier will be ignored, permissions and expiresOn are required.
 *
 * @param blobSASSignatureValues -
 * @param userDelegationKeyCredential -
 */ function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    // Stored access policies are not supported for a user delegation SAS.
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
            resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
            resource = "bv";
            timestamp = blobSASSignatureValues.versionId;
        }
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.preauthorizedAgentObjectId,
        undefined,
        blobSASSignatureValues.correlationId,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
        stringToSign: stringToSign
    };
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn.
 *
 * WARNING: identifier will be ignored, permissions and expiresOn are required.
 *
 * @param blobSASSignatureValues -
 * @param userDelegationKeyCredential -
 */ function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    // Stored access policies are not supported for a user delegation SAS.
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
            resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
            resource = "bv";
            timestamp = blobSASSignatureValues.versionId;
        }
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.preauthorizedAgentObjectId,
        undefined,
        blobSASSignatureValues.correlationId,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.encryptionScope,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
        stringToSign: stringToSign
    };
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn.
 *
 * WARNING: identifier will be ignored, permissions and expiresOn are required.
 *
 * @param blobSASSignatureValues -
 * @param userDelegationKeyCredential -
 */ function generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    // Stored access policies are not supported for a user delegation SAS.
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
        resource = "b";
        if (blobSASSignatureValues.snapshotTime) {
            resource = "bs";
        } else if (blobSASSignatureValues.versionId) {
            resource = "bv";
            timestamp = blobSASSignatureValues.versionId;
        }
    }
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
        if (blobSASSignatureValues.blobName) {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        } else {
            verifiedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerSASPermissions"].parse(blobSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions ? verifiedPermissions : "",
        blobSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.startsOn, false) : "",
        blobSASSignatureValues.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(blobSASSignatureValues.expiresOn, false) : "",
        getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
        userDelegationKeyCredential.userDelegationKey.signedObjectId,
        userDelegationKeyCredential.userDelegationKey.signedTenantId,
        userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
        userDelegationKeyCredential.userDelegationKey.signedService,
        userDelegationKeyCredential.userDelegationKey.signedVersion,
        blobSASSignatureValues.preauthorizedAgentObjectId,
        undefined,
        blobSASSignatureValues.correlationId,
        undefined,
        undefined,
        blobSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(blobSASSignatureValues.ipRange) : "",
        blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
        blobSASSignatureValues.version,
        resource,
        timestamp,
        blobSASSignatureValues.encryptionScope,
        blobSASSignatureValues.cacheControl,
        blobSASSignatureValues.contentDisposition,
        blobSASSignatureValues.contentEncoding,
        blobSASSignatureValues.contentLanguage,
        blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
        stringToSign: stringToSign
    };
}
function getCanonicalName(accountName, containerName, blobName) {
    // Container: "/blob/account/containerName"
    // Blob:      "/blob/account/containerName/blobName"
    const elements = [
        `/blob/${accountName}/${containerName}`
    ];
    if (blobName) {
        elements.push(`/${blobName}`);
    }
    return elements.join("");
}
function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SERVICE_VERSION"];
    if (blobSASSignatureValues.snapshotTime && version < "2018-11-09") {
        throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {
        throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.versionId && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {
        throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") {
        throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < "2019-12-12") {
        throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    }
    if (version < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
        throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    }
    if (version < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
        throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    }
    if (version < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
        throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    }
    if (blobSASSignatureValues.encryptionScope && version < "2020-12-06") {
        throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    blobSASSignatureValues.version = version;
    return blobSASSignatureValues;
} //# sourceMappingURL=BlobSASSignatureValues.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASPermissions.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */ __turbopack_context__.s([
    "AccountSASPermissions",
    ()=>AccountSASPermissions
]);
class AccountSASPermissions {
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @param permissions -
     */ static parse(permissions) {
        const accountSASPermissions = new AccountSASPermissions();
        for (const c of permissions){
            switch(c){
                case "r":
                    accountSASPermissions.read = true;
                    break;
                case "w":
                    accountSASPermissions.write = true;
                    break;
                case "d":
                    accountSASPermissions.delete = true;
                    break;
                case "x":
                    accountSASPermissions.deleteVersion = true;
                    break;
                case "l":
                    accountSASPermissions.list = true;
                    break;
                case "a":
                    accountSASPermissions.add = true;
                    break;
                case "c":
                    accountSASPermissions.create = true;
                    break;
                case "u":
                    accountSASPermissions.update = true;
                    break;
                case "p":
                    accountSASPermissions.process = true;
                    break;
                case "t":
                    accountSASPermissions.tag = true;
                    break;
                case "f":
                    accountSASPermissions.filter = true;
                    break;
                case "i":
                    accountSASPermissions.setImmutabilityPolicy = true;
                    break;
                case "y":
                    accountSASPermissions.permanentDelete = true;
                    break;
                default:
                    throw new RangeError(`Invalid permission character: ${c}`);
            }
        }
        return accountSASPermissions;
    }
    /**
     * Creates a {@link AccountSASPermissions} from a raw object which contains same keys as it
     * and boolean values for them.
     *
     * @param permissionLike -
     */ static from(permissionLike) {
        const accountSASPermissions = new AccountSASPermissions();
        if (permissionLike.read) {
            accountSASPermissions.read = true;
        }
        if (permissionLike.write) {
            accountSASPermissions.write = true;
        }
        if (permissionLike.delete) {
            accountSASPermissions.delete = true;
        }
        if (permissionLike.deleteVersion) {
            accountSASPermissions.deleteVersion = true;
        }
        if (permissionLike.filter) {
            accountSASPermissions.filter = true;
        }
        if (permissionLike.tag) {
            accountSASPermissions.tag = true;
        }
        if (permissionLike.list) {
            accountSASPermissions.list = true;
        }
        if (permissionLike.add) {
            accountSASPermissions.add = true;
        }
        if (permissionLike.create) {
            accountSASPermissions.create = true;
        }
        if (permissionLike.update) {
            accountSASPermissions.update = true;
        }
        if (permissionLike.process) {
            accountSASPermissions.process = true;
        }
        if (permissionLike.setImmutabilityPolicy) {
            accountSASPermissions.setImmutabilityPolicy = true;
        }
        if (permissionLike.permanentDelete) {
            accountSASPermissions.permanentDelete = true;
        }
        return accountSASPermissions;
    }
    /**
     * Permission to read resources and list queues and tables granted.
     */ read = false;
    /**
     * Permission to write resources granted.
     */ write = false;
    /**
     * Permission to delete blobs and files granted.
     */ delete = false;
    /**
     * Permission to delete versions granted.
     */ deleteVersion = false;
    /**
     * Permission to list blob containers, blobs, shares, directories, and files granted.
     */ list = false;
    /**
     * Permission to add messages, table entities, and append to blobs granted.
     */ add = false;
    /**
     * Permission to create blobs and files granted.
     */ create = false;
    /**
     * Permissions to update messages and table entities granted.
     */ update = false;
    /**
     * Permission to get and delete messages granted.
     */ process = false;
    /**
     * Specfies Tag access granted.
     */ tag = false;
    /**
     * Permission to filter blobs.
     */ filter = false;
    /**
     * Permission to set immutability policy.
     */ setImmutabilityPolicy = false;
    /**
     * Specifies that Permanent Delete is permitted.
     */ permanentDelete = false;
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
     *
     */ toString() {
        // The order of the characters should be as specified here to ensure correctness:
        // https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
        // Use a string array instead of string concatenating += operator for performance
        const permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.deleteVersion) {
            permissions.push("x");
        }
        if (this.filter) {
            permissions.push("f");
        }
        if (this.tag) {
            permissions.push("t");
        }
        if (this.list) {
            permissions.push("l");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.update) {
            permissions.push("u");
        }
        if (this.process) {
            permissions.push("p");
        }
        if (this.setImmutabilityPolicy) {
            permissions.push("i");
        }
        if (this.permanentDelete) {
            permissions.push("y");
        }
        return permissions.join("");
    }
} //# sourceMappingURL=AccountSASPermissions.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASResourceTypes.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 */ __turbopack_context__.s([
    "AccountSASResourceTypes",
    ()=>AccountSASResourceTypes
]);
class AccountSASResourceTypes {
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @param resourceTypes -
     */ static parse(resourceTypes) {
        const accountSASResourceTypes = new AccountSASResourceTypes();
        for (const c of resourceTypes){
            switch(c){
                case "s":
                    accountSASResourceTypes.service = true;
                    break;
                case "c":
                    accountSASResourceTypes.container = true;
                    break;
                case "o":
                    accountSASResourceTypes.object = true;
                    break;
                default:
                    throw new RangeError(`Invalid resource type: ${c}`);
            }
        }
        return accountSASResourceTypes;
    }
    /**
     * Permission to access service level APIs granted.
     */ service = false;
    /**
     * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
     */ container = false;
    /**
     * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
     */ object = false;
    /**
     * Converts the given resource types to a string.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
     *
     */ toString() {
        const resourceTypes = [];
        if (this.service) {
            resourceTypes.push("s");
        }
        if (this.container) {
            resourceTypes.push("c");
        }
        if (this.object) {
            resourceTypes.push("o");
        }
        return resourceTypes.join("");
    }
} //# sourceMappingURL=AccountSASResourceTypes.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASServices.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 */ __turbopack_context__.s([
    "AccountSASServices",
    ()=>AccountSASServices
]);
class AccountSASServices {
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @param services -
     */ static parse(services) {
        const accountSASServices = new AccountSASServices();
        for (const c of services){
            switch(c){
                case "b":
                    accountSASServices.blob = true;
                    break;
                case "f":
                    accountSASServices.file = true;
                    break;
                case "q":
                    accountSASServices.queue = true;
                    break;
                case "t":
                    accountSASServices.table = true;
                    break;
                default:
                    throw new RangeError(`Invalid service character: ${c}`);
            }
        }
        return accountSASServices;
    }
    /**
     * Permission to access blob resources granted.
     */ blob = false;
    /**
     * Permission to access file resources granted.
     */ file = false;
    /**
     * Permission to access queue resources granted.
     */ queue = false;
    /**
     * Permission to access table resources granted.
     */ table = false;
    /**
     * Converts the given services to a string.
     *
     */ toString() {
        const services = [];
        if (this.blob) {
            services.push("b");
        }
        if (this.table) {
            services.push("t");
        }
        if (this.queue) {
            services.push("q");
        }
        if (this.file) {
            services.push("f");
        }
        return services.join("");
    }
} //# sourceMappingURL=AccountSASServices.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASSignatureValues.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "generateAccountSASQueryParameters",
    ()=>generateAccountSASQueryParameters,
    "generateAccountSASQueryParametersInternal",
    ()=>generateAccountSASQueryParametersInternal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASResourceTypes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASResourceTypes.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASServices$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASServices.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/SasIPRange.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/SASQueryParameters.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
}
function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
    const version = accountSASSignatureValues.version ? accountSASSignatureValues.version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SERVICE_VERSION"];
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") {
        throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") {
        throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version < "2019-12-12") {
        throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version < "2019-12-12") {
        throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    }
    if (accountSASSignatureValues.encryptionScope && version < "2020-12-06") {
        throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    const parsedPermissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASPermissions"].parse(accountSASSignatureValues.permissions.toString());
    const parsedServices = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASServices$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASServices"].parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASResourceTypes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASResourceTypes"].parse(accountSASSignatureValues.resourceTypes).toString();
    let stringToSign;
    if (version >= "2020-12-06") {
        stringToSign = [
            sharedKeyCredential.accountName,
            parsedPermissions,
            parsedServices,
            parsedResourceTypes,
            accountSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(accountSASSignatureValues.startsOn, false) : "",
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(accountSASSignatureValues.expiresOn, false),
            accountSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(accountSASSignatureValues.ipRange) : "",
            accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
            version,
            accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
            ""
        ].join("\n");
    } else {
        stringToSign = [
            sharedKeyCredential.accountName,
            parsedPermissions,
            parsedServices,
            parsedResourceTypes,
            accountSASSignatureValues.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(accountSASSignatureValues.startsOn, false) : "",
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(accountSASSignatureValues.expiresOn, false),
            accountSASSignatureValues.ipRange ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SasIPRange$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ipRangeToString"])(accountSASSignatureValues.ipRange) : "",
            accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
            version,
            ""
        ].join("\n");
    }
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
        sasQueryParameters: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SASQueryParameters"](version, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, accountSASSignatureValues.encryptionScope),
        stringToSign: stringToSign
    };
} //# sourceMappingURL=AccountSASSignatureValues.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BlobLeaseClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobLeaseClient",
    ()=>BlobLeaseClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/tracing.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
;
class BlobLeaseClient {
    _leaseId;
    _url;
    _containerOrBlobOperation;
    _isContainer;
    /**
     * Gets the lease Id.
     *
     * @readonly
     */ get leaseId() {
        return this._leaseId;
    }
    /**
     * Gets the url.
     *
     * @readonly
     */ get url() {
        return this._url;
    }
    /**
     * Creates an instance of BlobLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */ constructor(client, leaseId){
        const clientContext = client.storageClientContext;
        this._url = client.url;
        if (client.name === undefined) {
            this._isContainer = true;
            this._containerOrBlobOperation = clientContext.container;
        } else {
            this._isContainer = false;
            this._containerOrBlobOperation = clientContext.blob;
        }
        if (!leaseId) {
            leaseId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["randomUUID"])();
        }
        this._leaseId = leaseId;
    }
    /**
     * Establishes and manages a lock on a container for delete operations, or on a blob
     * for write and delete operations.
     * The lock duration can be 15 to 60 seconds, or can be infinite.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param duration - Must be between 15 to 60 seconds, or infinite (-1)
     * @param options - option to configure lease management operations.
     * @returns Response data for acquire lease operation.
     */ async acquireLease(duration, options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.tagConditions)) {
            throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this._containerOrBlobOperation.acquireLease({
                abortSignal: options.abortSignal,
                duration,
                modifiedAccessConditions: {
                    ...options.conditions,
                    ifTags: options.conditions?.tagConditions
                },
                proposedLeaseId: this._leaseId,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * To change the ID of the lease.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - option to configure lease management operations.
     * @returns Response data for change lease operation.
     */ async changeLease(proposedLeaseId, options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.tagConditions)) {
            throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
                abortSignal: options.abortSignal,
                modifiedAccessConditions: {
                    ...options.conditions,
                    ifTags: options.conditions?.tagConditions
                },
                tracingOptions: updatedOptions.tracingOptions
            }));
            this._leaseId = proposedLeaseId;
            return response;
        });
    }
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease against the container or the blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param options - option to configure lease management operations.
     * @returns Response data for release lease operation.
     */ async releaseLease(options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.tagConditions)) {
            throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
                abortSignal: options.abortSignal,
                modifiedAccessConditions: {
                    ...options.conditions,
                    ifTags: options.conditions?.tagConditions
                },
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * To renew the lease.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param options - Optional option to configure lease management operations.
     * @returns Response data for renew lease operation.
     */ async renewLease(options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.tagConditions)) {
            throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions)=>{
            return this._containerOrBlobOperation.renewLease(this._leaseId, {
                abortSignal: options.abortSignal,
                modifiedAccessConditions: {
                    ...options.conditions,
                    ifTags: options.conditions?.tagConditions
                },
                tracingOptions: updatedOptions.tracingOptions
            });
        });
    }
    /**
     * To end the lease but ensure that another client cannot acquire a new lease
     * until the current lease period has expired.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param breakPeriod - Break period
     * @param options - Optional options to configure lease management operations.
     * @returns Response data for break lease operation.
     */ async breakLease(breakPeriod, options = {}) {
        if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ETagNone"] || options.conditions?.tagConditions)) {
            throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions)=>{
            const operationOptions = {
                abortSignal: options.abortSignal,
                breakPeriod,
                modifiedAccessConditions: {
                    ...options.conditions,
                    ifTags: options.conditions?.tagConditions
                },
                tracingOptions: updatedOptions.tracingOptions
            };
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this._containerOrBlobOperation.breakLease(operationOptions));
        });
    }
} //# sourceMappingURL=BlobLeaseClient.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BlobDownloadResponse.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobDownloadResponse",
    ()=>BlobDownloadResponse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$RetriableReadableStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/RetriableReadableStream.js [app-route] (ecmascript)");
;
;
class BlobDownloadResponse {
    /**
     * Indicates that the service supports
     * requests for partial file content.
     *
     * @readonly
     */ get acceptRanges() {
        return this.originalResponse.acceptRanges;
    }
    /**
     * Returns if it was previously specified
     * for the file.
     *
     * @readonly
     */ get cacheControl() {
        return this.originalResponse.cacheControl;
    }
    /**
     * Returns the value that was specified
     * for the 'x-ms-content-disposition' header and specifies how to process the
     * response.
     *
     * @readonly
     */ get contentDisposition() {
        return this.originalResponse.contentDisposition;
    }
    /**
     * Returns the value that was specified
     * for the Content-Encoding request header.
     *
     * @readonly
     */ get contentEncoding() {
        return this.originalResponse.contentEncoding;
    }
    /**
     * Returns the value that was specified
     * for the Content-Language request header.
     *
     * @readonly
     */ get contentLanguage() {
        return this.originalResponse.contentLanguage;
    }
    /**
     * The current sequence number for a
     * page blob. This header is not returned for block blobs or append blobs.
     *
     * @readonly
     */ get blobSequenceNumber() {
        return this.originalResponse.blobSequenceNumber;
    }
    /**
     * The blob's type. Possible values include:
     * 'BlockBlob', 'PageBlob', 'AppendBlob'.
     *
     * @readonly
     */ get blobType() {
        return this.originalResponse.blobType;
    }
    /**
     * The number of bytes present in the
     * response body.
     *
     * @readonly
     */ get contentLength() {
        return this.originalResponse.contentLength;
    }
    /**
     * If the file has an MD5 hash and the
     * request is to read the full file, this response header is returned so that
     * the client can check for message content integrity. If the request is to
     * read a specified range and the 'x-ms-range-get-content-md5' is set to
     * true, then the request returns an MD5 hash for the range, as long as the
     * range size is less than or equal to 4 MB. If neither of these sets of
     * conditions is true, then no value is returned for the 'Content-MD5'
     * header.
     *
     * @readonly
     */ get contentMD5() {
        return this.originalResponse.contentMD5;
    }
    /**
     * Indicates the range of bytes returned if
     * the client requested a subset of the file by setting the Range request
     * header.
     *
     * @readonly
     */ get contentRange() {
        return this.originalResponse.contentRange;
    }
    /**
     * The content type specified for the file.
     * The default content type is 'application/octet-stream'
     *
     * @readonly
     */ get contentType() {
        return this.originalResponse.contentType;
    }
    /**
     * Conclusion time of the last attempted
     * Copy File operation where this file was the destination file. This value
     * can specify the time of a completed, aborted, or failed copy attempt.
     *
     * @readonly
     */ get copyCompletedOn() {
        return this.originalResponse.copyCompletedOn;
    }
    /**
     * String identifier for the last attempted Copy
     * File operation where this file was the destination file.
     *
     * @readonly
     */ get copyId() {
        return this.originalResponse.copyId;
    }
    /**
     * Contains the number of bytes copied and
     * the total bytes in the source in the last attempted Copy File operation
     * where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     *
     * @readonly
     */ get copyProgress() {
        return this.originalResponse.copyProgress;
    }
    /**
     * URL up to 2KB in length that specifies the
     * source file used in the last attempted Copy File operation where this file
     * was the destination file.
     *
     * @readonly
     */ get copySource() {
        return this.originalResponse.copySource;
    }
    /**
     * State of the copy operation
     * identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     *
     * @readonly
     */ get copyStatus() {
        return this.originalResponse.copyStatus;
    }
    /**
     * Only appears when
     * x-ms-copy-status is failed or pending. Describes cause of fatal or
     * non-fatal copy operation failure.
     *
     * @readonly
     */ get copyStatusDescription() {
        return this.originalResponse.copyStatusDescription;
    }
    /**
     * When a blob is leased,
     * specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'.
     *
     * @readonly
     */ get leaseDuration() {
        return this.originalResponse.leaseDuration;
    }
    /**
     * Lease state of the blob. Possible
     * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
     *
     * @readonly
     */ get leaseState() {
        return this.originalResponse.leaseState;
    }
    /**
     * The current lease status of the
     * blob. Possible values include: 'locked', 'unlocked'.
     *
     * @readonly
     */ get leaseStatus() {
        return this.originalResponse.leaseStatus;
    }
    /**
     * A UTC date/time value generated by the service that
     * indicates the time at which the response was initiated.
     *
     * @readonly
     */ get date() {
        return this.originalResponse.date;
    }
    /**
     * The number of committed blocks
     * present in the blob. This header is returned only for append blobs.
     *
     * @readonly
     */ get blobCommittedBlockCount() {
        return this.originalResponse.blobCommittedBlockCount;
    }
    /**
     * The ETag contains a value that you can use to
     * perform operations conditionally, in quotes.
     *
     * @readonly
     */ get etag() {
        return this.originalResponse.etag;
    }
    /**
     * The number of tags associated with the blob
     *
     * @readonly
     */ get tagCount() {
        return this.originalResponse.tagCount;
    }
    /**
     * The error code.
     *
     * @readonly
     */ get errorCode() {
        return this.originalResponse.errorCode;
    }
    /**
     * The value of this header is set to
     * true if the file data and application metadata are completely encrypted
     * using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata
     * are encrypted).
     *
     * @readonly
     */ get isServerEncrypted() {
        return this.originalResponse.isServerEncrypted;
    }
    /**
     * If the blob has a MD5 hash, and if
     * request contains range header (Range or x-ms-range), this response header
     * is returned with the value of the whole blob's MD5 value. This value may
     * or may not be equal to the value returned in Content-MD5 header, with the
     * latter calculated from the requested range.
     *
     * @readonly
     */ get blobContentMD5() {
        return this.originalResponse.blobContentMD5;
    }
    /**
     * Returns the date and time the file was last
     * modified. Any operation that modifies the file or its properties updates
     * the last modified time.
     *
     * @readonly
     */ get lastModified() {
        return this.originalResponse.lastModified;
    }
    /**
     * Returns the UTC date and time generated by the service that indicates the time at which the blob was
     * last read or written to.
     *
     * @readonly
     */ get lastAccessed() {
        return this.originalResponse.lastAccessed;
    }
    /**
     * Returns the date and time the blob was created.
     *
     * @readonly
     */ get createdOn() {
        return this.originalResponse.createdOn;
    }
    /**
     * A name-value pair
     * to associate with a file storage object.
     *
     * @readonly
     */ get metadata() {
        return this.originalResponse.metadata;
    }
    /**
     * This header uniquely identifies the request
     * that was made and can be used for troubleshooting the request.
     *
     * @readonly
     */ get requestId() {
        return this.originalResponse.requestId;
    }
    /**
     * If a client request id header is sent in the request, this header will be present in the
     * response with the same value.
     *
     * @readonly
     */ get clientRequestId() {
        return this.originalResponse.clientRequestId;
    }
    /**
     * Indicates the version of the Blob service used
     * to execute the request.
     *
     * @readonly
     */ get version() {
        return this.originalResponse.version;
    }
    /**
     * Indicates the versionId of the downloaded blob version.
     *
     * @readonly
     */ get versionId() {
        return this.originalResponse.versionId;
    }
    /**
     * Indicates whether version of this blob is a current version.
     *
     * @readonly
     */ get isCurrentVersion() {
        return this.originalResponse.isCurrentVersion;
    }
    /**
     * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
     * when the blob was encrypted with a customer-provided key.
     *
     * @readonly
     */ get encryptionKeySha256() {
        return this.originalResponse.encryptionKeySha256;
    }
    /**
     * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
     * true, then the request returns a crc64 for the range, as long as the range size is less than
     * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
     * specified in the same request, it will fail with 400(Bad Request)
     */ get contentCrc64() {
        return this.originalResponse.contentCrc64;
    }
    /**
     * Object Replication Policy Id of the destination blob.
     *
     * @readonly
     */ get objectReplicationDestinationPolicyId() {
        return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    /**
     * Parsed Object Replication Policy Id, Rule Id(s) and status of the source blob.
     *
     * @readonly
     */ get objectReplicationSourceProperties() {
        return this.originalResponse.objectReplicationSourceProperties;
    }
    /**
     * If this blob has been sealed.
     *
     * @readonly
     */ get isSealed() {
        return this.originalResponse.isSealed;
    }
    /**
     * UTC date/time value generated by the service that indicates the time at which the blob immutability policy will expire.
     *
     * @readonly
     */ get immutabilityPolicyExpiresOn() {
        return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    /**
     * Indicates immutability policy mode.
     *
     * @readonly
     */ get immutabilityPolicyMode() {
        return this.originalResponse.immutabilityPolicyMode;
    }
    /**
     * Indicates if a legal hold is present on the blob.
     *
     * @readonly
     */ get legalHold() {
        return this.originalResponse.legalHold;
    }
    /**
     * The response body as a browser Blob.
     * Always undefined in node.js.
     *
     * @readonly
     */ get contentAsBlob() {
        return this.originalResponse.blobBody;
    }
    /**
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     *
     * It will automatically retry when internal read stream unexpected ends.
     *
     * @readonly
     */ get readableStreamBody() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] ? this.blobDownloadStream : undefined;
    }
    /**
     * The HTTP response.
     */ get _response() {
        return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    /**
     * Creates an instance of BlobDownloadResponse.
     *
     * @param originalResponse -
     * @param getter -
     * @param offset -
     * @param count -
     * @param options -
     */ constructor(originalResponse, getter, offset, count, options = {}){
        this.originalResponse = originalResponse;
        this.blobDownloadStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$RetriableReadableStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetriableReadableStream"](this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
} //# sourceMappingURL=BlobDownloadResponse.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroConstants.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "AVRO_CODEC_KEY",
    ()=>AVRO_CODEC_KEY,
    "AVRO_INIT_BYTES",
    ()=>AVRO_INIT_BYTES,
    "AVRO_SCHEMA_KEY",
    ()=>AVRO_SCHEMA_KEY,
    "AVRO_SYNC_MARKER_SIZE",
    ()=>AVRO_SYNC_MARKER_SIZE
]);
const AVRO_SYNC_MARKER_SIZE = 16;
const AVRO_INIT_BYTES = new Uint8Array([
    79,
    98,
    106,
    1
]);
const AVRO_CODEC_KEY = "avro.codec";
const AVRO_SCHEMA_KEY = "avro.schema"; //# sourceMappingURL=AvroConstants.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroParser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "AvroParser",
    ()=>AvroParser,
    "AvroType",
    ()=>AvroType
]);
class AvroParser {
    /**
     * Reads a fixed number of bytes from the stream.
     *
     * @param stream -
     * @param length -
     * @param options -
     */ static async readFixedBytes(stream, length, options = {}) {
        const bytes = await stream.read(length, {
            abortSignal: options.abortSignal
        });
        if (bytes.length !== length) {
            throw new Error("Hit stream end.");
        }
        return bytes;
    }
    /**
     * Reads a single byte from the stream.
     *
     * @param stream -
     * @param options -
     */ static async readByte(stream, options = {}) {
        const buf = await AvroParser.readFixedBytes(stream, 1, options);
        return buf[0];
    }
    // int and long are stored in variable-length zig-zag coding.
    // variable-length: https://lucene.apache.org/core/3_5_0/fileformats.html#VInt
    // zig-zag: https://developers.google.com/protocol-buffers/docs/encoding?csw=1#types
    static async readZigZagLong(stream, options = {}) {
        let zigZagEncoded = 0;
        let significanceInBit = 0;
        let byte, haveMoreByte, significanceInFloat;
        do {
            byte = await AvroParser.readByte(stream, options);
            haveMoreByte = byte & 0x80;
            zigZagEncoded |= (byte & 0x7f) << significanceInBit;
            significanceInBit += 7;
        }while (haveMoreByte && significanceInBit < 28) // bitwise operation only works for 32-bit integers
        if (haveMoreByte) {
            // Switch to float arithmetic
            // eslint-disable-next-line no-self-assign
            zigZagEncoded = zigZagEncoded;
            significanceInFloat = 268435456; // 2 ** 28.
            do {
                byte = await AvroParser.readByte(stream, options);
                zigZagEncoded += (byte & 0x7f) * significanceInFloat;
                significanceInFloat *= 128; // 2 ** 7
            }while (byte & 0x80)
            const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
            if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
                throw new Error("Integer overflow.");
            }
            return res;
        }
        return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream, options = {}) {
        return AvroParser.readZigZagLong(stream, options);
    }
    static async readInt(stream, options = {}) {
        return AvroParser.readZigZagLong(stream, options);
    }
    static async readNull() {
        return null;
    }
    static async readBoolean(stream, options = {}) {
        const b = await AvroParser.readByte(stream, options);
        if (b === 1) {
            return true;
        } else if (b === 0) {
            return false;
        } else {
            throw new Error("Byte was not a boolean.");
        }
    }
    static async readFloat(stream, options = {}) {
        const u8arr = await AvroParser.readFixedBytes(stream, 4, options);
        const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
        return view.getFloat32(0, true); // littleEndian = true
    }
    static async readDouble(stream, options = {}) {
        const u8arr = await AvroParser.readFixedBytes(stream, 8, options);
        const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
        return view.getFloat64(0, true); // littleEndian = true
    }
    static async readBytes(stream, options = {}) {
        const size = await AvroParser.readLong(stream, options);
        if (size < 0) {
            throw new Error("Bytes size was negative.");
        }
        return stream.read(size, {
            abortSignal: options.abortSignal
        });
    }
    static async readString(stream, options = {}) {
        const u8arr = await AvroParser.readBytes(stream, options);
        const utf8decoder = new TextDecoder();
        return utf8decoder.decode(u8arr);
    }
    static async readMapPair(stream, readItemMethod, options = {}) {
        const key = await AvroParser.readString(stream, options);
        // FUTURE: this won't work with readFixed (currently not supported) which needs a length as the parameter.
        const value = await readItemMethod(stream, options);
        return {
            key,
            value
        };
    }
    static async readMap(stream, readItemMethod, options = {}) {
        const readPairMethod = (s, opts = {})=>{
            return AvroParser.readMapPair(s, readItemMethod, opts);
        };
        const pairs = await AvroParser.readArray(stream, readPairMethod, options);
        const dict = {};
        for (const pair of pairs){
            dict[pair.key] = pair.value;
        }
        return dict;
    }
    static async readArray(stream, readItemMethod, options = {}) {
        const items = [];
        for(let count = await AvroParser.readLong(stream, options); count !== 0; count = await AvroParser.readLong(stream, options)){
            if (count < 0) {
                // Ignore block sizes
                await AvroParser.readLong(stream, options);
                count = -count;
            }
            while(count--){
                const item = await readItemMethod(stream, options);
                items.push(item);
            }
        }
        return items;
    }
}
var AvroComplex;
(function(AvroComplex) {
    AvroComplex["RECORD"] = "record";
    AvroComplex["ENUM"] = "enum";
    AvroComplex["ARRAY"] = "array";
    AvroComplex["MAP"] = "map";
    AvroComplex["UNION"] = "union";
    AvroComplex["FIXED"] = "fixed";
})(AvroComplex || (AvroComplex = {}));
var AvroPrimitive;
(function(AvroPrimitive) {
    AvroPrimitive["NULL"] = "null";
    AvroPrimitive["BOOLEAN"] = "boolean";
    AvroPrimitive["INT"] = "int";
    AvroPrimitive["LONG"] = "long";
    AvroPrimitive["FLOAT"] = "float";
    AvroPrimitive["DOUBLE"] = "double";
    AvroPrimitive["BYTES"] = "bytes";
    AvroPrimitive["STRING"] = "string";
})(AvroPrimitive || (AvroPrimitive = {}));
class AvroType {
    /**
     * Determines the AvroType from the Avro Schema.
     */ // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    static fromSchema(schema) {
        if (typeof schema === "string") {
            return AvroType.fromStringSchema(schema);
        } else if (Array.isArray(schema)) {
            return AvroType.fromArraySchema(schema);
        } else {
            return AvroType.fromObjectSchema(schema);
        }
    }
    static fromStringSchema(schema) {
        switch(schema){
            case AvroPrimitive.NULL:
            case AvroPrimitive.BOOLEAN:
            case AvroPrimitive.INT:
            case AvroPrimitive.LONG:
            case AvroPrimitive.FLOAT:
            case AvroPrimitive.DOUBLE:
            case AvroPrimitive.BYTES:
            case AvroPrimitive.STRING:
                return new AvroPrimitiveType(schema);
            default:
                throw new Error(`Unexpected Avro type ${schema}`);
        }
    }
    static fromArraySchema(schema) {
        return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
        const type = schema.type;
        // Primitives can be defined as strings or objects
        try {
            return AvroType.fromStringSchema(type);
        } catch  {
        // no-op
        }
        switch(type){
            case AvroComplex.RECORD:
                if (schema.aliases) {
                    throw new Error(`aliases currently is not supported, schema: ${schema}`);
                }
                if (!schema.name) {
                    throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
                }
                // eslint-disable-next-line no-case-declarations
                const fields = {};
                if (!schema.fields) {
                    throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
                }
                for (const field of schema.fields){
                    fields[field.name] = AvroType.fromSchema(field.type);
                }
                return new AvroRecordType(fields, schema.name);
            case AvroComplex.ENUM:
                if (schema.aliases) {
                    throw new Error(`aliases currently is not supported, schema: ${schema}`);
                }
                if (!schema.symbols) {
                    throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
                }
                return new AvroEnumType(schema.symbols);
            case AvroComplex.MAP:
                if (!schema.values) {
                    throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
                }
                return new AvroMapType(AvroType.fromSchema(schema.values));
            case AvroComplex.ARRAY:
            case AvroComplex.FIXED:
            default:
                throw new Error(`Unexpected Avro type ${type} in ${schema}`);
        }
    }
}
class AvroPrimitiveType extends AvroType {
    _primitive;
    constructor(primitive){
        super();
        this._primitive = primitive;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    read(stream, options = {}) {
        switch(this._primitive){
            case AvroPrimitive.NULL:
                return AvroParser.readNull();
            case AvroPrimitive.BOOLEAN:
                return AvroParser.readBoolean(stream, options);
            case AvroPrimitive.INT:
                return AvroParser.readInt(stream, options);
            case AvroPrimitive.LONG:
                return AvroParser.readLong(stream, options);
            case AvroPrimitive.FLOAT:
                return AvroParser.readFloat(stream, options);
            case AvroPrimitive.DOUBLE:
                return AvroParser.readDouble(stream, options);
            case AvroPrimitive.BYTES:
                return AvroParser.readBytes(stream, options);
            case AvroPrimitive.STRING:
                return AvroParser.readString(stream, options);
            default:
                throw new Error("Unknown Avro Primitive");
        }
    }
}
class AvroEnumType extends AvroType {
    _symbols;
    constructor(symbols){
        super();
        this._symbols = symbols;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    async read(stream, options = {}) {
        const value = await AvroParser.readInt(stream, options);
        return this._symbols[value];
    }
}
class AvroUnionType extends AvroType {
    _types;
    constructor(types){
        super();
        this._types = types;
    }
    async read(stream, options = {}) {
        const typeIndex = await AvroParser.readInt(stream, options);
        return this._types[typeIndex].read(stream, options);
    }
}
class AvroMapType extends AvroType {
    _itemType;
    constructor(itemType){
        super();
        this._itemType = itemType;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    read(stream, options = {}) {
        const readItemMethod = (s, opts)=>{
            return this._itemType.read(s, opts);
        };
        return AvroParser.readMap(stream, readItemMethod, options);
    }
}
class AvroRecordType extends AvroType {
    _name;
    _fields;
    constructor(fields, name){
        super();
        this._fields = fields;
        this._name = name;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    async read(stream, options = {}) {
        // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
        const record = {};
        record["$schema"] = this._name;
        for(const key in this._fields){
            if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
                record[key] = await this._fields[key].read(stream, options);
            }
        }
        return record;
    }
} //# sourceMappingURL=AvroParser.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/utils/utils.common.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "arraysEqual",
    ()=>arraysEqual
]);
function arraysEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; ++i){
        if (a[i] !== b[i]) return false;
    }
    return true;
} //# sourceMappingURL=utils.common.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// TODO: Do a review of non-interfaces
/* eslint-disable @azure/azure-sdk/ts-use-interface-parameters */ __turbopack_context__.s([
    "AvroReader",
    ()=>AvroReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroConstants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroParser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
class AvroReader {
    _dataStream;
    _headerStream;
    _syncMarker;
    _metadata;
    _itemType;
    _itemsRemainingInBlock;
    // Remembers where we started if partial data stream was provided.
    _initialBlockOffset;
    /// The byte offset within the Avro file (both header and data)
    /// of the start of the current block.
    _blockOffset;
    get blockOffset() {
        return this._blockOffset;
    }
    _objectIndex;
    get objectIndex() {
        return this._objectIndex;
    }
    _initialized;
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock){
        this._dataStream = dataStream;
        this._headerStream = headerStream || dataStream;
        this._initialized = false;
        this._blockOffset = currentBlockOffset || 0;
        this._objectIndex = indexWithinCurrentBlock || 0;
        this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options = {}) {
        const header = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readFixedBytes(this._headerStream, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AVRO_INIT_BYTES"].length, {
            abortSignal: options.abortSignal
        });
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["arraysEqual"])(header, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AVRO_INIT_BYTES"])) {
            throw new Error("Stream is not an Avro file.");
        }
        // File metadata is written as if defined by the following map schema:
        // { "type": "map", "values": "bytes"}
        this._metadata = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readMap(this._headerStream, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readString, {
            abortSignal: options.abortSignal
        });
        // Validate codec
        const codec = this._metadata[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AVRO_CODEC_KEY"]];
        if (!(codec === undefined || codec === null || codec === "null")) {
            throw new Error("Codecs are not supported");
        }
        // The 16-byte, randomly-generated sync marker for this file.
        this._syncMarker = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readFixedBytes(this._headerStream, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AVRO_SYNC_MARKER_SIZE"], {
            abortSignal: options.abortSignal
        });
        // Parse the schema
        const schema = JSON.parse(this._metadata[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AVRO_SCHEMA_KEY"]]);
        this._itemType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroType"].fromSchema(schema);
        if (this._blockOffset === 0) {
            this._blockOffset = this._initialBlockOffset + this._dataStream.position;
        }
        this._itemsRemainingInBlock = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readLong(this._dataStream, {
            abortSignal: options.abortSignal
        });
        // skip block length
        await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readLong(this._dataStream, {
            abortSignal: options.abortSignal
        });
        this._initialized = true;
        if (this._objectIndex && this._objectIndex > 0) {
            for(let i = 0; i < this._objectIndex; i++){
                await this._itemType.read(this._dataStream, {
                    abortSignal: options.abortSignal
                });
                this._itemsRemainingInBlock--;
            }
        }
    }
    hasNext() {
        return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    async *parseObjects(options = {}) {
        if (!this._initialized) {
            await this.initialize(options);
        }
        while(this.hasNext()){
            const result = await this._itemType.read(this._dataStream, {
                abortSignal: options.abortSignal
            });
            this._itemsRemainingInBlock--;
            this._objectIndex++;
            if (this._itemsRemainingInBlock === 0) {
                const marker = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readFixedBytes(this._dataStream, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroConstants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AVRO_SYNC_MARKER_SIZE"], {
                    abortSignal: options.abortSignal
                });
                this._blockOffset = this._initialBlockOffset + this._dataStream.position;
                this._objectIndex = 0;
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["arraysEqual"])(this._syncMarker, marker)) {
                    throw new Error("Stream is not a valid Avro file.");
                }
                try {
                    this._itemsRemainingInBlock = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readLong(this._dataStream, {
                        abortSignal: options.abortSignal
                    });
                } catch  {
                    // We hit the end of the stream.
                    this._itemsRemainingInBlock = 0;
                }
                if (this._itemsRemainingInBlock > 0) {
                    // Ignore block size
                    await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroParser"].readLong(this._dataStream, {
                        abortSignal: options.abortSignal
                    });
                }
            }
            yield result;
        }
    }
} //# sourceMappingURL=AvroReader.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReadable.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "AvroReadable",
    ()=>AvroReadable
]);
class AvroReadable {
} //# sourceMappingURL=AvroReadable.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReadableFromStream.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "AvroReadableFromStream",
    ()=>AvroReadableFromStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReadable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReadable.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/abort-controller/dist/esm/AbortError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/buffer [external] (buffer, cjs)");
;
;
;
const ABORT_ERROR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$abort$2d$controller$2f$dist$2f$esm$2f$AbortError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbortError"]("Reading from the avro stream was aborted.");
class AvroReadableFromStream extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReadable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AvroReadable"] {
    _position;
    _readable;
    toUint8Array(data) {
        if (typeof data === "string") {
            return __TURBOPACK__imported__module__$5b$externals$5d2f$buffer__$5b$external$5d$__$28$buffer$2c$__cjs$29$__["Buffer"].from(data);
        }
        return data;
    }
    constructor(readable){
        super();
        this._readable = readable;
        this._position = 0;
    }
    get position() {
        return this._position;
    }
    async read(size, options = {}) {
        if (options.abortSignal?.aborted) {
            throw ABORT_ERROR;
        }
        if (size < 0) {
            throw new Error(`size parameter should be positive: ${size}`);
        }
        if (size === 0) {
            return new Uint8Array();
        }
        if (!this._readable.readable) {
            throw new Error("Stream no longer readable.");
        }
        // See if there is already enough data.
        const chunk = this._readable.read(size);
        if (chunk) {
            this._position += chunk.length;
            // chunk.length maybe less than desired size if the stream ends.
            return this.toUint8Array(chunk);
        } else {
            // register callback to wait for enough data to read
            return new Promise((resolve, reject)=>{
                /* eslint-disable @typescript-eslint/no-use-before-define */ const cleanUp = ()=>{
                    this._readable.removeListener("readable", readableCallback);
                    this._readable.removeListener("error", rejectCallback);
                    this._readable.removeListener("end", rejectCallback);
                    this._readable.removeListener("close", rejectCallback);
                    if (options.abortSignal) {
                        options.abortSignal.removeEventListener("abort", abortHandler);
                    }
                };
                const readableCallback = ()=>{
                    const callbackChunk = this._readable.read(size);
                    if (callbackChunk) {
                        this._position += callbackChunk.length;
                        cleanUp();
                        // callbackChunk.length maybe less than desired size if the stream ends.
                        resolve(this.toUint8Array(callbackChunk));
                    }
                };
                const rejectCallback = ()=>{
                    cleanUp();
                    reject();
                };
                const abortHandler = ()=>{
                    cleanUp();
                    reject(ABORT_ERROR);
                };
                this._readable.on("readable", readableCallback);
                this._readable.once("error", rejectCallback);
                this._readable.once("end", rejectCallback);
                this._readable.once("close", rejectCallback);
                if (options.abortSignal) {
                    options.abortSignal.addEventListener("abort", abortHandler);
                }
            /* eslint-enable @typescript-eslint/no-use-before-define */ });
        }
    }
} //# sourceMappingURL=AvroReadableFromStream.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReadable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReadable.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$internal$2d$avro$2f$AvroReadableFromStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/internal-avro/AvroReadableFromStream.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BlobQueryResponse.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobQueryResponse",
    ()=>BlobQueryResponse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$BlobQuickQueryStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/BlobQuickQueryStream.js [app-route] (ecmascript)");
;
;
class BlobQueryResponse {
    /**
     * Indicates that the service supports
     * requests for partial file content.
     *
     * @readonly
     */ get acceptRanges() {
        return this.originalResponse.acceptRanges;
    }
    /**
     * Returns if it was previously specified
     * for the file.
     *
     * @readonly
     */ get cacheControl() {
        return this.originalResponse.cacheControl;
    }
    /**
     * Returns the value that was specified
     * for the 'x-ms-content-disposition' header and specifies how to process the
     * response.
     *
     * @readonly
     */ get contentDisposition() {
        return this.originalResponse.contentDisposition;
    }
    /**
     * Returns the value that was specified
     * for the Content-Encoding request header.
     *
     * @readonly
     */ get contentEncoding() {
        return this.originalResponse.contentEncoding;
    }
    /**
     * Returns the value that was specified
     * for the Content-Language request header.
     *
     * @readonly
     */ get contentLanguage() {
        return this.originalResponse.contentLanguage;
    }
    /**
     * The current sequence number for a
     * page blob. This header is not returned for block blobs or append blobs.
     *
     * @readonly
     */ get blobSequenceNumber() {
        return this.originalResponse.blobSequenceNumber;
    }
    /**
     * The blob's type. Possible values include:
     * 'BlockBlob', 'PageBlob', 'AppendBlob'.
     *
     * @readonly
     */ get blobType() {
        return this.originalResponse.blobType;
    }
    /**
     * The number of bytes present in the
     * response body.
     *
     * @readonly
     */ get contentLength() {
        return this.originalResponse.contentLength;
    }
    /**
     * If the file has an MD5 hash and the
     * request is to read the full file, this response header is returned so that
     * the client can check for message content integrity. If the request is to
     * read a specified range and the 'x-ms-range-get-content-md5' is set to
     * true, then the request returns an MD5 hash for the range, as long as the
     * range size is less than or equal to 4 MB. If neither of these sets of
     * conditions is true, then no value is returned for the 'Content-MD5'
     * header.
     *
     * @readonly
     */ get contentMD5() {
        return this.originalResponse.contentMD5;
    }
    /**
     * Indicates the range of bytes returned if
     * the client requested a subset of the file by setting the Range request
     * header.
     *
     * @readonly
     */ get contentRange() {
        return this.originalResponse.contentRange;
    }
    /**
     * The content type specified for the file.
     * The default content type is 'application/octet-stream'
     *
     * @readonly
     */ get contentType() {
        return this.originalResponse.contentType;
    }
    /**
     * Conclusion time of the last attempted
     * Copy File operation where this file was the destination file. This value
     * can specify the time of a completed, aborted, or failed copy attempt.
     *
     * @readonly
     */ get copyCompletedOn() {
        return undefined;
    }
    /**
     * String identifier for the last attempted Copy
     * File operation where this file was the destination file.
     *
     * @readonly
     */ get copyId() {
        return this.originalResponse.copyId;
    }
    /**
     * Contains the number of bytes copied and
     * the total bytes in the source in the last attempted Copy File operation
     * where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     *
     * @readonly
     */ get copyProgress() {
        return this.originalResponse.copyProgress;
    }
    /**
     * URL up to 2KB in length that specifies the
     * source file used in the last attempted Copy File operation where this file
     * was the destination file.
     *
     * @readonly
     */ get copySource() {
        return this.originalResponse.copySource;
    }
    /**
     * State of the copy operation
     * identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     *
     * @readonly
     */ get copyStatus() {
        return this.originalResponse.copyStatus;
    }
    /**
     * Only appears when
     * x-ms-copy-status is failed or pending. Describes cause of fatal or
     * non-fatal copy operation failure.
     *
     * @readonly
     */ get copyStatusDescription() {
        return this.originalResponse.copyStatusDescription;
    }
    /**
     * When a blob is leased,
     * specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'.
     *
     * @readonly
     */ get leaseDuration() {
        return this.originalResponse.leaseDuration;
    }
    /**
     * Lease state of the blob. Possible
     * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
     *
     * @readonly
     */ get leaseState() {
        return this.originalResponse.leaseState;
    }
    /**
     * The current lease status of the
     * blob. Possible values include: 'locked', 'unlocked'.
     *
     * @readonly
     */ get leaseStatus() {
        return this.originalResponse.leaseStatus;
    }
    /**
     * A UTC date/time value generated by the service that
     * indicates the time at which the response was initiated.
     *
     * @readonly
     */ get date() {
        return this.originalResponse.date;
    }
    /**
     * The number of committed blocks
     * present in the blob. This header is returned only for append blobs.
     *
     * @readonly
     */ get blobCommittedBlockCount() {
        return this.originalResponse.blobCommittedBlockCount;
    }
    /**
     * The ETag contains a value that you can use to
     * perform operations conditionally, in quotes.
     *
     * @readonly
     */ get etag() {
        return this.originalResponse.etag;
    }
    /**
     * The error code.
     *
     * @readonly
     */ get errorCode() {
        return this.originalResponse.errorCode;
    }
    /**
     * The value of this header is set to
     * true if the file data and application metadata are completely encrypted
     * using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata
     * are encrypted).
     *
     * @readonly
     */ get isServerEncrypted() {
        return this.originalResponse.isServerEncrypted;
    }
    /**
     * If the blob has a MD5 hash, and if
     * request contains range header (Range or x-ms-range), this response header
     * is returned with the value of the whole blob's MD5 value. This value may
     * or may not be equal to the value returned in Content-MD5 header, with the
     * latter calculated from the requested range.
     *
     * @readonly
     */ get blobContentMD5() {
        return this.originalResponse.blobContentMD5;
    }
    /**
     * Returns the date and time the file was last
     * modified. Any operation that modifies the file or its properties updates
     * the last modified time.
     *
     * @readonly
     */ get lastModified() {
        return this.originalResponse.lastModified;
    }
    /**
     * A name-value pair
     * to associate with a file storage object.
     *
     * @readonly
     */ get metadata() {
        return this.originalResponse.metadata;
    }
    /**
     * This header uniquely identifies the request
     * that was made and can be used for troubleshooting the request.
     *
     * @readonly
     */ get requestId() {
        return this.originalResponse.requestId;
    }
    /**
     * If a client request id header is sent in the request, this header will be present in the
     * response with the same value.
     *
     * @readonly
     */ get clientRequestId() {
        return this.originalResponse.clientRequestId;
    }
    /**
     * Indicates the version of the File service used
     * to execute the request.
     *
     * @readonly
     */ get version() {
        return this.originalResponse.version;
    }
    /**
     * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
     * when the blob was encrypted with a customer-provided key.
     *
     * @readonly
     */ get encryptionKeySha256() {
        return this.originalResponse.encryptionKeySha256;
    }
    /**
     * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
     * true, then the request returns a crc64 for the range, as long as the range size is less than
     * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
     * specified in the same request, it will fail with 400(Bad Request)
     */ get contentCrc64() {
        return this.originalResponse.contentCrc64;
    }
    /**
     * The response body as a browser Blob.
     * Always undefined in node.js.
     *
     * @readonly
     */ get blobBody() {
        return undefined;
    }
    /**
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     *
     * It will parse avor data returned by blob query.
     *
     * @readonly
     */ get readableStreamBody() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] ? this.blobDownloadStream : undefined;
    }
    /**
     * The HTTP response.
     */ get _response() {
        return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    /**
     * Creates an instance of BlobQueryResponse.
     *
     * @param originalResponse -
     * @param options -
     */ constructor(originalResponse, options = {}){
        this.originalResponse = originalResponse;
        this.blobDownloadStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$BlobQuickQueryStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobQuickQueryStream"](this.originalResponse.readableStreamBody, options);
    }
} //# sourceMappingURL=BlobQueryResponse.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/models.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlockBlobTier",
    ()=>BlockBlobTier,
    "PremiumPageBlobTier",
    ()=>PremiumPageBlobTier,
    "StorageBlobAudience",
    ()=>StorageBlobAudience,
    "ensureCpkIfSpecified",
    ()=>ensureCpkIfSpecified,
    "getBlobServiceAccountAudience",
    ()=>getBlobServiceAccountAudience,
    "toAccessTier",
    ()=>toAccessTier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
;
var BlockBlobTier;
(function(BlockBlobTier) {
    /**
     * Optimized for storing data that is accessed frequently.
     */ BlockBlobTier["Hot"] = "Hot";
    /**
     * Optimized for storing data that is infrequently accessed and stored for at least 30 days.
     */ BlockBlobTier["Cool"] = "Cool";
    /**
     * Optimized for storing data that is rarely accessed.
     */ BlockBlobTier["Cold"] = "Cold";
    /**
     * Optimized for storing data that is rarely accessed and stored for at least 180 days
     * with flexible latency requirements (on the order of hours).
     */ BlockBlobTier["Archive"] = "Archive";
})(BlockBlobTier || (BlockBlobTier = {}));
var PremiumPageBlobTier;
(function(PremiumPageBlobTier) {
    /**
     * P4 Tier.
     */ PremiumPageBlobTier["P4"] = "P4";
    /**
     * P6 Tier.
     */ PremiumPageBlobTier["P6"] = "P6";
    /**
     * P10 Tier.
     */ PremiumPageBlobTier["P10"] = "P10";
    /**
     * P15 Tier.
     */ PremiumPageBlobTier["P15"] = "P15";
    /**
     * P20 Tier.
     */ PremiumPageBlobTier["P20"] = "P20";
    /**
     * P30 Tier.
     */ PremiumPageBlobTier["P30"] = "P30";
    /**
     * P40 Tier.
     */ PremiumPageBlobTier["P40"] = "P40";
    /**
     * P50 Tier.
     */ PremiumPageBlobTier["P50"] = "P50";
    /**
     * P60 Tier.
     */ PremiumPageBlobTier["P60"] = "P60";
    /**
     * P70 Tier.
     */ PremiumPageBlobTier["P70"] = "P70";
    /**
     * P80 Tier.
     */ PremiumPageBlobTier["P80"] = "P80";
})(PremiumPageBlobTier || (PremiumPageBlobTier = {}));
function toAccessTier(tier) {
    if (tier === undefined) {
        return undefined;
    }
    return tier; // No more check if string is a valid AccessTier, and left this to underlay logic to decide(service).
}
function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps) {
        throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
    }
    if (cpk && !cpk.encryptionAlgorithm) {
        cpk.encryptionAlgorithm = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EncryptionAlgorithmAES25"];
    }
}
var StorageBlobAudience;
(function(StorageBlobAudience) {
    /**
     * The OAuth scope to use to retrieve an AAD token for Azure Storage.
     */ StorageBlobAudience["StorageOAuthScopes"] = "https://storage.azure.com/.default";
    /**
     * The OAuth scope to use to retrieve an AAD token for Azure Disk.
     */ StorageBlobAudience["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
})(StorageBlobAudience || (StorageBlobAudience = {}));
function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
} //# sourceMappingURL=models.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/PageBlobRangeResponse.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Function that converts PageRange and ClearRange to a common Range object.
 * PageRange and ClearRange have start and end while Range offset and count
 * this function normalizes to Range.
 * @param response - Model PageBlob Range response
 */ __turbopack_context__.s([
    "rangeResponseFromModel",
    ()=>rangeResponseFromModel
]);
function rangeResponseFromModel(response) {
    const pageRange = (response._response.parsedBody.pageRange || []).map((x)=>({
            offset: x.start,
            count: x.end - x.start
        }));
    const clearRange = (response._response.parsedBody.clearRange || []).map((x)=>({
            offset: x.start,
            count: x.end - x.start
        }));
    return {
        ...response,
        pageRange,
        clearRange,
        _response: {
            ...response._response,
            parsedBody: {
                pageRange,
                clearRange
            }
        }
    };
} //# sourceMappingURL=PageBlobRangeResponse.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/pollers/BlobStartCopyFromUrlPoller.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobBeginCopyFromUrlPoller",
    ()=>BlobBeginCopyFromUrlPoller
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$delay$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/delay.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$lro$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-lro/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$lro$2f$dist$2f$esm$2f$legacy$2f$poller$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-lro/dist/esm/legacy/poller.js [app-route] (ecmascript)");
;
;
class BlobBeginCopyFromUrlPoller extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$lro$2f$dist$2f$esm$2f$legacy$2f$poller$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Poller"] {
    intervalInMs;
    constructor(options){
        const { blobClient, copySource, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBlobBeginCopyFromURLPollOperation({
            ...state,
            blobClient,
            copySource,
            startCopyFromURLOptions
        });
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.intervalInMs = intervalInMs;
    }
    delay() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$delay$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["delay"])(this.intervalInMs);
    }
}
/**
 * Note: Intentionally using function expression over arrow function expression
 * so that the function can be invoked with a different context.
 * This affects what `this` refers to.
 * @hidden
 */ const cancel = async function cancel(options = {}) {
    const state = this.state;
    const { copyId } = state;
    if (state.isCompleted) {
        return makeBlobBeginCopyFromURLPollOperation(state);
    }
    if (!copyId) {
        state.isCancelled = true;
        return makeBlobBeginCopyFromURLPollOperation(state);
    }
    // if abortCopyFromURL throws, it will bubble up to user's poller.cancelOperation call
    await state.blobClient.abortCopyFromURL(copyId, {
        abortSignal: options.abortSignal
    });
    state.isCancelled = true;
    return makeBlobBeginCopyFromURLPollOperation(state);
};
/**
 * Note: Intentionally using function expression over arrow function expression
 * so that the function can be invoked with a different context.
 * This affects what `this` refers to.
 * @hidden
 */ const update = async function update(options = {}) {
    const state = this.state;
    const { blobClient, copySource, startCopyFromURLOptions } = state;
    if (!state.isStarted) {
        state.isStarted = true;
        const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
        // copyId is needed to abort
        state.copyId = result.copyId;
        if (result.copyStatus === "success") {
            state.result = result;
            state.isCompleted = true;
        }
    } else if (!state.isCompleted) {
        try {
            const result = await state.blobClient.getProperties({
                abortSignal: options.abortSignal
            });
            const { copyStatus, copyProgress } = result;
            const prevCopyProgress = state.copyProgress;
            if (copyProgress) {
                state.copyProgress = copyProgress;
            }
            if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function") {
                // trigger in setTimeout, or swallow error?
                options.fireProgress(state);
            } else if (copyStatus === "success") {
                state.result = result;
                state.isCompleted = true;
            } else if (copyStatus === "failed") {
                state.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
                state.isCompleted = true;
            }
        } catch (err) {
            state.error = err;
            state.isCompleted = true;
        }
    }
    return makeBlobBeginCopyFromURLPollOperation(state);
};
/**
 * Note: Intentionally using function expression over arrow function expression
 * so that the function can be invoked with a different context.
 * This affects what `this` refers to.
 * @hidden
 */ const toString = function toString() {
    return JSON.stringify({
        state: this.state
    }, (key, value)=>{
        // remove blobClient from serialized state since a client can't be hydrated from this info.
        if (key === "blobClient") {
            return undefined;
        }
        return value;
    });
};
/**
 * Creates a poll operation given the provided state.
 * @hidden
 */ function makeBlobBeginCopyFromURLPollOperation(state) {
    return {
        state: {
            ...state
        },
        cancel,
        toString,
        update
    };
} //# sourceMappingURL=BlobStartCopyFromUrlPoller.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/Range.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Generate a range string. For example:
 *
 * "bytes=255-" or "bytes=0-511"
 *
 * @param iRange -
 */ __turbopack_context__.s([
    "rangeToString",
    ()=>rangeToString
]);
function rangeToString(iRange) {
    if (iRange.offset < 0) {
        throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (iRange.count && iRange.count <= 0) {
        throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
} //# sourceMappingURL=Range.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BatchUtils.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "getBodyAsText",
    ()=>getBodyAsText,
    "utf8ByteLength",
    ()=>utf8ByteLength
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
;
;
async function getBodyAsText(batchResponse) {
    let buffer = Buffer.alloc(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BATCH_MAX_PAYLOAD_IN_BYTES"]);
    const responseLength = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["streamToBuffer2"])(batchResponse.readableStreamBody, buffer);
    // Slice the buffer to trim the empty ending.
    buffer = buffer.slice(0, responseLength);
    return buffer.toString();
}
function utf8ByteLength(str) {
    return Buffer.byteLength(str);
} //# sourceMappingURL=BatchUtils.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BatchResponseParser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BatchResponseParser",
    ()=>BatchResponseParser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$httpHeaders$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/httpHeaders.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-http-compat/dist/esm/util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BatchUtils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/log.js [app-route] (ecmascript)");
;
;
;
;
;
const HTTP_HEADER_DELIMITER = ": ";
const SPACE_DELIMITER = " ";
const NOT_FOUND = -1;
class BatchResponseParser {
    batchResponse;
    responseBatchBoundary;
    perResponsePrefix;
    batchResponseEnding;
    subRequests;
    constructor(batchResponse, subRequests){
        if (!batchResponse || !batchResponse.contentType) {
            // In special case(reported), server may return invalid content-type which could not be parsed.
            throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
        }
        if (!subRequests || subRequests.size === 0) {
            // This should be prevent during coding.
            throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
        }
        this.batchResponse = batchResponse;
        this.subRequests = subRequests;
        this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
        this.perResponsePrefix = `--${this.responseBatchBoundary}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}`;
        this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    // For example of response, please refer to https://learn.microsoft.com/rest/api/storageservices/blob-batch#response
    async parseBatchResponse() {
        // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse
        // sub request's response.
        if (this.batchResponse._response.status !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPURLConnection"].HTTP_ACCEPTED) {
            throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
        }
        const responseBodyAsText = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBodyAsText"])(this.batchResponse);
        const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0] // string after ending is useless
        .split(this.perResponsePrefix).slice(1); // string before first response boundary is useless
        const subResponseCount = subResponses.length;
        // Defensive coding in case of potential error parsing.
        // Note: subResponseCount == 1 is special case where sub request is invalid.
        // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.
        // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.
        if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
            throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
        }
        const deserializedSubResponses = new Array(subResponseCount);
        let subResponsesSucceededCount = 0;
        let subResponsesFailedCount = 0;
        // Parse sub subResponses.
        for(let index = 0; index < subResponseCount; index++){
            const subResponse = subResponses[index];
            const deserializedSubResponse = {};
            deserializedSubResponse.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$http$2d$compat$2f$dist$2f$esm$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toHttpHeadersLike"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$httpHeaders$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHttpHeaders"])());
            const responseLines = subResponse.split(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}`);
            let subRespHeaderStartFound = false;
            let subRespHeaderEndFound = false;
            let subRespFailed = false;
            let contentId = NOT_FOUND;
            for (const responseLine of responseLines){
                if (!subRespHeaderStartFound) {
                    // Convention line to indicate content ID
                    if (responseLine.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_ID)) {
                        contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
                    }
                    // Http version line with status code indicates the start of sub request's response.
                    // Example: HTTP/1.1 202 Accepted
                    if (responseLine.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_VERSION_1_1"])) {
                        subRespHeaderStartFound = true;
                        const tokens = responseLine.split(SPACE_DELIMITER);
                        deserializedSubResponse.status = parseInt(tokens[1]);
                        deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
                    }
                    continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *
                }
                if (responseLine.trim() === "") {
                    // Sub response's header start line already found, and the first empty line indicates header end line found.
                    if (!subRespHeaderEndFound) {
                        subRespHeaderEndFound = true;
                    }
                    continue; // Skip empty line
                }
                // Note: when code reach here, it indicates subRespHeaderStartFound == true
                if (!subRespHeaderEndFound) {
                    if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
                        // Defensive coding to prevent from missing valuable lines.
                        throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
                    }
                    // Parse headers of sub response.
                    const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
                    deserializedSubResponse.headers.set(tokens[0], tokens[1]);
                    if (tokens[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_ERROR_CODE) {
                        deserializedSubResponse.errorCode = tokens[1];
                        subRespFailed = true;
                    }
                } else {
                    // Assemble body of sub response.
                    if (!deserializedSubResponse.bodyAsText) {
                        deserializedSubResponse.bodyAsText = "";
                    }
                    deserializedSubResponse.bodyAsText += responseLine;
                }
            } // Inner for end
            // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.
            // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it
            // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that
            // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.
            if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {
                deserializedSubResponse._request = this.subRequests.get(contentId);
                deserializedSubResponses[contentId] = deserializedSubResponse;
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
            }
            if (subRespFailed) {
                subResponsesFailedCount++;
            } else {
                subResponsesSucceededCount++;
            }
        }
        return {
            subResponses: deserializedSubResponses,
            subResponsesSucceededCount: subResponsesSucceededCount,
            subResponsesFailedCount: subResponsesFailedCount
        };
    }
} //# sourceMappingURL=BatchResponseParser.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobBatch",
    ()=>BlobBatch
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/tokenCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$bearerTokenAuthenticationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/policies/bearerTokenAuthenticationPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/pipeline.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$httpHeaders$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/httpHeaders.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Clients.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$Mutex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/Mutex.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-xml/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$xml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-xml/dist/esm/xml.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/tracing.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$authorizeRequestOnTenantChallenge$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/authorizeRequestOnTenantChallenge.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$serializationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-client/dist/esm/serializationPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageSharedKeyCredentialPolicyV2.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class BlobBatch {
    batchRequest;
    batch = "batch";
    batchType;
    constructor(){
        this.batchRequest = new InnerBatchRequest();
    }
    /**
     * Get the value of Content-Type for a batch request.
     * The value must be multipart/mixed with a batch boundary.
     * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252
     */ getMultiPartContentType() {
        return this.batchRequest.getMultipartContentType();
    }
    /**
     * Get assembled HTTP request body for sub requests.
     */ getHttpRequestBody() {
        return this.batchRequest.getHttpRequestBody();
    }
    /**
     * Get sub requests that are added into the batch request.
     */ getSubRequests() {
        return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
        await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$Mutex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Mutex"].lock(this.batch);
        try {
            this.batchRequest.preAddSubRequest(subRequest);
            await assembleSubRequestFunc();
            this.batchRequest.postAddSubRequest(subRequest);
        } finally{
            await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$Mutex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Mutex"].unlock(this.batch);
        }
    }
    setBatchType(batchType) {
        if (!this.batchType) {
            this.batchType = batchType;
        }
        if (this.batchType !== batchType) {
            throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
        }
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
        let url;
        let credential;
        if (typeof urlOrBlobClient === "string" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] && credentialOrOptions instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"] || credentialOrOptions instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credentialOrOptions))) {
            // First overload
            url = urlOrBlobClient;
            credential = credentialOrOptions;
        } else if (urlOrBlobClient instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobClient"]) {
            // Second overload
            url = urlOrBlobClient.url;
            credential = urlOrBlobClient.credential;
            options = credentialOrOptions;
        } else {
            throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
        }
        if (!options) {
            options = {};
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions)=>{
            this.setBatchType("delete");
            await this.addSubRequestInternal({
                url: url,
                credential: credential
            }, async ()=>{
                await new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobClient"](url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
            });
        });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
        let url;
        let credential;
        let tier;
        if (typeof urlOrBlobClient === "string" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] && credentialOrTier instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"] || credentialOrTier instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credentialOrTier))) {
            // First overload
            url = urlOrBlobClient;
            credential = credentialOrTier;
            tier = tierOrOptions;
        } else if (urlOrBlobClient instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobClient"]) {
            // Second overload
            url = urlOrBlobClient.url;
            credential = urlOrBlobClient.credential;
            tier = credentialOrTier;
            options = tierOrOptions;
        } else {
            throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
        }
        if (!options) {
            options = {};
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions)=>{
            this.setBatchType("setAccessTier");
            await this.addSubRequestInternal({
                url: url,
                credential: credential
            }, async ()=>{
                await new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobClient"](url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
            });
        });
    }
}
/**
 * Inner batch request class which is responsible for assembling and serializing sub requests.
 * See https://learn.microsoft.com/rest/api/storageservices/blob-batch#request-body for how requests are assembled.
 */ class InnerBatchRequest {
    operationCount;
    body;
    subRequests;
    boundary;
    subRequestPrefix;
    multipartContentType;
    batchRequestEnding;
    constructor(){
        this.operationCount = 0;
        this.body = "";
        const tempGuid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["randomUUID"])();
        // batch_{batchid}
        this.boundary = `batch_${tempGuid}`;
        // --batch_{batchid}
        // Content-Type: application/http
        // Content-Transfer-Encoding: binary
        this.subRequestPrefix = `--${this.boundary}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_TYPE}: application/http${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_TRANSFER_ENCODING}: binary`;
        // multipart/mixed; boundary=batch_{batchid}
        this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
        // --batch_{batchid}--
        this.batchRequestEnding = `--${this.boundary}--`;
        this.subRequests = new Map();
    }
    /**
     * Create pipeline to assemble sub requests. The idea here is to use existing
     * credential and serialization/deserialization components, with additional policies to
     * filter unnecessary headers, assemble sub requests into request's body
     * and intercept request from going to wire.
     * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
     */ createPipeline(credential) {
        const corePipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createEmptyPipeline"])();
        corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$serializationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializationPolicy"])({
            stringifyXML: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$xml$2f$dist$2f$esm$2f$xml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringifyXML"],
            serializerOptions: {
                xml: {
                    xmlCharKey: "#"
                }
            }
        }), {
            phase: "Serialize"
        });
        // Use batch header filter policy to exclude unnecessary headers
        corePipeline.addPolicy(batchHeaderFilterPolicy());
        // Use batch assemble policy to assemble request and intercept request from going to wire
        corePipeline.addPolicy(batchRequestAssemblePolicy(this), {
            afterPhase: "Sign"
        });
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credential)) {
            corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$bearerTokenAuthenticationPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bearerTokenAuthenticationPolicy"])({
                credential,
                scopes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageOAuthScopes"],
                challengeCallbacks: {
                    authorizeRequestOnChallenge: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$client$2f$dist$2f$esm$2f$authorizeRequestOnTenantChallenge$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authorizeRequestOnTenantChallenge"]
                }
            }), {
                phase: "Sign"
            });
        } else if (credential instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"]) {
            corePipeline.addPolicy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicyV2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storageSharedKeyCredentialPolicy"])({
                accountName: credential.accountName,
                accountKey: credential.accountKey
            }), {
                phase: "Sign"
            });
        }
        const pipeline = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Pipeline"]([]);
        // attach the v2 pipeline to this one
        pipeline._credential = credential;
        pipeline._corePipeline = corePipeline;
        return pipeline;
    }
    appendSubRequestToBody(request) {
        // Start to assemble sub request
        this.body += [
            this.subRequestPrefix,
            `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].CONTENT_ID}: ${this.operationCount}`,
            "",
            `${request.method.toString()} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLPathAndQuery"])(request.url)} ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_VERSION_1_1"]}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}`
        ].join(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]);
        for (const [name, value] of request.headers){
            this.body += `${name}: ${value}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}`;
        }
        this.body += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]; // sub request's headers need be ending with an empty line
    // No body to assemble for current batch request support
    // End to assemble sub request
    }
    preAddSubRequest(subRequest) {
        if (this.operationCount >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BATCH_MAX_REQUEST"]) {
            throw new RangeError(`Cannot exceed ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BATCH_MAX_REQUEST"]} sub requests in a single batch`);
        }
        // Fast fail if url for sub request is invalid
        const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLPath"])(subRequest.url);
        if (!path || path === "") {
            throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
        }
    }
    postAddSubRequest(subRequest) {
        this.subRequests.set(this.operationCount, subRequest);
        this.operationCount++;
    }
    // Return the http request body with assembling the ending line to the sub request body.
    getHttpRequestBody() {
        return `${this.body}${this.batchRequestEnding}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTP_LINE_ENDING"]}`;
    }
    getMultipartContentType() {
        return this.multipartContentType;
    }
    getSubRequests() {
        return this.subRequests;
    }
}
function batchRequestAssemblePolicy(batchRequest) {
    return {
        name: "batchRequestAssemblePolicy",
        async sendRequest (request) {
            batchRequest.appendSubRequestToBody(request);
            return {
                request,
                status: 200,
                headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$httpHeaders$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHttpHeaders"])()
            };
        }
    };
}
function batchHeaderFilterPolicy() {
    return {
        name: "batchHeaderFilterPolicy",
        async sendRequest (request, next) {
            let xMsHeaderName = "";
            for (const [name] of request.headers){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["iEqual"])(name, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HeaderConstants"].X_MS_VERSION)) {
                    xMsHeaderName = name;
                }
            }
            if (xMsHeaderName !== "") {
                request.headers.delete(xMsHeaderName); // The subrequests should not have the x-ms-version header.
            }
            return next(request);
        }
    };
} //# sourceMappingURL=BlobBatch.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatchClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([
    "BlobBatchClient",
    ()=>BlobBatchClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchResponseParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BatchResponseParser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BatchUtils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/tracing.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageContextClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageContextClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
class BlobBatchClient {
    serviceOrContainerContext;
    constructor(url, credentialOrPipeline, // Legacy, no fix for eslint error without breaking. Disable it for this interface.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ options){
        let pipeline;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPipelineLike"])(credentialOrPipeline)) {
            pipeline = credentialOrPipeline;
        } else if (!credentialOrPipeline) {
            // no credential provided
            pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"](), options);
        } else {
            pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(credentialOrPipeline, options);
        }
        const storageClientContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageContextClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageContextClient"](url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getCoreClientOptions"])(pipeline));
        const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getURLPath"])(url);
        if (path && path !== "/") {
            // Container scoped.
            this.serviceOrContainerContext = storageClientContext.container;
        } else {
            this.serviceOrContainerContext = storageClientContext.service;
        }
    }
    /**
     * Creates a {@link BlobBatch}.
     * A BlobBatch represents an aggregated set of operations on blobs.
     */ createBatch() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobBatch"]();
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ options) {
        const batch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobBatch"]();
        for (const urlOrBlobClient of urlsOrBlobClients){
            if (typeof urlOrBlobClient === "string") {
                await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
            } else {
                await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
            }
        }
        return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ options) {
        const batch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobBatch"]();
        for (const urlOrBlobClient of urlsOrBlobClients){
            if (typeof urlOrBlobClient === "string") {
                await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
            } else {
                await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
            }
        }
        return this.submitBatch(batch);
    }
    /**
     * Submit batch request which consists of multiple subrequests.
     *
     * Get `blobBatchClient` and other details before running the snippets.
     * `blobServiceClient.getBlobBatchClient()` gives the `blobBatchClient`
     *
     * Example usage:
     *
     * ```ts snippet:BlobBatchClientSubmitBatch
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { BlobServiceClient, BlobBatch } from "@azure/storage-blob";
     *
     * const account = "<account>";
     * const credential = new DefaultAzureCredential();
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   credential,
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobBatchClient = containerClient.getBlobBatchClient();
     *
     * const batchRequest = new BlobBatch();
     * await batchRequest.deleteBlob("<blob-url-1>", credential);
     * await batchRequest.deleteBlob("<blob-url-2>", credential, {
     *   deleteSnapshots: "include",
     * });
     * const batchResp = await blobBatchClient.submitBatch(batchRequest);
     * console.log(batchResp.subResponsesSucceededCount);
     * ```
     *
     * Example using a lease:
     *
     * ```ts snippet:BlobBatchClientSubmitBatchWithLease
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { BlobServiceClient, BlobBatch } from "@azure/storage-blob";
     *
     * const account = "<account>";
     * const credential = new DefaultAzureCredential();
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   credential,
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobBatchClient = containerClient.getBlobBatchClient();
     * const blobClient = containerClient.getBlobClient("<blob name>");
     *
     * const batchRequest = new BlobBatch();
     * await batchRequest.setBlobAccessTier(blobClient, "Cool");
     * await batchRequest.setBlobAccessTier(blobClient, "Cool", {
     *   conditions: { leaseId: "<lease-id>" },
     * });
     * const batchResp = await blobBatchClient.submitBatch(batchRequest);
     * console.log(batchResp.subResponsesSucceededCount);
     * ```
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
     *
     * @param batchRequest - A set of Delete or SetTier operations.
     * @param options -
     */ async submitBatch(batchRequest, options = {}) {
        if (!batchRequest || batchRequest.getSubRequests().size === 0) {
            throw new RangeError("Batch request should contain one or more sub requests.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions)=>{
            const batchRequestBody = batchRequest.getHttpRequestBody();
            // ServiceSubmitBatchResponseModel and ContainerSubmitBatchResponse are compatible for now.
            const rawBatchResponse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceOrContainerContext.submitBatch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8ByteLength"])(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, {
                ...updatedOptions
            }));
            // Parse the sub responses result, if logic reaches here(i.e. the batch request succeeded with status code 202).
            const batchResponseParser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchResponseParser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BatchResponseParser"](rawBatchResponse, batchRequest.getSubRequests());
            const responseSummary = await batchResponseParser.parseBatchResponse();
            const res = {
                _response: rawBatchResponse._response,
                contentType: rawBatchResponse.contentType,
                errorCode: rawBatchResponse.errorCode,
                requestId: rawBatchResponse.requestId,
                clientRequestId: rawBatchResponse.clientRequestId,
                version: rawBatchResponse.version,
                subResponses: responseSummary.subResponses,
                subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
                subResponsesFailedCount: responseSummary.subResponsesFailedCount
            };
            return res;
        });
    }
} //# sourceMappingURL=BlobBatchClient.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/ContainerClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ContainerClient",
    ()=>ContainerClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$proxyPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/policies/proxyPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/tokenCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/tracing.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/BlobSASSignatureValues.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobLeaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobLeaseClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Clients.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatchClient.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
class ContainerClient extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageClient"] {
    /**
     * containerContext provided by protocol layer.
     */ containerContext;
    _containerName;
    /**
     * The name of the container.
     */ get containerName() {
        return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, // Legacy, no fix for eslint error without breaking. Disable it for this interface.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ options){
        let pipeline;
        let url;
        options = options || {};
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPipelineLike"])(credentialOrPipelineOrContainerName)) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrContainerName;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] && credentialOrPipelineOrContainerName instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"] || credentialOrPipelineOrContainerName instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credentialOrPipelineOrContainerName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(credentialOrPipelineOrContainerName, options);
        } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"](), options);
        } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)
            const containerName = credentialOrPipelineOrContainerName;
            const extractedCreds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractConnectionStringParts"])(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"]) {
                    const sharedKeyCredential = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"](extractedCreds.accountName, extractedCreds.accountKey);
                    url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(extractedCreds.url, encodeURIComponent(containerName));
                    if (!options.proxyOptions) {
                        options.proxyOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$proxyPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultProxySettings"])(extractedCreds.proxyUri);
                    }
                    pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(sharedKeyCredential, options);
                } else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            } else if (extractedCreds.kind === "SASConnString") {
                url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
                pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"](), options);
            } else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        } else {
            throw new Error("Expecting non-empty strings for containerName parameter");
        }
        super(url, pipeline);
        this._containerName = this.getContainerNameFromUrl();
        this.containerContext = this.storageClientContext.container;
    }
    /**
     * Creates a new container under the specified account. If the container with
     * the same name already exists, the operation fails.
     * @see https://learn.microsoft.com/rest/api/storageservices/create-container
     * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
     *
     * @param options - Options to Container Create operation.
     *
     *
     * Example usage:
     *
     * ```ts snippet:ContainerClientCreate
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const createContainerResponse = await containerClient.create();
     * console.log("Container was created successfully", createContainerResponse.requestId);
     * ```
     */ async create(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-create", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.create(updatedOptions));
        });
    }
    /**
     * Creates a new container under the specified account. If the container with
     * the same name already exists, it is not changed.
     * @see https://learn.microsoft.com/rest/api/storageservices/create-container
     * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
     *
     * @param options -
     */ async createIfNotExists(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions)=>{
            try {
                const res = await this.create(updatedOptions);
                return {
                    succeeded: true,
                    ...res,
                    _response: res._response
                };
            } catch (e) {
                if (e.details?.errorCode === "ContainerAlreadyExists") {
                    return {
                        succeeded: false,
                        ...e.response?.parsedHeaders,
                        _response: e.response
                    };
                } else {
                    throw e;
                }
            }
        });
    }
    /**
     * Returns true if the Azure container resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing container might be deleted by other clients or
     * applications. Vice versa new containers with the same name might be added by other clients or
     * applications after this function completes.
     *
     * @param options -
     */ async exists(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-exists", options, async (updatedOptions)=>{
            try {
                await this.getProperties({
                    abortSignal: options.abortSignal,
                    tracingOptions: updatedOptions.tracingOptions
                });
                return true;
            } catch (e) {
                if (e.statusCode === 404) {
                    return false;
                }
                throw e;
            }
        });
    }
    /**
     * Creates a {@link BlobClient}
     *
     * @param blobName - A blob name
     * @returns A new BlobClient object for the given blob name.
     */ getBlobClient(blobName) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobClient"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(this.url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EscapePath"])(blobName)), this.pipeline);
    }
    /**
     * Creates an {@link AppendBlobClient}
     *
     * @param blobName - An append blob name
     */ getAppendBlobClient(blobName) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AppendBlobClient"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(this.url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EscapePath"])(blobName)), this.pipeline);
    }
    /**
     * Creates a {@link BlockBlobClient}
     *
     * @param blobName - A block blob name
     *
     *
     * Example usage:
     *
     * ```ts snippet:ClientsUpload
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
     *
     * const content = "Hello world!";
     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
     * ```
     */ getBlockBlobClient(blobName) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlockBlobClient"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(this.url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EscapePath"])(blobName)), this.pipeline);
    }
    /**
     * Creates a {@link PageBlobClient}
     *
     * @param blobName - A page blob name
     */ getPageBlobClient(blobName) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PageBlobClient"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(this.url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EscapePath"])(blobName)), this.pipeline);
    }
    /**
     * Returns all user-defined metadata and system properties for the specified
     * container. The data returned does not include the container's list of blobs.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-container-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @param options - Options to Container Get Properties operation.
     */ async getProperties(options = {}) {
        if (!options.conditions) {
            options.conditions = {};
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-getProperties", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.getProperties({
                abortSignal: options.abortSignal,
                ...options.conditions,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Marks the specified container for deletion. The container and any blobs
     * contained within it are later deleted during garbage collection.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-container
     *
     * @param options - Options to Container Delete operation.
     */ async delete(options = {}) {
        if (!options.conditions) {
            options.conditions = {};
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-delete", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.delete({
                abortSignal: options.abortSignal,
                leaseAccessConditions: options.conditions,
                modifiedAccessConditions: options.conditions,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Marks the specified container for deletion if it exists. The container and any blobs
     * contained within it are later deleted during garbage collection.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-container
     *
     * @param options - Options to Container Delete operation.
     */ async deleteIfExists(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions)=>{
            try {
                const res = await this.delete(updatedOptions);
                return {
                    succeeded: true,
                    ...res,
                    _response: res._response
                };
            } catch (e) {
                if (e.details?.errorCode === "ContainerNotFound") {
                    return {
                        succeeded: false,
                        ...e.response?.parsedHeaders,
                        _response: e.response
                    };
                }
                throw e;
            }
        });
    }
    /**
     * Sets one or more user-defined name-value pairs for the specified container.
     *
     * If no option provided, or no metadata defined in the parameter, the container
     * metadata will be removed.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/set-container-metadata
     *
     * @param metadata - Replace existing metadata with this value.
     *                            If no value provided the existing metadata will be removed.
     * @param options - Options to Container Set Metadata operation.
     */ async setMetadata(metadata, options = {}) {
        if (!options.conditions) {
            options.conditions = {};
        }
        if (options.conditions.ifUnmodifiedSince) {
            throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-setMetadata", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.setMetadata({
                abortSignal: options.abortSignal,
                leaseAccessConditions: options.conditions,
                metadata,
                modifiedAccessConditions: options.conditions,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Gets the permissions for the specified container. The permissions indicate
     * whether container data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-container-acl
     *
     * @param options - Options to Container Get Access Policy operation.
     */ async getAccessPolicy(options = {}) {
        if (!options.conditions) {
            options.conditions = {};
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.getAccessPolicy({
                abortSignal: options.abortSignal,
                leaseAccessConditions: options.conditions,
                tracingOptions: updatedOptions.tracingOptions
            }));
            const res = {
                _response: response._response,
                blobPublicAccess: response.blobPublicAccess,
                date: response.date,
                etag: response.etag,
                errorCode: response.errorCode,
                lastModified: response.lastModified,
                requestId: response.requestId,
                clientRequestId: response.clientRequestId,
                signedIdentifiers: [],
                version: response.version
            };
            for (const identifier of response){
                let accessPolicy = undefined;
                if (identifier.accessPolicy) {
                    accessPolicy = {
                        permissions: identifier.accessPolicy.permissions
                    };
                    if (identifier.accessPolicy.expiresOn) {
                        accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                    }
                    if (identifier.accessPolicy.startsOn) {
                        accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                    }
                }
                res.signedIdentifiers.push({
                    accessPolicy,
                    id: identifier.id
                });
            }
            return res;
        });
    }
    /**
     * Sets the permissions for the specified container. The permissions indicate
     * whether blobs in a container may be accessed publicly.
     *
     * When you set permissions for a container, the existing permissions are replaced.
     * If no access or containerAcl provided, the existing container ACL will be
     * removed.
     *
     * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-container-acl
     *
     * @param access - The level of public access to data in the container.
     * @param containerAcl - Array of elements each having a unique Id and details of the access policy.
     * @param options - Options to Container Set Access Policy operation.
     */ async setAccessPolicy(access, containerAcl, options = {}) {
        options.conditions = options.conditions || {};
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions)=>{
            const acl = [];
            for (const identifier of containerAcl || []){
                acl.push({
                    accessPolicy: {
                        expiresOn: identifier.accessPolicy.expiresOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(identifier.accessPolicy.expiresOn) : "",
                        permissions: identifier.accessPolicy.permissions,
                        startsOn: identifier.accessPolicy.startsOn ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(identifier.accessPolicy.startsOn) : ""
                    },
                    id: identifier.id
                });
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.setAccessPolicy({
                abortSignal: options.abortSignal,
                access,
                containerAcl: acl,
                leaseAccessConditions: options.conditions,
                modifiedAccessConditions: options.conditions,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Get a {@link BlobLeaseClient} that manages leases on the container.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new BlobLeaseClient object for managing leases on the container.
     */ getBlobLeaseClient(proposeLeaseId) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobLeaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobLeaseClient"](this, proposeLeaseId);
    }
    /**
     * Creates a new block blob, or updates the content of an existing block blob.
     *
     * Updating an existing block blob overwrites any existing metadata on the blob.
     * Partial updates are not supported; the content of the existing blob is
     * overwritten with the new content. To perform a partial update of a block blob's,
     * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.
     *
     * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},
     * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better
     * performance with concurrency uploading.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param blobName - Name of the block blob to create or update.
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to configure the Block Blob Upload operation.
     * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.
     */ async uploadBlockBlob(blobName, body, contentLength, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions)=>{
            const blockBlobClient = this.getBlockBlobClient(blobName);
            const response = await blockBlobClient.upload(body, contentLength, updatedOptions);
            return {
                blockBlobClient,
                response
            };
        });
    }
    /**
     * Marks the specified blob or snapshot for deletion. The blob is later deleted
     * during garbage collection. Note that in order to delete a blob, you must delete
     * all of its snapshots. You can delete both at the same time with the Delete
     * Blob operation.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
     *
     * @param blobName -
     * @param options - Options to Blob Delete operation.
     * @returns Block blob deletion response data.
     */ async deleteBlob(blobName, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-deleteBlob", options, async (updatedOptions)=>{
            let blobClient = this.getBlobClient(blobName);
            if (options.versionId) {
                blobClient = blobClient.withVersion(options.versionId);
            }
            return blobClient.delete(updatedOptions);
        });
    }
    /**
     * listBlobFlatSegment returns a single segment of blobs starting from the
     * specified Marker. Use an empty Marker to start enumeration from the beginning.
     * After getting a segment, process it, and then call listBlobsFlatSegment again
     * (passing the the previously-returned Marker) to get the next segment.
     * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Container List Blob Flat Segment operation.
     */ async listBlobFlatSegment(marker, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.listBlobFlatSegment({
                marker,
                ...options,
                tracingOptions: updatedOptions.tracingOptions
            }));
            const wrappedResponse = {
                ...response,
                _response: {
                    ...response._response,
                    parsedBody: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ConvertInternalResponseOfListBlobFlat"])(response._response.parsedBody)
                },
                segment: {
                    ...response.segment,
                    blobItems: response.segment.blobItems.map((blobItemInternal)=>{
                        const blobItem = {
                            ...blobItemInternal,
                            name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobNameToString"])(blobItemInternal.name),
                            tags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toTags"])(blobItemInternal.blobTags),
                            objectReplicationSourceProperties: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseObjectReplicationRecord"])(blobItemInternal.objectReplicationMetadata)
                        };
                        return blobItem;
                    })
                }
            };
            return wrappedResponse;
        });
    }
    /**
     * listBlobHierarchySegment returns a single segment of blobs starting from
     * the specified Marker. Use an empty Marker to start enumeration from the
     * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment
     * again (passing the the previously-returned Marker) to get the next segment.
     * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Container List Blob Hierarchy Segment operation.
     */ async listBlobHierarchySegment(delimiter, marker, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.listBlobHierarchySegment(delimiter, {
                marker,
                ...options,
                tracingOptions: updatedOptions.tracingOptions
            }));
            const wrappedResponse = {
                ...response,
                _response: {
                    ...response._response,
                    parsedBody: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ConvertInternalResponseOfListBlobHierarchy"])(response._response.parsedBody)
                },
                segment: {
                    ...response.segment,
                    blobItems: response.segment.blobItems.map((blobItemInternal)=>{
                        const blobItem = {
                            ...blobItemInternal,
                            name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobNameToString"])(blobItemInternal.name),
                            tags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toTags"])(blobItemInternal.blobTags),
                            objectReplicationSourceProperties: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseObjectReplicationRecord"])(blobItemInternal.objectReplicationMetadata)
                        };
                        return blobItem;
                    }),
                    blobPrefixes: response.segment.blobPrefixes?.map((blobPrefixInternal)=>{
                        const blobPrefix = {
                            ...blobPrefixInternal,
                            name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobNameToString"])(blobPrefixInternal.name)
                        };
                        return blobPrefix;
                    })
                }
            };
            return wrappedResponse;
        });
    }
    /**
     * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list blobs operation.
     */ async *listSegments(marker, options = {}) {
        let listBlobsFlatSegmentResponse;
        if (!!marker || marker === undefined) {
            do {
                listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options);
                marker = listBlobsFlatSegmentResponse.continuationToken;
                yield await listBlobsFlatSegmentResponse;
            }while (marker)
        }
    }
    /**
     * Returns an AsyncIterableIterator of {@link BlobItem} objects
     *
     * @param options - Options to list blobs operation.
     */ async *listItems(options = {}) {
        let marker;
        for await (const listBlobsFlatSegmentResponse of this.listSegments(marker, options)){
            yield* listBlobsFlatSegmentResponse.segment.blobItems;
        }
    }
    /**
     * Returns an async iterable iterator to list all the blobs
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * ```ts snippet:ReadmeSampleListBlobs_Multiple
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * const blobs = containerClient.listBlobsFlat();
     * for await (const blob of blobs) {
     *   console.log(`Blob ${i++}: ${blob.name}`);
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = containerClient.listBlobsFlat();
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Blob ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {
     *   for (const blob of page.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 blob names
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list blobs.
     * @returns An asyncIterableIterator that supports paging.
     */ listBlobsFlat(options = {}) {
        const include = [];
        if (options.includeCopy) {
            include.push("copy");
        }
        if (options.includeDeleted) {
            include.push("deleted");
        }
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        if (options.includeVersions) {
            include.push("versions");
        }
        if (options.includeUncommitedBlobs) {
            include.push("uncommittedblobs");
        }
        if (options.includeTags) {
            include.push("tags");
        }
        if (options.includeDeletedWithVersions) {
            include.push("deletedwithversions");
        }
        if (options.includeImmutabilityPolicy) {
            include.push("immutabilitypolicy");
        }
        if (options.includeLegalHold) {
            include.push("legalhold");
        }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        const updatedOptions = {
            ...options,
            ...include.length > 0 ? {
                include: include
            } : {}
        };
        // AsyncIterableIterator to iterate over blobs
        const iter = this.listItems(updatedOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */ next () {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */ byPage: (settings = {})=>{
                return this.listSegments(settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...updatedOptions
                });
            }
        };
    }
    /**
     * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list blobs operation.
     */ async *listHierarchySegments(delimiter, marker, options = {}) {
        let listBlobsHierarchySegmentResponse;
        if (!!marker || marker === undefined) {
            do {
                listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(delimiter, marker, options);
                marker = listBlobsHierarchySegmentResponse.continuationToken;
                yield await listBlobsHierarchySegmentResponse;
            }while (marker)
        }
    }
    /**
     * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param options - Options to list blobs operation.
     */ async *listItemsByHierarchy(delimiter, options = {}) {
        let marker;
        for await (const listBlobsHierarchySegmentResponse of this.listHierarchySegments(delimiter, marker, options)){
            const segment = listBlobsHierarchySegmentResponse.segment;
            if (segment.blobPrefixes) {
                for (const prefix of segment.blobPrefixes){
                    yield {
                        kind: "prefix",
                        ...prefix
                    };
                }
            }
            for (const blob of segment.blobItems){
                yield {
                    kind: "blob",
                    ...blob
                };
            }
        }
    }
    /**
     * Returns an async iterable iterator to list all the blobs by hierarchy.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.
     *
     * ```ts snippet:ReadmeSampleListBlobsByHierarchy
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * const blobs = containerClient.listBlobsByHierarchy("/");
     * for await (const blob of blobs) {
     *   if (blob.kind === "prefix") {
     *     console.log(`\tBlobPrefix: ${blob.name}`);
     *   } else {
     *     console.log(`\tBlobItem: name - ${blob.name}`);
     *   }
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = containerClient.listBlobsByHierarchy("/");
     * let { value, done } = await iter.next();
     * while (!done) {
     *   if (value.kind === "prefix") {
     *     console.log(`\tBlobPrefix: ${value.name}`);
     *   } else {
     *     console.log(`\tBlobItem: name - ${value.name}`);
     *   }
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of containerClient.listBlobsByHierarchy("/").byPage({ maxPageSize: 20 })) {
     *   const segment = page.segment;
     *   if (segment.blobPrefixes) {
     *     for (const prefix of segment.blobPrefixes) {
     *       console.log(`\tBlobPrefix: ${prefix.name}`);
     *     }
     *   }
     *   for (const blob of page.segment.blobItems) {
     *     console.log(`\tBlobItem: name - ${blob.name}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = containerClient.listBlobsByHierarchy("/").byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.blobPrefixes) {
     *   for (const prefix of response.blobPrefixes) {
     *     console.log(`\tBlobPrefix: ${prefix.name}`);
     *   }
     * }
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`\tBlobItem: name - ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = containerClient
     *   .listBlobsByHierarchy("/")
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 blob names
     * if (response.blobPrefixes) {
     *   for (const prefix of response.blobPrefixes) {
     *     console.log(`\tBlobPrefix: ${prefix.name}`);
     *   }
     * }
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param options - Options to list blobs operation.
     */ listBlobsByHierarchy(delimiter, options = {}) {
        if (delimiter === "") {
            throw new RangeError("delimiter should contain one or more characters");
        }
        const include = [];
        if (options.includeCopy) {
            include.push("copy");
        }
        if (options.includeDeleted) {
            include.push("deleted");
        }
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        if (options.includeVersions) {
            include.push("versions");
        }
        if (options.includeUncommitedBlobs) {
            include.push("uncommittedblobs");
        }
        if (options.includeTags) {
            include.push("tags");
        }
        if (options.includeDeletedWithVersions) {
            include.push("deletedwithversions");
        }
        if (options.includeImmutabilityPolicy) {
            include.push("immutabilitypolicy");
        }
        if (options.includeLegalHold) {
            include.push("legalhold");
        }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        const updatedOptions = {
            ...options,
            ...include.length > 0 ? {
                include: include
            } : {}
        };
        // AsyncIterableIterator to iterate over blob prefixes and blobs
        const iter = this.listItemsByHierarchy(delimiter, updatedOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */ async next () {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */ byPage: (settings = {})=>{
                return this.listHierarchySegments(delimiter, settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...updatedOptions
                });
            }
        };
    }
    /**
     * The Filter Blobs operation enables callers to list blobs in the container whose tags
     * match a given search expression.
     *
     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                        The given expression must evaluate to true for a blob to be returned in the results.
     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */ async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.filterBlobs({
                abortSignal: options.abortSignal,
                where: tagFilterSqlExpression,
                marker,
                maxPageSize: options.maxPageSize,
                tracingOptions: updatedOptions.tracingOptions
            }));
            const wrappedResponse = {
                ...response,
                _response: response._response,
                blobs: response.blobs.map((blob)=>{
                    let tagValue = "";
                    if (blob.tags?.blobTagSet.length === 1) {
                        tagValue = blob.tags.blobTagSet[0].value;
                    }
                    return {
                        ...blob,
                        tags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toTags"])(blob.tags),
                        tagValue
                    };
                })
            };
            return wrappedResponse;
        });
    }
    /**
     * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */ async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
        let response;
        if (!!marker || marker === undefined) {
            do {
                response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
                response.blobs = response.blobs || [];
                marker = response.continuationToken;
                yield response;
            }while (marker)
        }
    }
    /**
     * Returns an AsyncIterableIterator for blobs.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to findBlobsByTagsItems.
     */ async *findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
        let marker;
        for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)){
            yield* segment.blobs;
        }
    }
    /**
     * Returns an async iterable iterator to find all blobs with specified tag
     * under the specified container.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * Example using `for await` syntax:
     *
     * ```ts snippet:ReadmeSampleFindBlobsByTags
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * for await (const blob of containerClient.findBlobsByTags("tagkey='tagvalue'")) {
     *   console.log(`Blob ${i++}: ${blob.name}`);
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = containerClient.findBlobsByTags("tagkey='tagvalue'");
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Blob ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of containerClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const blob of page.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = containerClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = containerClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to find blobs by tags.
     */ findBlobsByTags(tagFilterSqlExpression, options = {}) {
        // AsyncIterableIterator to iterate over blobs
        const listSegmentOptions = {
            ...options
        };
        const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */ next () {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */ byPage: (settings = {})=>{
                return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...listSegmentOptions
                });
            }
        };
    }
    /**
     * The Get Account Information operation returns the sku name and account kind
     * for the specified account.
     * The Get Account Information operation is available on service versions beginning
     * with version 2018-03-28.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
     *
     * @param options - Options to the Service Get Account Info operation.
     * @returns Response data for the Service Get Account Info operation.
     */ async getAccountInfo(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.containerContext.getAccountInfo({
                abortSignal: options.abortSignal,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    getContainerNameFromUrl() {
        let containerName;
        try {
            //  URL may look like the following
            // "https://myaccount.blob.core.windows.net/mycontainer?sasString";
            // "https://myaccount.blob.core.windows.net/mycontainer";
            // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername`
            // http://localhost:10001/devstoreaccount1/containername
            const parsedUrl = new URL(this.url);
            if (parsedUrl.hostname.split(".")[1] === "blob") {
                // "https://myaccount.blob.core.windows.net/containername".
                // "https://customdomain.com/containername".
                // .getPath() -> /containername
                containerName = parsedUrl.pathname.split("/")[1];
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isIpEndpointStyle"])(parsedUrl)) {
                // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername
                // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername
                // .getPath() -> /devstoreaccount1/containername
                containerName = parsedUrl.pathname.split("/")[2];
            } else {
                // "https://customdomain.com/containername".
                // .getPath() -> /containername
                containerName = parsedUrl.pathname.split("/")[1];
            }
            // decode the encoded containerName - to get all the special characters that might be present in it
            containerName = decodeURIComponent(containerName);
            if (!containerName) {
                throw new Error("Provided containerName is invalid.");
            }
            return containerName;
        } catch (error) {
            throw new Error("Unable to extract containerName with provided information.");
        }
    }
    /**
     * Only available for ContainerClient constructed with a shared key credential.
     *
     * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */ generateSasUrl(options) {
        return new Promise((resolve)=>{
            if (!(this.credential instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"])) {
                throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
            }
            const sas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateBlobSASQueryParameters"])({
                containerName: this._containerName,
                ...options
            }, this.credential).toString();
            resolve((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLQuery"])(this.url, sas));
        });
    }
    /**
     * Only available for ContainerClient constructed with a shared key credential.
     *
     * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
     * based on the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */ /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ generateSasStringToSign(options) {
        if (!(this.credential instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"])) {
            throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateBlobSASQueryParametersInternal"])({
            containerName: this._containerName,
            ...options
        }, this.credential).stringToSign;
    }
    /**
     * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the input user delegation key.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */ generateUserDelegationSasUrl(options, userDelegationKey) {
        return new Promise((resolve)=>{
            const sas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateBlobSASQueryParameters"])({
                containerName: this._containerName,
                ...options
            }, userDelegationKey, this.accountName).toString();
            resolve((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLQuery"])(this.url, sas));
        });
    }
    /**
     * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
     * based on the client properties and parameters passed in. The SAS is signed by the input user delegation key.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */ generateUserDelegationSasStringToSign(options, userDelegationKey) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateBlobSASQueryParametersInternal"])({
            containerName: this._containerName,
            ...options
        }, userDelegationKey, this.accountName).stringToSign;
    }
    /**
     * Creates a BlobBatchClient object to conduct batch operations.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
     *
     * @returns A new BlobBatchClient object for this container.
     */ getBlobBatchClient() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobBatchClient"](this.url, this.pipeline);
    }
} //# sourceMappingURL=ContainerClient.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BlobServiceClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BlobServiceClient",
    ()=>BlobServiceClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-auth/dist/esm/tokenCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$proxyPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/policies/proxyPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-util/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$ContainerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/ContainerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/utils.common.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/utils/tracing.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatchClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASSignatureValues.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASServices$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASServices.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class BlobServiceClient extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageClient"] {
    /**
     * serviceContext provided by protocol layer.
     */ serviceContext;
    /**
     *
     * Creates an instance of BlobServiceClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Optional. Options to configure the HTTP pipeline.
     */ static fromConnectionString(connectionString, // Legacy, no fix for eslint error without breaking. Disable it for this interface.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ options) {
        options = options || {};
        const extractedCreds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extractConnectionStringParts"])(connectionString);
        if (extractedCreds.kind === "AccountConnString") {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"]) {
                const sharedKeyCredential = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"](extractedCreds.accountName, extractedCreds.accountKey);
                if (!options.proxyOptions) {
                    options.proxyOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$policies$2f$proxyPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDefaultProxySettings"])(extractedCreds.proxyUri);
                }
                const pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(sharedKeyCredential, options);
                return new BlobServiceClient(extractedCreds.url, pipeline);
            } else {
                throw new Error("Account connection string is only supported in Node.js environment");
            }
        } else if (extractedCreds.kind === "SASConnString") {
            const pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"](), options);
            return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
        } else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
    }
    constructor(url, credentialOrPipeline, // Legacy, no fix for eslint error without breaking. Disable it for this interface.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/ options){
        let pipeline;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPipelineLike"])(credentialOrPipeline)) {
            pipeline = credentialOrPipeline;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNodeLike"] && credentialOrPipeline instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"] || credentialOrPipeline instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$auth$2f$dist$2f$esm$2f$tokenCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTokenCredential"])(credentialOrPipeline)) {
            pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(credentialOrPipeline, options);
        } else {
            // The second parameter is undefined. Use anonymous credential
            pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["newPipeline"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AnonymousCredential"](), options);
        }
        super(url, pipeline);
        this.serviceContext = this.storageClientContext.service;
    }
    /**
     * Creates a {@link ContainerClient} object
     *
     * @param containerName - A container name
     * @returns A new ContainerClient object for the given container name.
     *
     * Example usage:
     *
     * ```ts snippet:BlobServiceClientGetContainerClient
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerClient = blobServiceClient.getContainerClient("<container name>");
     * ```
     */ getContainerClient(containerName) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$ContainerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ContainerClient"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLPath"])(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    /**
     * Create a Blob container. @see https://learn.microsoft.com/rest/api/storageservices/create-container
     *
     * @param containerName - Name of the container to create.
     * @param options - Options to configure Container Create operation.
     * @returns Container creation response and the corresponding container client.
     */ async createContainer(containerName, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-createContainer", options, async (updatedOptions)=>{
            const containerClient = this.getContainerClient(containerName);
            const containerCreateResponse = await containerClient.create(updatedOptions);
            return {
                containerClient,
                containerCreateResponse
            };
        });
    }
    /**
     * Deletes a Blob container.
     *
     * @param containerName - Name of the container to delete.
     * @param options - Options to configure Container Delete operation.
     * @returns Container deletion response.
     */ async deleteContainer(containerName, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions)=>{
            const containerClient = this.getContainerClient(containerName);
            return containerClient.delete(updatedOptions);
        });
    }
    /**
     * Restore a previously deleted Blob container.
     * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.
     *
     * @param deletedContainerName - Name of the previously deleted container.
     * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.
     * @param options - Options to configure Container Restore operation.
     * @returns Container deletion response.
     */ async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions)=>{
            const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);
            // Hack to access a protected member.
            const containerContext = containerClient["storageClientContext"].container;
            const containerUndeleteResponse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await containerContext.restore({
                deletedContainerName,
                deletedContainerVersion,
                tracingOptions: updatedOptions.tracingOptions
            }));
            return {
                containerClient,
                containerUndeleteResponse
            };
        });
    }
    /**
     * Gets the properties of a storage accounts Blob service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-properties
     *
     * @param options - Options to the Service Get Properties operation.
     * @returns Response data for the Service Get Properties operation.
     */ async getProperties(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-getProperties", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.getProperties({
                abortSignal: options.abortSignal,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Sets properties for a storage accounts Blob service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-service-properties
     *
     * @param properties -
     * @param options - Options to the Service Set Properties operation.
     * @returns Response data for the Service Set Properties operation.
     */ async setProperties(properties, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-setProperties", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.setProperties(properties, {
                abortSignal: options.abortSignal,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Retrieves statistics related to replication for the Blob service. It is only
     * available on the secondary location endpoint when read-access geo-redundant
     * replication is enabled for the storage account.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-stats
     *
     * @param options - Options to the Service Get Statistics operation.
     * @returns Response data for the Service Get Statistics operation.
     */ async getStatistics(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.getStatistics({
                abortSignal: options.abortSignal,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * The Get Account Information operation returns the sku name and account kind
     * for the specified account.
     * The Get Account Information operation is available on service versions beginning
     * with version 2018-03-28.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
     *
     * @param options - Options to the Service Get Account Info operation.
     * @returns Response data for the Service Get Account Info operation.
     */ async getAccountInfo(options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.getAccountInfo({
                abortSignal: options.abortSignal,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * Returns a list of the containers under the specified account.
     * @see https://learn.microsoft.com/rest/api/storageservices/list-containers2
     *
     * @param marker - A string value that identifies the portion of
     *                        the list of containers to be returned with the next listing operation. The
     *                        operation returns the continuationToken value within the response body if the
     *                        listing operation did not return all containers remaining to be listed
     *                        with the current page. The continuationToken value can be used as the value for
     *                        the marker parameter in a subsequent call to request the next page of list
     *                        items. The marker value is opaque to the client.
     * @param options - Options to the Service List Container Segment operation.
     * @returns Response data for the Service List Container Segment operation.
     */ async listContainersSegment(marker, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.listContainersSegment({
                abortSignal: options.abortSignal,
                marker,
                ...options,
                include: typeof options.include === "string" ? [
                    options.include
                ] : options.include,
                tracingOptions: updatedOptions.tracingOptions
            }));
        });
    }
    /**
     * The Filter Blobs operation enables callers to list blobs across all containers whose tags
     * match a given search expression. Filter blobs searches across all containers within a
     * storage account but can be scoped within the expression to a single container.
     *
     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                        The given expression must evaluate to true for a blob to be returned in the results.
     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */ async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.filterBlobs({
                abortSignal: options.abortSignal,
                where: tagFilterSqlExpression,
                marker,
                maxPageSize: options.maxPageSize,
                tracingOptions: updatedOptions.tracingOptions
            }));
            const wrappedResponse = {
                ...response,
                _response: response._response,
                blobs: response.blobs.map((blob)=>{
                    let tagValue = "";
                    if (blob.tags?.blobTagSet.length === 1) {
                        tagValue = blob.tags.blobTagSet[0].value;
                    }
                    return {
                        ...blob,
                        tags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toTags"])(blob.tags),
                        tagValue
                    };
                })
            };
            return wrappedResponse;
        });
    }
    /**
     * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */ async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
        let response;
        if (!!marker || marker === undefined) {
            do {
                response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
                response.blobs = response.blobs || [];
                marker = response.continuationToken;
                yield response;
            }while (marker)
        }
    }
    /**
     * Returns an AsyncIterableIterator for blobs.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to findBlobsByTagsItems.
     */ async *findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
        let marker;
        for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)){
            yield* segment.blobs;
        }
    }
    /**
     * Returns an async iterable iterator to find all blobs with specified tag
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-properties
     *
     * ```ts snippet:BlobServiceClientFindBlobsByTags
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * // Use for await to iterate the blobs
     * let i = 1;
     * for await (const blob of blobServiceClient.findBlobsByTags("tagkey='tagvalue'")) {
     *   console.log(`Blob ${i++}: ${blob.name}`);
     * }
     *
     * // Use iter.next() to iterate the blobs
     * i = 1;
     * const iter = blobServiceClient.findBlobsByTags("tagkey='tagvalue'");
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Blob ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Use byPage() to iterate the blobs
     * i = 1;
     * for await (const page of blobServiceClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const blob of page.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     *
     * // Use paging with a marker
     * i = 1;
     * let iterator = blobServiceClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = blobServiceClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to find blobs by tags.
     */ findBlobsByTags(tagFilterSqlExpression, options = {}) {
        // AsyncIterableIterator to iterate over blobs
        const listSegmentOptions = {
            ...options
        };
        const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */ next () {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */ byPage: (settings = {})=>{
                return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...listSegmentOptions
                });
            }
        };
    }
    /**
     * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses
     *
     * @param marker - A string value that identifies the portion of
     *                        the list of containers to be returned with the next listing operation. The
     *                        operation returns the continuationToken value within the response body if the
     *                        listing operation did not return all containers remaining to be listed
     *                        with the current page. The continuationToken value can be used as the value for
     *                        the marker parameter in a subsequent call to request the next page of list
     *                        items. The marker value is opaque to the client.
     * @param options - Options to list containers operation.
     */ async *listSegments(marker, options = {}) {
        let listContainersSegmentResponse;
        if (!!marker || marker === undefined) {
            do {
                listContainersSegmentResponse = await this.listContainersSegment(marker, options);
                listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
                marker = listContainersSegmentResponse.continuationToken;
                yield await listContainersSegmentResponse;
            }while (marker)
        }
    }
    /**
     * Returns an AsyncIterableIterator for Container Items
     *
     * @param options - Options to list containers operation.
     */ async *listItems(options = {}) {
        let marker;
        for await (const segment of this.listSegments(marker, options)){
            yield* segment.containerItems;
        }
    }
    /**
     * Returns an async iterable iterator to list all the containers
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the containers in pages.
     *
     * ```ts snippet:BlobServiceClientListContainers
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * // Use for await to iterate the containers
     * let i = 1;
     * for await (const container of blobServiceClient.listContainers()) {
     *   console.log(`Container ${i++}: ${container.name}`);
     * }
     *
     * // Use iter.next() to iterate the containers
     * i = 1;
     * const iter = blobServiceClient.listContainers();
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Container ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Use byPage() to iterate the containers
     * i = 1;
     * for await (const page of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {
     *   for (const container of page.containerItems) {
     *     console.log(`Container ${i++}: ${container.name}`);
     *   }
     * }
     *
     * // Use paging with a marker
     * i = 1;
     * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 container names
     * if (response.containerItems) {
     *   for (const container of response.containerItems) {
     *     console.log(`Container ${i++}: ${container.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = blobServiceClient
     *   .listContainers()
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 container names
     * if (response.containerItems) {
     *   for (const container of response.containerItems) {
     *     console.log(`Container ${i++}: ${container.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list containers.
     * @returns An asyncIterableIterator that supports paging.
     */ listContainers(options = {}) {
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        const include = [];
        if (options.includeDeleted) {
            include.push("deleted");
        }
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSystem) {
            include.push("system");
        }
        // AsyncIterableIterator to iterate over containers
        const listSegmentOptions = {
            ...options,
            ...include.length > 0 ? {
                include
            } : {}
        };
        const iter = this.listItems(listSegmentOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */ next () {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */ byPage: (settings = {})=>{
                return this.listSegments(settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...listSegmentOptions
                });
            }
        };
    }
    /**
     * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).
     *
     * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
     * bearer token authentication.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-user-delegation-key
     *
     * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time
     * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time
     */ async getUserDelegationKey(startsOn, expiresOn, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$tracing$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tracingClient"].withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions)=>{
            const response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertResponse"])(await this.serviceContext.getUserDelegationKey({
                startsOn: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(startsOn, false),
                expiresOn: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["truncatedISO8061Date"])(expiresOn, false)
            }, {
                abortSignal: options.abortSignal,
                tracingOptions: updatedOptions.tracingOptions
            }));
            const userDelegationKey = {
                signedObjectId: response.signedObjectId,
                signedTenantId: response.signedTenantId,
                signedStartsOn: new Date(response.signedStartsOn),
                signedExpiresOn: new Date(response.signedExpiresOn),
                signedService: response.signedService,
                signedVersion: response.signedVersion,
                value: response.value
            };
            const res = {
                _response: response._response,
                requestId: response.requestId,
                clientRequestId: response.clientRequestId,
                version: response.version,
                date: response.date,
                errorCode: response.errorCode,
                ...userDelegationKey
            };
            return res;
        });
    }
    /**
     * Creates a BlobBatchClient object to conduct batch operations.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
     *
     * @returns A new BlobBatchClient object for this service.
     */ getBlobBatchClient() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobBatchClient"](this.url, this.pipeline);
    }
    /**
     * Only available for BlobServiceClient constructed with a shared key credential.
     *
     * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */ generateAccountSasUrl(expiresOn, permissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASPermissions"].parse("r"), resourceTypes = "sco", options = {}) {
        if (!(this.credential instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"])) {
            throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
        }
        if (expiresOn === undefined) {
            const now = new Date();
            expiresOn = new Date(now.getTime() + 3600 * 1000);
        }
        const sas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateAccountSASQueryParameters"])({
            permissions,
            expiresOn,
            resourceTypes,
            services: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASServices$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASServices"].parse("b").toString(),
            ...options
        }, this.credential).toString();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$utils$2f$utils$2e$common$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["appendToURLQuery"])(this.url, sas);
    }
    /**
     * Only available for BlobServiceClient constructed with a shared key credential.
     *
     * Generates string to sign for a Blob account Shared Access Signature (SAS) URI based on
     * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */ generateSasStringToSign(expiresOn, permissions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASPermissions"].parse("r"), resourceTypes = "sco", options = {}) {
        if (!(this.credential instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageSharedKeyCredential"])) {
            throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
        }
        if (expiresOn === undefined) {
            const now = new Date();
            expiresOn = new Date(now.getTime() + 3600 * 1000);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateAccountSASQueryParametersInternal"])({
            permissions,
            expiresOn,
            resourceTypes,
            services: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASServices$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AccountSASServices"].parse("b").toString(),
            ...options
        }, this.credential).stringToSign;
    }
} //# sourceMappingURL=BlobServiceClient.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/BatchResponse.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=BatchResponse.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/generatedModels.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** Known values of {@link EncryptionAlgorithmType} that the service accepts. */ __turbopack_context__.s([
    "KnownEncryptionAlgorithmType",
    ()=>KnownEncryptionAlgorithmType
]);
var KnownEncryptionAlgorithmType;
(function(KnownEncryptionAlgorithmType) {
    KnownEncryptionAlgorithmType["AES256"] = "AES256";
})(KnownEncryptionAlgorithmType || (KnownEncryptionAlgorithmType = {})); //# sourceMappingURL=generatedModels.js.map
}),
"[project]/node_modules/@azure/storage-blob/dist/esm/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$core$2d$rest$2d$pipeline$2f$dist$2f$esm$2f$restError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/core-rest-pipeline/dist/esm/restError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobServiceClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobServiceClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Clients.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$ContainerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/ContainerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobLeaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobLeaseClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASResourceTypes$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASResourceTypes.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASServices$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASServices.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$AccountSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/AccountSASSignatureValues.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BlobBatchClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BlobBatchClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$BatchResponse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/BatchResponse.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/BlobSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$BlobSASSignatureValues$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/BlobSASSignatureValues.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageBrowserPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageBrowserPolicyFactory.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$ContainerSASPermissions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/ContainerSASPermissions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$AnonymousCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/AnonymousCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$Credential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/Credential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$credentials$2f$StorageSharedKeyCredential$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/credentials/StorageSharedKeyCredential.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$models$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/models.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$Pipeline$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/Pipeline.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$StorageRetryPolicyFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/StorageRetryPolicyFactory.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$RequestPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/RequestPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$AnonymousCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/AnonymousCredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$CredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/CredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$policies$2f$StorageSharedKeyCredentialPolicy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/policies/StorageSharedKeyCredentialPolicy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$sas$2f$SASQueryParameters$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/sas/SASQueryParameters.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$generatedModels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/generatedModels.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$azure$2f$storage$2d$blob$2f$dist$2f$esm$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@azure/storage-blob/dist/esm/log.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}),
];

//# sourceMappingURL=node_modules_%40azure_storage-blob_dist_esm_881444fb._.js.map