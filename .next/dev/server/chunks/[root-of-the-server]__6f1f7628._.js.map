{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\n// Create Prisma client instance\r\nconst createPrismaClient = () => {\r\n  return new PrismaClient({\r\n    log: ['query', 'info', 'warn', 'error'], // Enable detailed logging\r\n  })\r\n}\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined\r\n}\r\n\r\n// Use the global instance in development to prevent exceeding connection limits\r\nconst client = globalThis.prisma || createPrismaClient()\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = client\r\n\r\nexport default client"],"names":[],"mappings":";;;;AAAA;;AAEA,gCAAgC;AAChC,MAAM,qBAAqB;IACzB,OAAO,IAAI,6IAAY,CAAC;QACtB,KAAK;YAAC;YAAS;YAAQ;YAAQ;SAAQ;IACzC;AACF;AAOA,gFAAgF;AAChF,MAAM,SAAS,WAAW,MAAM,IAAI;AACpC,wCAA2C,WAAW,MAAM,GAAG;uCAEhD"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/colivara-error-handler.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport ColivaraService from './colivara-service';\r\nimport { Document } from '@/lib/api/types';\r\n\r\nexport enum ColivaraErrorType {\r\n  API_UNAVAILABLE = 'API_UNAVAILABLE',\r\n  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',\r\n  AUTHENTICATION_FAILED = 'AUTHENTICATION_FAILED',\r\n  PROCESSING_FAILED = 'PROCESSING_FAILED',\r\n  TIMEOUT = 'TIMEOUT',\r\n  INVALID_RESPONSE = 'INVALID_RESPONSE',\r\n  NETWORK_ERROR = 'NETWORK_ERROR',\r\n  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',\r\n}\r\n\r\nexport class ColivaraError extends Error {\r\n  constructor(\r\n    public type: ColivaraErrorType,\r\n    message: string,\r\n    public originalError?: any,\r\n    public status?: number\r\n  ) {\r\n    super(message);\r\n    this.name = 'ColivaraError';\r\n  }\r\n}\r\n\r\nexport interface ErrorHandlingOptions {\r\n  maxRetries?: number;\r\n  retryDelay?: number;\r\n  fallbackToTraditional?: boolean;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface ProcessingResult {\r\n  success: boolean;\r\n  error?: ColivaraError;\r\n  fallbackUsed?: boolean;\r\n  data?: any;\r\n}\r\n\r\nexport class ColivaraErrorHandler {\r\n  private static instance: ColivaraErrorHandler;\r\n  private circuitBreakerOpen = false;\r\n  private lastFailureTime: Date | null = null;\r\n  private failureCount = 0;\r\n  private maxFailures = 5;\r\n  private resetTimeout = 300000; // 5 minutes\r\n  \r\n  private constructor() {}\r\n\r\n  public static getInstance(): ColivaraErrorHandler {\r\n    if (!ColivaraErrorHandler.instance) {\r\n      ColivaraErrorHandler.instance = new ColivaraErrorHandler();\r\n    }\r\n    return ColivaraErrorHandler.instance;\r\n  }\r\n\r\n  async handleColivaraOperation<T>(\r\n    operation: () => Promise<T>,\r\n    options: ErrorHandlingOptions = {}\r\n  ): Promise<{ result: T | null; error?: ColivaraError; fallbackUsed: boolean }> {\r\n    const { \r\n      maxRetries = 3, \r\n      retryDelay = 1000, \r\n      fallbackToTraditional = true,\r\n      timeout = 30000 \r\n    } = options;\r\n\r\n    // Check circuit breaker status\r\n    if (this.isCircuitBreakerOpen()) {\r\n      if (fallbackToTraditional) {\r\n        console.warn('Circuit breaker is open, using fallback to traditional processing');\r\n        return { result: null, error: new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'Service temporarily unavailable'), fallbackUsed: true };\r\n      } else {\r\n        throw new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'Service temporarily unavailable due to circuit breaker');\r\n      }\r\n    }\r\n\r\n    let lastError: ColivaraError | undefined;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        // Add timeout to the operation\r\n        const result = await this.withTimeout(operation(), timeout);\r\n        this.resetCircuitBreaker(); // Reset on success\r\n        return { result, error: undefined, fallbackUsed: false };\r\n      } catch (error) {\r\n        lastError = this.convertErrorToColivaraError(error);\r\n\r\n        // Log the error\r\n        console.error(`Colivara operation failed on attempt ${attempt + 1}:`, lastError);\r\n\r\n        // Check if this is a permanent error that shouldn't be retried\r\n        if (lastError && this.isPermanentError(lastError)) {\r\n          break;\r\n        }\r\n\r\n        // Update circuit breaker on failure\r\n        this.updateCircuitBreaker();\r\n\r\n        // If this isn't the last attempt, wait before retrying\r\n        if (attempt < maxRetries) {\r\n          await this.delay(retryDelay * Math.pow(2, attempt)); // Exponential backoff\r\n        }\r\n      }\r\n    }\r\n\r\n    // If we've exhausted retries and fallback is enabled\r\n    if (fallbackToTraditional) {\r\n      console.warn('Using fallback after Colivara operation failed:', lastError?.message);\r\n      return { result: null, error: lastError, fallbackUsed: true };\r\n    }\r\n\r\n    // If fallback is not enabled, throw the last error\r\n    throw lastError;\r\n  }\r\n\r\n  private async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<T>((_, reject) => {\r\n        setTimeout(() => {\r\n          reject(new ColivaraError(ColivaraErrorType.TIMEOUT, `Operation timed out after ${timeoutMs}ms`));\r\n        }, timeoutMs);\r\n      })\r\n    ]);\r\n  }\r\n\r\n  public convertErrorToColivaraError(error: any): ColivaraError {\r\n    if (error instanceof ColivaraError) {\r\n      return error;\r\n    }\r\n\r\n    // Check for specific error types\r\n    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\r\n      return new ColivaraError(ColivaraErrorType.NETWORK_ERROR, 'Network connection failed', error);\r\n    }\r\n\r\n    if (error.status === 429) {\r\n      return new ColivaraError(ColivaraErrorType.RATE_LIMIT_EXCEEDED, 'Rate limit exceeded', error, error.status);\r\n    }\r\n\r\n    if (error.status === 401 || error.status === 403) {\r\n      return new ColivaraError(ColivaraErrorType.AUTHENTICATION_FAILED, 'Authentication failed', error, error.status);\r\n    }\r\n\r\n    if (error.status === 404) {\r\n      return new ColivaraError(ColivaraErrorType.DOCUMENT_NOT_FOUND, 'Document not found in Colivara collections', error, error.status);\r\n    }\r\n\r\n    if (error.status >= 500) {\r\n      return new ColivaraError(ColivaraErrorType.API_UNAVAILABLE, 'API temporarily unavailable', error, error.status);\r\n    }\r\n\r\n    if (error.name === 'TimeoutError') {\r\n      return new ColivaraError(ColivaraErrorType.TIMEOUT, error.message, error);\r\n    }\r\n\r\n    // Default to processing failed\r\n    return new ColivaraError(ColivaraErrorType.PROCESSING_FAILED, error.message || 'Processing failed', error);\r\n  }\r\n\r\n  private isPermanentError(error: ColivaraError): boolean {\r\n    // These errors should not be retried\r\n    return [\r\n      ColivaraErrorType.AUTHENTICATION_FAILED,\r\n      ColivaraErrorType.INVALID_RESPONSE,\r\n      ColivaraErrorType.DOCUMENT_NOT_FOUND\r\n    ].includes(error.type);\r\n  }\r\n\r\n  private isCircuitBreakerOpen(): boolean {\r\n    if (!this.circuitBreakerOpen) {\r\n      return false;\r\n    }\r\n\r\n    // Check if enough time has passed to close the circuit\r\n    if (this.lastFailureTime && \r\n        new Date().getTime() - this.lastFailureTime.getTime() > this.resetTimeout) {\r\n      this.circuitBreakerOpen = false;\r\n      this.failureCount = 0;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateCircuitBreaker(): void {\r\n    this.failureCount++;\r\n    this.lastFailureTime = new Date();\r\n    \r\n    if (this.failureCount >= this.maxFailures) {\r\n      this.circuitBreakerOpen = true;\r\n      console.warn('Circuit breaker opened due to too many failures');\r\n    }\r\n  }\r\n\r\n  private resetCircuitBreaker(): void {\r\n    this.circuitBreakerOpen = false;\r\n    this.failureCount = 0;\r\n    this.lastFailureTime = null;\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  // Method to check service health\r\n  async checkServiceHealth(service: ColivaraService): Promise<boolean> {\r\n    try {\r\n      return await service.validateApiKey();\r\n    } catch (error) {\r\n      console.error('Colivara service health check failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Method to handle graceful degradation\r\n  async handleGracefulDegradation<T>(\r\n    colivaraOperation: () => Promise<T>,\r\n    fallbackOperation: () => Promise<T>,\r\n    options: ErrorHandlingOptions = {}\r\n  ): Promise<{ result: T; degraded: boolean; error?: ColivaraError }> {\r\n    const { result, error, fallbackUsed } = await this.handleColivaraOperation(\r\n      colivaraOperation,\r\n      { ...options, fallbackToTraditional: true }\r\n    );\r\n\r\n    if (fallbackUsed && result === null) {\r\n      // Use fallback operation\r\n      try {\r\n        const fallbackResult = await fallbackOperation();\r\n        return { result: fallbackResult, degraded: true, error };\r\n      } catch (fallbackError) {\r\n        console.error('Fallback operation also failed:', fallbackError);\r\n        throw new ColivaraError(\r\n          ColivaraErrorType.PROCESSING_FAILED, \r\n          'Both primary and fallback operations failed',\r\n          fallbackError\r\n        );\r\n      }\r\n    }\r\n\r\n    if (result !== null) {\r\n      return { result, degraded: false };\r\n    }\r\n\r\n    throw new ColivaraError(ColivaraErrorType.PROCESSING_FAILED, 'Operation failed', error);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const colivaraErrorHandler = ColivaraErrorHandler.getInstance();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/colivara-service.ts"],"sourcesContent":["import { ColiVara } from 'colivara-ts';\r\nimport prisma from '@/lib/prisma';\r\nimport { Document } from '@/lib/api/types';\r\nimport { ColivaraDocument, ColivaraIndex } from '@/lib/types/colivara-types';\r\nimport { colivaraErrorHandler, ColivaraError as ColivaraServiceError, ColivaraErrorType } from './colivara-error-handler';\r\n\r\ninterface DocumentMetadata {\r\n  originalName: string;\r\n  size: number;\r\n  type: string;\r\n  extension: string;\r\n  uploadedAt: Date;\r\n lastModified: Date;\r\n  hash: string;\r\n}\r\n\r\ninterface ProcessingStatus {\r\n  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED';\r\n  progress?: number;\r\n  error?: string;\r\n  processedAt?: Date;\r\n  num_pages?: number;  // Add page count field\r\n}\r\n\r\ninterface SearchFilters {\r\n  unitId?: string;\r\n  category?: string;\r\n  dateRange?: { start: Date; end: Date };\r\n  fileType?: string[];\r\n}\r\n\r\ninterface SearchResults {\r\n  results: SearchResult[];\r\n  total: number;\r\n  query: string;\r\n processingTime: number;\r\n}\r\n\r\ninterface SearchResult {\r\n  documentId: string;\r\n  title: string;\r\n  content: string;\r\n  score: number;\r\n  pageNumbers: number[];\r\n  documentSection?: string;\r\n  confidenceScore?: number;\r\n  snippet: string;\r\n  document: Document;\r\n  visualContent?: string; // Base64 encoded visual content\r\n  extractedText?: string; // Extracted text content\r\n  screenshots?: string[]; // Array of screenshot base64 strings\r\n}\r\n\r\ninterface ColivaraConfig {\r\n  apiKey: string;\r\n  processingTimeout: number;\r\n  maxFileSize: number;\r\n  retryAttempts: number;\r\n  batchSize: number;\r\n  cacheEnabled: boolean;\r\n  cacheTtl: number;\r\n  defaultCollection: string;\r\n}\r\n\r\nclass ColivaraError extends Error {\r\n  constructor(message: string, public code?: string, public status?: number) {\r\n    super(message);\r\n    this.name = 'ColivaraError';\r\n }\r\n}\r\n\r\nclass ColivaraApiError extends ColivaraError {\r\n  constructor(message: string, public response?: any) {\r\n    super(message, 'API_ERROR', response?.status);\r\n    this.name = 'ColivaraApiError';\r\n  }\r\n}\r\n\r\nclass ColivaraProcessingError extends ColivaraError {\r\n  constructor(message: string, public documentId: string) {\r\n    super(message, 'PROCESSING_ERROR');\r\n    this.name = 'ColivaraProcessingError';\r\n  }\r\n}\r\n\r\nclass ColivaraService {\r\n  private client: ColiVara;\r\n  private config: ColivaraConfig;\r\n  private isInitialized: boolean;\r\n  private defaultCollection: string = 'lspu-kmis-documents';\r\n\r\n  constructor(config?: Partial<ColivaraConfig>) {\r\n    this.config = this.mergeConfig(config);\r\n    this.client = new ColiVara(this.config.apiKey);\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  private mergeConfig(userConfig?: Partial<ColivaraConfig>): ColivaraConfig {\r\n    return {\r\n      apiKey: process.env.COLIVARA_API_KEY || userConfig?.apiKey || '',\r\n      processingTimeout: userConfig?.processingTimeout || 300000, // 5 minutes default\r\n      maxFileSize: userConfig?.maxFileSize || 52428800, // 50MB default\r\n      retryAttempts: userConfig?.retryAttempts || 3,\r\n      batchSize: userConfig?.batchSize || 10,\r\n      cacheEnabled: userConfig?.cacheEnabled ?? true,\r\n      cacheTtl: userConfig?.cacheTtl || 3600000, // 1 hour default\r\n      defaultCollection: userConfig?.defaultCollection || 'lspu-kmis-documents',\r\n    };\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      // Validate API key by checking health\r\n      await this.validateApiKey();\r\n      \r\n      // Ensure the default collection exists\r\n      await this.ensureDefaultCollection();\r\n      \r\n      this.isInitialized = true;\r\n      console.log('Colivara service initialized successfully');\r\n    } catch (error) {\r\n      console.error('Failed to initialize Colivara service:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async validateApiKey(): Promise<boolean> {\r\n    try {\r\n      // Test connectivity to Colivara service using the health check\r\n      if (typeof this.client.checkHealth !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a checkHealth method');\r\n      }\r\n      await this.client.checkHealth();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('API key validation failed:', error);\r\n      throw colivaraErrorHandler.convertErrorToColivaraError(error);\r\n    }\r\n  }\r\n\r\n  private async ensureDefaultCollection(): Promise<void> {\r\n    try {\r\n      // Try to get the collection first\r\n      if (typeof this.client.getCollection !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getCollection method');\r\n      }\r\n      \r\n      try {\r\n        await this.client.getCollection({ collection_name: this.config.defaultCollection });\r\n        console.log(`Collection '${this.config.defaultCollection}' already exists`);\r\n      } catch (error) {\r\n        // Check if the error is because the method doesn't exist or collection doesn't exist\r\n        if (error instanceof TypeError || (error instanceof Error && error.message.includes('method'))) {\r\n          throw error; // Re-throw if it's a method not found error\r\n        }\r\n        \r\n        // If collection doesn't exist, create it\r\n        console.log(`Creating collection '${this.config.defaultCollection}'`);\r\n        \r\n        if (typeof this.client.createCollection !== 'function') {\r\n          throw new ColivaraApiError('Colivara client does not have a createCollection method');\r\n        }\r\n        \r\n        await this.client.createCollection({\r\n          name: this.config.defaultCollection,\r\n          metadata: {\r\n            description: 'Default collection for LSPU KMIS documents',\r\n            created_at: new Date().toISOString()\r\n          }\r\n        });\r\n        console.log(`Collection '${this.config.defaultCollection}' created successfully`);\r\n      }\r\n    } catch (error) {\r\n      console.error(`Failed to ensure default collection exists:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async uploadDocument(fileUrl: string, documentId: string, metadata: DocumentMetadata, base64Content?: string): Promise<string> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Update document status to PROCESSING using raw SQL since Prisma client hasn't been updated\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'PROCESSING', \"colivaraChecksum\" = ${metadata.hash}\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      // Check if the upsertDocument method exists\r\n      if (typeof this.client.upsertDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have an upsertDocument method');\r\n      }\r\n      \r\n      // Validate document metadata before upload\r\n      if (!documentId || typeof documentId !== 'string') {\r\n        throw new ColivaraApiError('Invalid document ID provided for upload');\r\n      }\r\n\r\n      // Validate document name\r\n      const documentName = `${documentId}_${metadata.originalName}`;\r\n      if (!documentName || documentName.length > 255) {\r\n        throw new ColivaraApiError('Document name is invalid or too long');\r\n      }\r\n\r\n      // Validate collection name\r\n      if (!this.config.defaultCollection || typeof this.config.defaultCollection !== 'string') {\r\n        throw new ColivaraApiError('Invalid collection name provided');\r\n      }\r\n\r\n      // Prepare upload parameters\r\n      const uploadParams: any = {\r\n        name: documentName,\r\n        collection_name: this.config.defaultCollection,\r\n        metadata: {\r\n          documentId,\r\n          title: metadata.originalName, // Ensure the title is stored in metadata for proper display\r\n          ...metadata\r\n        },\r\n        wait: false // Don't wait for processing to complete, we'll check status separately\r\n      };\r\n\r\n      // If base64 content is provided, use it instead of the URL\r\n      if (base64Content) {\r\n        console.log('Uploading document with base64 content:', {\r\n          name: documentName,\r\n          collection_name: this.config.defaultCollection,\r\n          metadata: {\r\n            documentId,\r\n            ...metadata\r\n          }\r\n        });\r\n        uploadParams.document_base64 = base64Content; // Use document_base64 instead of content for Colivara API\r\n      } else {\r\n        // If no base64 content provided, use the URL (fallback for backward compatibility)\r\n        if (!fileUrl || typeof fileUrl !== 'string') {\r\n          throw new ColivaraApiError('Invalid file URL provided for upload');\r\n        }\r\n        console.log('Uploading document with URL:', {\r\n          name: documentName,\r\n          collection_name: this.config.defaultCollection,\r\n          document_url: fileUrl,\r\n          metadata: {\r\n            documentId,\r\n            ...metadata\r\n          }\r\n        });\r\n        uploadParams.document_url = fileUrl;\r\n      }\r\n\r\n      const response = await this.client.upsertDocument(uploadParams);\r\n\r\n      console.log('Upload response received:', response);\r\n\r\n      // Extract document ID from response - adjust based on actual API response structure\r\n      // Ensure we return a string value, not the entire response object\r\n      const responseObj = response as any;\r\n      const documentIdFromResponse = responseObj.id || responseObj.documentId || responseObj.name ||\r\n                                    (typeof response === 'string' ? response : documentName);\r\n\r\n      if (!documentIdFromResponse) {\r\n        throw new ColivaraApiError('Invalid response from upsertDocument - no document ID returned');\r\n      }\r\n\r\n      // Validate that the document ID is a proper string\r\n      if (typeof documentIdFromResponse !== 'string' || documentIdFromResponse === '[object Object]') {\r\n        throw new ColivaraApiError(`Invalid document ID returned from API: ${typeof documentIdFromResponse}`);\r\n      }\r\n\r\n      // Store the Colivara document ID using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraDocumentId\" = ${documentIdFromResponse}\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      return documentIdFromResponse;\r\n    } catch (error) {\r\n      console.error(`Failed to upload document ${documentId} to Colivara:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED', \"colivaraMetadata\" = ${JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' })}::jsonb\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      if (error instanceof ColivaraError) {\r\n        throw error;\r\n      }\r\n\r\n      throw new ColivaraProcessingError(\r\n        `Failed to upload document to Colivara: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        documentId\r\n      );\r\n    }\r\n  }\r\n\r\n  async checkProcessingStatus(colivaraDocumentId: string): Promise<ProcessingStatus> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]' || !colivaraDocumentId) {\r\n        throw new ColivaraApiError('Invalid document ID provided to checkProcessingStatus');\r\n      }\r\n\r\n      console.log(`Checking processing status for document ID: ${colivaraDocumentId}`);\r\n\r\n      if (typeof this.client.getDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getDocument method');\r\n      }\r\n      \r\n      const response = await this.client.getDocument({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection  // Include collection name in the request\r\n      });\r\n\r\n      console.log(`Processing status response for ${colivaraDocumentId}:`, response);\r\n\r\n      // Handle the response based on the actual ColiVara API response structure\r\n      // Since we don't have exact type information, we'll access fields safely\r\n      return {\r\n        status: (response as any).status as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' || 'PENDING',\r\n        progress: (response as any).progress || 0,\r\n        error: (response as any).error,\r\n        processedAt: (response as any).processedAt ? new Date((response as any).processedAt) : undefined,\r\n        num_pages: (response as any).num_pages || (response as any).pages || (response as any).page_count || 0,  // Add page count information\r\n      };\r\n    } catch (error) {\r\n      console.error(`Failed to check processing status for ${colivaraDocumentId}:`, error);\r\n      \r\n      // Convert error to ColivaraError to check if it's a 404\r\n      const colivaraError = colivaraErrorHandler.convertErrorToColivaraError(error);\r\n      \r\n      // If it's a document not found error, return appropriate status\r\n      if (colivaraError.type === ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n        console.warn(`Document ${colivaraDocumentId} not found in Colivara collections`);\r\n        return {\r\n          status: 'FAILED',\r\n          error: `Document not found in Colivara: ${colivaraError.message}`,\r\n          processedAt: new Date(),\r\n        };\r\n      }\r\n      \r\n      // For other errors, log them and re-throw\r\n      console.error(`Error checking processing status for ${colivaraDocumentId}:`, colivaraError);\r\n      throw colivaraError;\r\n    }\r\n  }\r\n\r\n  async waitForProcessing(colivaraDocumentId: string, maxWaitTime: number = 3000): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    const checkInterval = 5000; // Check every 5 seconds\r\n\r\n    // Add a 2-second delay before starting the status check loop\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n    console.log(`Waiting 2 seconds before starting status check for document: ${colivaraDocumentId}`);\r\n\r\n    while (Date.now() - startTime < maxWaitTime) {\r\n      try {\r\n        const status = await this.checkProcessingStatus(colivaraDocumentId);\r\n        \r\n        if (status.status === 'COMPLETED' || (status.num_pages !== undefined && status.num_pages > 0)) {\r\n          return true;\r\n        } else if (status.status === 'FAILED') {\r\n          console.error(`Document processing failed for ${colivaraDocumentId}: ${status.error}`);\r\n          return false;\r\n        }\r\n        \r\n        // Wait before next check\r\n        await new Promise(resolve => setTimeout(resolve, checkInterval));\r\n      } catch (error) {\r\n        console.error(`Error checking processing status for ${colivaraDocumentId}:`, error);\r\n        // If the error is due to document not being found, return false immediately\r\n        if (error instanceof ColivaraServiceError && (error as any).type === ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n          console.error(`Document ${colivaraDocumentId} not found in Colivara, failing immediately`);\r\n          return false;\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    console.warn(`Processing timeout for ${colivaraDocumentId} after ${maxWaitTime}ms`);\r\n    return false;\r\n  }\r\n\r\n  async performSemanticSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      const startTime = Date.now();\r\n      \r\n      let response;\r\n      \r\n      // Check if the search method exists on the client\r\n      if (typeof this.client.search !== 'function') {\r\n        console.warn('Colivara client does not have a search method, falling back to traditional search');\r\n        return {\r\n          results: [],\r\n          total: 0,\r\n          query,\r\n          processingTime: 0,\r\n        };\r\n      }\r\n      \r\n      try {\r\n        response = await this.client.search({\r\n          query,\r\n          collection_name: this.config.defaultCollection,\r\n          top_k: 10 // Return top 10 results\r\n          // Note: Filters are not directly supported in the search call,\r\n          // they would need to be implemented using metadata filtering if available in the actual API\r\n        });\r\n      } catch (error) {\r\n        console.error('Colivara search API call failed:', error);\r\n        // Return empty results but don't throw, let the fallback mechanism handle it\r\n        return {\r\n          results: [],\r\n          total: 0,\r\n          query,\r\n          processingTime: 0,\r\n        };\r\n      }\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      // Format results to match our expected structure\r\n      const results: SearchResult[] = response.results.map((item: any) => {\r\n        // Extract the original document ID from multiple possible locations\r\n        let originalDocumentId = item.metadata?.documentId ||\r\n                                (item.document && item.document.metadata?.documentId) ||\r\n                                item.metadata?.id ||\r\n                                item.id;\r\n                                \r\n        // If still not found, try to extract from document_metadata in the document object\r\n        if (!originalDocumentId && item.document && item.document_metadata) {\r\n          originalDocumentId = item.document.document_metadata.documentId;\r\n        }\r\n        \r\n        // If still not found, try to extract directly from document_metadata property\r\n        if (!originalDocumentId && item.document_metadata) {\r\n          originalDocumentId = item.document_metadata.documentId;\r\n        }\r\n        \r\n        // If still not found, try to extract from the document name (which contains the document ID)\r\n        if (!originalDocumentId && item.document?.document_name) {\r\n          // Extract document ID from document_name which is in format \"docId_originalName.ext\"\r\n          const nameParts = item.document.document_name.split('_');\r\n          if (nameParts.length >= 1) {\r\n            originalDocumentId = nameParts[0];\r\n          }\r\n        }\r\n                                  \r\n        // Extract score - prioritize similarity/prob over confidence since those are more likely to be the actual relevance scores\r\n        const score = item.score || item.similarity || item.prob || item.confidence || 0;\r\n                                  \r\n        return {\r\n          documentId: originalDocumentId,\r\n          title: item.metadata?.title || item.title || item.metadata?.originalName || item.name || 'Untitled Document',\r\n          content: item.content || item.text || item.metadata?.content || '',\r\n          score: score,\r\n          pageNumbers: item.page_numbers || item.pageNumbers || item.pages || [item.document?.page_number] || [],\r\n          documentSection: item.section || item.documentSection || item.metadata?.section || '',\r\n          confidenceScore: score, // Use the same score value for consistency\r\n          snippet: item.snippet || item.content?.substring(0, 200) + '...' || item.text?.substring(0, 200) + '...' || item.metadata?.content?.substring(0, 200) + '...' || '',\r\n          document: item.document || item.metadata?.document || item || {} as Document,\r\n          visualContent: item.visualContent || item.image || item.image_data || undefined,\r\n          extractedText: item.extractedText || item.text || item.content || undefined,\r\n        };\r\n      });\r\n\r\n      return {\r\n        results,\r\n        total: results.length,\r\n        query,\r\n        processingTime,\r\n      };\r\n    } catch (error) {\r\n      console.error('Semantic search failed:', error);\r\n      // Return an empty result set in case of error\r\n      return {\r\n        results: [],\r\n        total: 0,\r\n        query,\r\n        processingTime: 0,\r\n      };\r\n    }\r\n  }\r\n\r\n  async performHybridSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Perform semantic search with Colivara\r\n      const semanticResults = await this.performSemanticSearch(query, filters, userId);\r\n\r\n      // Perform traditional database search\r\n      const traditionalResults = await this.performTraditionalSearch(query, filters, userId);\r\n\r\n      // Combine and rank results\r\n      const combinedResults = this.combineSearchResults(semanticResults, traditionalResults);\r\n\r\n      return {\r\n        results: combinedResults,\r\n        total: combinedResults.length,\r\n        query,\r\n        processingTime: semanticResults.processingTime + (traditionalResults as any).processingTime || 0,\r\n      };\r\n    } catch (error) {\r\n      console.error('Hybrid search failed:', error);\r\n      // Fallback to traditional search only\r\n      return await this.performTraditionalSearch(query, filters, userId);\r\n    }\r\n  }\r\n\r\n  private async performTraditionalSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    // This would use the existing search functionality from enhanced-document-service\r\n    // For now, we'll implement a basic version\r\n    const documents = await prisma.document.findMany({\r\n      where: {\r\n        AND: [\r\n          {\r\n            OR: [\r\n              { title: { contains: query, mode: 'insensitive' } },\r\n              { description: { contains: query, mode: 'insensitive' } },\r\n              { tags: { path: ['$[*]'], string_contains: query } as any }, // Search for query string within the tags array using JSON path as array\r\n            ]\r\n          },\r\n          filters?.unitId ? { unitId: filters.unitId } : {},\r\n          filters?.category ? { category: filters.category } : {},\r\n        ],\r\n        status: 'ACTIVE',\r\n      },\r\n      include: {\r\n        uploadedByUser: true,\r\n        documentUnit: true,\r\n      },\r\n      take: 50, // Limit to 50 results\r\n    });\r\n\r\n    const results: SearchResult[] = documents.map((doc: any) => ({\r\n      documentId: doc.id,\r\n      title: doc.title,\r\n      content: doc.description,\r\n      score: 0.5, // Default score for traditional search\r\n      pageNumbers: [],\r\n      documentSection: 'description',\r\n      confidenceScore: 0.5,\r\n      snippet: doc.description.substring(0, 200) + '...',\r\n      document: {\r\n        ...doc,\r\n        tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n        uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n        unit: doc.documentUnit ? {\r\n          id: doc.documentUnit.id,\r\n          name: doc.documentUnit.name,\r\n          code: doc.documentUnit.code,\r\n          description: doc.documentUnit.description || undefined,\r\n          createdAt: doc.documentUnit.createdAt,\r\n          updatedAt: doc.documentUnit.updatedAt,\r\n        } : undefined,\r\n        uploadedAt: new Date(doc.uploadedAt),\r\n        createdAt: new Date(doc.createdAt),\r\n        updatedAt: new Date(doc.updatedAt),\r\n        // Colivara fields (for consistency)\r\n        colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n      } as Document,\r\n    }));\r\n\r\n    return {\r\n      results,\r\n      total: results.length,\r\n      query,\r\n      processingTime: 0, // We don't track this for traditional search here\r\n    };\r\n  }\r\n\r\n  private combineSearchResults(semanticResults: SearchResults, traditionalResults: SearchResults): SearchResult[] {\r\n   // This is a simplified combination - in a real implementation, we would have more sophisticated ranking\r\n   const combined = [...semanticResults.results];\r\n   \r\n   // Add traditional results that aren't already in semantic results\r\n   for (const tradResult of traditionalResults.results) {\r\n     // Check if document already exists in combined results using documentId field\r\n     const exists = combined.some(semResult => {\r\n       const semDocId = semResult.documentId;\r\n       const tradDocId = tradResult.documentId;\r\n       return semDocId && tradDocId && semDocId === tradDocId;\r\n     });\r\n     if (!exists) {\r\n       combined.push(tradResult);\r\n     }\r\n   }\r\n   \r\n   // Sort by score (or some combination of scores)\r\n   return combined.sort((a, b) => (b.score || 0) - (a.score || 0));\r\n }\r\n\r\n  async indexDocument(documentId: string, base64Content?: string): Promise<boolean> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Get document from database\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!document) {\r\n        throw new ColivaraProcessingError(`Document not found: ${documentId}`, documentId);\r\n      }\r\n\r\n      // Update document status to PROCESSING using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'PROCESSING'\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      // Upload document to Colivara for processing\r\n      const colivaraDocId = await this.uploadDocument(\r\n        document.fileUrl,\r\n        documentId,\r\n        {\r\n          originalName: document.fileName,\r\n          size: document.fileSize,\r\n          type: document.fileType,\r\n          extension: document.fileName.split('.').pop() || '',\r\n          uploadedAt: document.uploadedAt,\r\n          lastModified: document.updatedAt,\r\n          hash: (document as any).colivaraChecksum || ''\r\n        },\r\n        base64Content // Pass the base64 content if provided\r\n      );\r\n\r\n      console.log('Upload result from upsertDocument:', { colivaraDocId, documentId });\r\n\r\n      // Start background processing without blocking\r\n      this.waitForProcessingAndComplete(documentId, colivaraDocId);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Failed to index document ${documentId}:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED'\r\n        WHERE id = ${documentId}\r\n      `;\r\n      \r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async waitForProcessingAndComplete(documentId: string, colivaraDocId: string): Promise<void> {\r\n    try {\r\n      // Wait for processing to complete\r\n      const completed = await this.waitForProcessing(colivaraDocId, this.config.processingTimeout);\r\n\r\n      if (completed) {\r\n        // Update document with Colivara results using raw SQL\r\n        await prisma.$executeRaw`\r\n          UPDATE documents\r\n          SET \"colivaraDocumentId\" = ${colivaraDocId},\r\n              \"colivaraProcessingStatus\" = 'COMPLETED',\r\n              \"colivaraProcessedAt\" = ${new Date()}::timestamp\r\n          WHERE id = ${documentId}\r\n        `;\r\n\r\n        // Extract and store the processed content in ColivaraIndex\r\n        await this.storeProcessedContent(documentId, colivaraDocId);\r\n      } else {\r\n        // Handle timeout or failure\r\n        await prisma.$executeRaw`\r\n          UPDATE documents\r\n          SET \"colivaraProcessingStatus\" = 'FAILED'\r\n          WHERE id = ${documentId}\r\n        `;\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error completing processing for document ${documentId}:`, error);\r\n      \r\n      // Update document status to FAILED using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraProcessingStatus\" = 'FAILED'\r\n        WHERE id = ${documentId}\r\n      `;\r\n    }\r\n  }\r\n\r\n  private async storeProcessedContent(documentId: string, colivaraDocId: string): Promise<void> {\r\n    try {\r\n      // Get the processed content from Colivara\r\n      // Note: The official API might not have a direct content endpoint\r\n      // We'll need to implement this based on what the actual API provides\r\n      console.log(`Storing processed content for document ${documentId} with Colivara ID ${colivaraDocId}`);\r\n      \r\n      // For now, we'll just log this operation\r\n      // The actual implementation would depend on what data the Colivara API returns\r\n      // after document processing is complete\r\n    } catch (error) {\r\n      console.error(`Failed to store processed content for document ${documentId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n   async updateIndex(documentId: string, base64Content?: string): Promise<boolean> {\r\n     try {\r\n       // Get the current document to check if it has changed\r\n       const document = await prisma.document.findUnique({\r\n         where: { id: documentId }\r\n       });\r\n \r\n       if (!document) {\r\n         return false;\r\n       }\r\n \r\n       // Check if we need to reprocess (e.g., if file has changed)\r\n       // For now, we'll just reprocess - we'll need to implement proper change detection\r\n       // once the Prisma client is updated with new fields\r\n       if ((document as any).colivaraProcessingStatus === 'COMPLETED' && (document as any).colivaraChecksum) {\r\n         // In a real implementation, we would check if the file has changed\r\n         // For now, we'll just reprocess\r\n       }\r\n \r\n       return await this.indexDocument(documentId, base64Content);\r\n     } catch (error) {\r\n       console.error(`Failed to update index for document ${documentId}:`, error);\r\n       return false;\r\n     }\r\n   }\r\n\r\n  async deleteFromIndex(documentId: string): Promise<boolean> {\r\n    try {\r\n      // Get the document first to check if it has a Colivara document ID\r\n      const document = await prisma.document.findUnique({\r\n        where: { id: documentId }\r\n      });\r\n\r\n      // If document exists and has a Colivara document ID, delete from Colivara collection\r\n      if (document && (document as any).colivaraDocumentId) {\r\n        try {\r\n          // Delete from Colivara collection using the official API\r\n          await this.client.deleteDocument({\r\n            document_name: (document as any).colivaraDocumentId,\r\n            collection_name: this.config.defaultCollection\r\n          });\r\n          console.log(`Successfully deleted document ${documentId} (${(document as any).colivaraDocumentId}) from Colivara collection`);\r\n        } catch (colivaraError) {\r\n          // Log the error but continue with database cleanup\r\n          console.error(`Failed to delete document ${documentId} from Colivara collection:`, colivaraError);\r\n          \r\n          // Check if it's a \"document not found\" error, which is acceptable\r\n          const colivaraServiceError = colivaraErrorHandler.convertErrorToColivaraError(colivaraError);\r\n          if (colivaraServiceError.type !== ColivaraErrorType.DOCUMENT_NOT_FOUND) {\r\n            // For other errors, log but continue with database cleanup\r\n            console.warn(`Non-critical error deleting document from Colivara collection, proceeding with database cleanup:`, colivaraError);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Delete all index entries for this document using raw SQL\r\n      await prisma.$executeRaw`\r\n        DELETE FROM colivara_indexes WHERE \"documentId\" = ${documentId}\r\n      `;\r\n\r\n      // Update document to reset Colivara fields using raw SQL\r\n      await prisma.$executeRaw`\r\n        UPDATE documents\r\n        SET \"colivaraDocumentId\" = NULL,\r\n            \"colivaraEmbeddings\" = NULL,\r\n            \"colivaraMetadata\" = NULL,\r\n            \"colivaraProcessingStatus\" = NULL,\r\n            \"colivaraProcessedAt\" = NULL,\r\n            \"colivaraChecksum\" = NULL\r\n        WHERE id = ${documentId}\r\n      `;\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Failed to delete document ${documentId} from index:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async extractDocumentMetadata(colivaraDocumentId: string): Promise<any> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to extractDocumentMetadata');\r\n      }\r\n\r\n      if (typeof this.client.getDocument !== 'function') {\r\n        throw new ColivaraApiError('Colivara client does not have a getDocument method');\r\n      }\r\n      \r\n      const response = await this.client.getDocument({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection  // Include collection name in the request\r\n      });\r\n      return response.metadata || response;\r\n    } catch (error) {\r\n      console.error(`Failed to extract metadata for ${colivaraDocumentId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async processNewDocument(document: Document, fileUrl: string, base64Content?: string): Promise<void> {\r\n    // This method processes a newly uploaded document\r\n    // It will be called after a document is successfully uploaded to the system\r\n    // Processing happens in the background without blocking the upload response\r\n    this.processNewDocumentAsync(document, fileUrl, base64Content);\r\n  }\r\n\r\n  private async processNewDocumentAsync(document: Document, fileUrl: string, base64Content?: string): Promise<void> {\r\n    try {\r\n      // The document should already be in the database with PENDING status\r\n      // We just need to trigger the Colivara processing\r\n      // Processing happens in the background without waiting for completion\r\n      this.indexDocument(document.id, base64Content);\r\n    } catch (error) {\r\n      console.error(`Error starting processing for new document ${document.id}:`, error);\r\n    }\r\n }\r\n\r\n  async handleDocumentUpdate(documentId: string, updatedDocument: Document, fileUrl?: string, base64Content?: string): Promise<void> {\r\n    try {\r\n      // Handle document updates\r\n      // If the file has changed (fileUrl is provided), reprocess the document\r\n      if (fileUrl) {\r\n        // Use updateIndex which will call indexDocument with the base64 content if provided\r\n        const success = await this.updateIndex(documentId, base64Content);\r\n        if (!success) {\r\n          console.error(`Failed to reprocess updated document ${documentId} with Colivara`);\r\n        }\r\n      } else {\r\n        // If only metadata changed, we might need to update the index differently\r\n        // For now, just return\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error handling document update for ${documentId}:`, error);\r\n    }\r\n  }\r\n\r\n /**\r\n   * Get visual content (screenshots/pages) from processed documents\r\n   * @param colivaraDocumentId The document ID in Colivara\r\n   * @param pageNumbers Specific pages to retrieve (optional, if not provided, returns all available)\r\n   */\r\n  async getVisualContent(colivaraDocumentId: string, pageNumbers?: number[]): Promise<string[]> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to getVisualContent');\r\n      }\r\n\r\n      console.log(`Getting visual content for document: ${colivaraDocumentId}, pages: ${pageNumbers || 'all'}`);\r\n\r\n      // Check if the getDocumentPages method exists on the client\r\n      if (typeof (this.client as any).getDocumentPages !== 'function') {\r\n        console.warn('Colivara client does not have a getDocumentPages method, returning empty array');\r\n        return [];\r\n      }\r\n\r\n      const response = await (this.client as any).getDocumentPages({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection,\r\n        page_numbers: pageNumbers\r\n      });\r\n\r\n      // Process the response to extract base64 images\r\n      if (response && response.pages) {\r\n        // If pages is an array of objects with image data\r\n        if (Array.isArray(response.pages)) {\r\n          return response.pages.map((page: any) => {\r\n            // Return base64 image data if available, otherwise return empty string\r\n            return page.image_data || page.image || page.base64 || '';\r\n          }).filter((img: string) => img !== ''); // Filter out empty strings\r\n        }\r\n        // If response has a different structure, try to extract images\r\n        else if (response.images && Array.isArray(response.images)) {\r\n          return response.images;\r\n        }\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error(`Failed to get visual content for ${colivaraDocumentId}:`, error);\r\n      return [];\r\n    }\r\n }\r\n\r\n  /**\r\n   * Get extracted text content from processed documents\r\n   * @param colivaraDocumentId The document ID in Colivara\r\n   * @param pageNumbers Specific pages to retrieve text from (optional, if not provided, returns all available)\r\n   */\r\n  async getExtractedText(colivaraDocumentId: string, pageNumbers?: number[]): Promise<string> {\r\n    try {\r\n      if (!this.isInitialized) {\r\n        await this.initialize();\r\n      }\r\n\r\n      // Validate that colivaraDocumentId is actually a string, not an object\r\n      if (typeof colivaraDocumentId !== 'string' || colivaraDocumentId === '[object Object]') {\r\n        throw new ColivaraApiError('Invalid document ID provided to getExtractedText');\r\n      }\r\n\r\n      console.log(`Getting extracted text for document: ${colivaraDocumentId}, pages: ${pageNumbers || 'all'}`);\r\n\r\n      // Check if the getDocumentText method exists on the client\r\n      if (typeof (this.client as any).getDocumentText !== 'function') {\r\n        console.warn('Colivara client does not have a getDocumentText method, returning empty string');\r\n        return '';\r\n      }\r\n\r\n      const response = await (this.client as any).getDocumentText({\r\n        document_name: colivaraDocumentId,\r\n        collection_name: this.config.defaultCollection,\r\n        page_numbers: pageNumbers\r\n      });\r\n\r\n      // Return the extracted text content\r\n      return response.text || response.content || response.extracted_text || '';\r\n    } catch (error) {\r\n      console.error(`Failed to get extracted text for ${colivaraDocumentId}:`, error);\r\n      return '';\r\n    }\r\n }\r\n\r\n  /**\r\n   * Enhanced search method that includes visual content and extracted text for multimodal processing\r\n   */\r\n  async performEnhancedSearch(query: string, filters?: SearchFilters, userId?: string): Promise<SearchResults> {\r\n    try {\r\n      // First, perform the standard semantic search\r\n      const standardResults = await this.performSemanticSearch(query, filters, userId);\r\n\r\n      // Instead of calling getVisualContent and getExtractedText which may trigger getDocumentPages errors,\r\n      // we'll return the standard results which should already contain the content from the search response\r\n      // This avoids the problematic API calls while still providing data for Gemini\r\n      return standardResults;\r\n    } catch (error) {\r\n      console.error('Enhanced search failed:', error);\r\n      // Fallback to standard search\r\n      return await this.performSemanticSearch(query, filters, userId);\r\n    }\r\n  }\r\n}\r\n\r\nexport default ColivaraService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/enhanced-document-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma';\r\nimport { Document } from '@/lib/api/types';\r\nimport ColivaraService from './colivara-service';\r\n\r\nconst colivaraService = new ColivaraService();\r\n\r\nclass EnhancedDocumentService {\r\n  /**\r\n   * Get all documents with optional filtering and pagination\r\n   * Enhanced with unit, year, quarter filtering capabilities\r\n   */\r\n  async getDocuments(\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    category?: string,\r\n    search?: string,\r\n    userId?: string,\r\n    sort?: string,\r\n    order: 'asc' | 'desc' = 'desc',\r\n    unitId?: string, // NEW: Filter by unit\r\n    year?: number, // NEW: Filter by reporting year\r\n    quarter?: number // NEW: Filter by reporting quarter\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    const skip = (page - 1) * limit;\r\n    \r\n    // Build where clause based on permissions and filters\r\n    const whereClause: any = {\r\n      status: 'ACTIVE', // Only show active documents\r\n    };\r\n\r\n    // Add category filter if provided\r\n    if (category && category !== 'all') {\r\n      whereClause.category = category;\r\n    }\r\n\r\n    // Add unit filter if provided\r\n    if (unitId) {\r\n      whereClause.unitId = unitId; // Using the new field name that was renamed from departmentId\r\n    }\r\n\r\n    // Add year filter if provided\r\n    if (year) {\r\n      whereClause.year = year;\r\n    }\r\n\r\n    // Add quarter filter if provided\r\n    if (quarter) {\r\n      whereClause.quarter = quarter;\r\n    }\r\n\r\n    // Add search filter if provided\r\n    if (search) {\r\n      const searchCondition = {\r\n        OR: [\r\n          { title: { contains: search, mode: 'insensitive' } },\r\n          { description: { contains: search, mode: 'insensitive' } },\r\n          { tags: { array_contains: [search] } }, // Updated for JSON field\r\n        ]\r\n      };\r\n      \r\n      // If we already have conditions (like category or unit), wrap everything in AND\r\n      if (Object.keys(whereClause).length > 1) { // More than just status\r\n        whereClause.AND = whereClause.AND || [];\r\n        whereClause.AND.push(searchCondition);\r\n      } else {\r\n        // If no other conditions exist, just add the search condition\r\n        Object.assign(whereClause, searchCondition);\r\n      }\r\n    }\r\n\r\n    // If user is not admin, only show documents they have access to\r\n    if (userId) {\r\n      // First, try to find the user by the provided userId (which might be the database ID)\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n\r\n      // In the new system, we only use the database ID\r\n      // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n      // The permission checks later will handle access control\r\n\r\n      if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n        // For non-admin and non-faculty users, we need to check document permissions\r\n        // This is a simplified approach - in a real system, you'd have more complex permission logic\r\n        const permissionCondition = {\r\n          OR: [\r\n            { uploadedById: user.id }, // Allow access to user's own documents (using db ID)\r\n            { permissions: { some: { userId: user.id, permission: { in: ['READ', 'WRITE', 'ADMIN'] } } } }, // Documents with explicit permissions\r\n          ]\r\n        };\r\n\r\n        // If we already have conditions in whereClause, wrap everything in AND\r\n        if (Object.keys(whereClause).length > 1) { // More than just status\r\n          whereClause.AND = whereClause.AND || [];\r\n          whereClause.AND.push(permissionCondition);\r\n        } else {\r\n          // If no other conditions exist, just add the permission condition\r\n          Object.assign(whereClause, permissionCondition);\r\n        }\r\n      }\r\n    }\r\n\r\n    try {\r\n      const [documents, total] = await Promise.all([\r\n        prisma.document.findMany({\r\n          where: whereClause,\r\n          skip,\r\n          take: limit,\r\n          orderBy: sort ? { [sort]: order } : { uploadedAt: 'desc' },\r\n          include: {\r\n            uploadedByUser: true,\r\n            documentUnit: true,\r\n          }\r\n        }),\r\n        prisma.document.count({ where: whereClause }),\r\n      ]);\r\n\r\n      return {\r\n        documents: documents.map((doc: any) => ({\r\n          ...doc,\r\n          tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n          unitId: doc.unitId ?? undefined,\r\n          year: doc.year ?? undefined,\r\n          quarter: doc.quarter ?? undefined,\r\n          isQproDocument: doc.isQproDocument ?? false,\r\n          versionNotes: doc.versionNotes ?? undefined, // Convert null to undefined\r\n          uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n          status: doc.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n          unit: doc.documentUnit ? {\r\n            id: doc.documentUnit.id,\r\n            name: doc.documentUnit.name,\r\n            code: doc.documentUnit.code,\r\n            description: doc.documentUnit.description || undefined, // Convert null to undefined\r\n            createdAt: doc.documentUnit.createdAt,\r\n            updatedAt: doc.documentUnit.updatedAt,\r\n          } : undefined,\r\n          uploadedAt: new Date(doc.uploadedAt),\r\n          createdAt: new Date(doc.createdAt),\r\n          updatedAt: new Date(doc.updatedAt),\r\n          // Colivara fields\r\n          colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n          colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n          colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n          colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n        })),\r\n        total,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocuments:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific document by ID\r\n   * Enhanced with unit access controls\r\n   */\r\n  async getDocumentById(id: string, userId?: string): Promise<Document | null> {\r\n    try {\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      if (!document) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has access to the document\r\n      if (userId) {\r\n        // First, try to find the user by the provided userId (which might be the database ID)\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: userId },\r\n        });\r\n\r\n        // In the new system, we only use the database ID\r\n        // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n        // The permission checks later will handle access control\r\n\r\n        if (user && user.role !== 'ADMIN' && user.role !== 'FACULTY') {\r\n          // Check if user has explicit permission for this document\r\n          const permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: id,\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['READ', 'WRITE', 'ADMIN'] }, // User needs at least READ permission\r\n            },\r\n          });\r\n\r\n          // Allow access if user has explicit READ/WRITE/ADMIN permission OR if user uploaded the document\r\n          if (!permission && document.uploadedById !== user.id) {\r\n            return null; // User doesn't have access\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        id: document.id,\r\n        title: document.title,\r\n        description: document.description,\r\n        category: document.category,\r\n        tags: Array.isArray(document.tags) ? document.tags as string[] : [],\r\n        uploadedBy: document.uploadedByUser?.name || document.uploadedBy,\r\n        uploadedById: document.uploadedById,\r\n        uploadedAt: new Date(document.uploadedAt),\r\n        fileUrl: document.fileUrl,\r\n        fileName: document.fileName,\r\n        fileType: document.fileType,\r\n        fileSize: document.fileSize,\r\n        downloadsCount: document.downloadsCount || 0,\r\n        viewsCount: document.viewsCount || 0,\r\n        version: document.version || 1,\r\n        versionNotes: document.versionNotes || undefined, // Convert null to undefined\r\n        status: document.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n        createdAt: new Date(document.createdAt),\r\n        updatedAt: new Date(document.updatedAt),\r\n        unitId: document.unitId || undefined, // Convert null to undefined\r\n        year: document.year ?? undefined,\r\n        quarter: document.quarter ?? undefined,\r\n        isQproDocument: document.isQproDocument ?? false,\r\n        unit: document.documentUnit ? {\r\n          id: document.documentUnit.id,\r\n          name: document.documentUnit.name,\r\n          code: document.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: document.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: document.documentUnit.createdAt,\r\n          updatedAt: document.documentUnit.updatedAt,\r\n        } : undefined,\r\n        // Colivara fields\r\n        colivaraDocumentId: document.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: document.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: document.colivaraProcessedAt ? new Date(document.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: document.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getDocumentById:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new document\r\n   * Enhanced with unit assignment and QPRO support (year, quarter)\r\n   */\r\n  async createDocument(\r\n    title: string,\r\n    description: string,\r\n    category: string,\r\n    tags: string[],\r\n    uploadedBy: string,\r\n    fileUrl: string,\r\n    fileName: string,\r\n    fileType: string,\r\n    fileSize: number,\r\n    userId: string,\r\n    unitId?: string, // NEW: Unit assignment\r\n    base64Content?: string, // NEW: Base64 content for Colivara processing\r\n    blobName?: string, // NEW: Azure Blob Storage blob name\r\n    options?: {\r\n      year?: number; // Reporting year for QPRO documents (2025-2029)\r\n      quarter?: number; // Reporting quarter for QPRO documents (1-4)\r\n      isQproDocument?: boolean; // Flag for QPRO documents\r\n    }\r\n  ): Promise<Document> {\r\n    try {\r\n      console.log('Creating document in database...', {\r\n        title,\r\n        description,\r\n        category,\r\n        tags,\r\n        uploadedBy,\r\n        fileUrl,\r\n        fileName,\r\n        fileType,\r\n        fileSize,\r\n        userId\r\n      });\r\n      \r\n      // First, check if userId is defined\r\n      if (!userId) {\r\n        console.error('No userId provided to createDocument function');\r\n        throw new Error('User ID is required to upload documents');\r\n      }\r\n\r\n      console.log('Attempting to find user with ID:', userId);\r\n      \r\n      // First, try to find user by the provided userId (which might be the database ID)\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n\r\n      // In the new system, we only use the database ID\r\n      // If not found by database ID, we return null\r\n      if (!user) {\r\n        console.error('User not found with provided ID:', userId);\r\n        throw new Error('Only admins and faculty can upload documents');\r\n      }\r\n      \r\n      console.log('User lookup result:', { user: !!user, role: user?.role, id: user?.id });\r\n\r\n      if (!user || !['ADMIN', 'FACULTY'].includes(user.role)) {\r\n        console.error('User does not have required role to upload documents:', user?.role);\r\n        throw new Error('Only admins and faculty can upload documents');\r\n      }\r\n\r\n      const document = await prisma.document.create({\r\n        data: {\r\n          title,\r\n          description: description || \"\", // Ensure description is not null\r\n          category: category || \"Uncategorized\", // Ensure category is not null\r\n          tags: tags || [], // Ensure tags is always an array, even if undefined\r\n          uploadedBy: user.name,\r\n          uploadedById: user.id, // Use the database user ID, not the Supabase auth ID\r\n          fileUrl,\r\n          blobName: blobName || undefined, // NEW: Store blob name if provided\r\n          fileName,\r\n          fileType,\r\n          fileSize,\r\n          unitId: unitId || null, // NEW: Assign unitId if provided\r\n          year: options?.year || null, // NEW: Reporting year for QPRO documents\r\n          quarter: options?.quarter || null, // NEW: Reporting quarter for QPRO documents\r\n          isQproDocument: options?.isQproDocument || false, // NEW: Flag for QPRO documents\r\n          status: 'ACTIVE',\r\n          colivaraProcessingStatus: 'PENDING', // Set initial processing status to PENDING\r\n        },\r\n      });\r\n      \r\n      console.log('Document created:', document.id);\r\n\r\n      // Grant the uploader full permissions\r\n      await prisma.documentPermission.create({\r\n        data: {\r\n          documentId: document.id,\r\n          userId: user.id, // Use the database user ID for permissions\r\n          permission: 'ADMIN',\r\n        },\r\n      });\r\n      \r\n      console.log('Document permissions granted');\r\n\r\n      // Get the updated document to ensure we have the latest unitId value after creation\r\n      const finalDocument = await prisma.document.findUnique({\r\n        where: { id: document.id },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n      \r\n      if (!finalDocument) {\r\n        throw new Error(`Document with id ${document.id} not found after creation`);\r\n      }\r\n\r\n      // Trigger Colivara processing asynchronously without blocking document creation\r\n      try {\r\n        colivaraService.processNewDocument(finalDocument as Document, fileUrl, base64Content);\r\n      } catch (processingError) {\r\n        console.error(`Error triggering Colivara processing for document ${document.id}:`, processingError);\r\n        // Don't throw error as we don't want to fail the document creation due to processing issues\r\n      }\r\n      \r\n      return {\r\n        id: finalDocument.id,\r\n        title: finalDocument.title,\r\n        description: finalDocument.description,\r\n        category: finalDocument.category,\r\n        tags: Array.isArray(finalDocument.tags) ? finalDocument.tags as string[] : [],\r\n        uploadedBy: finalDocument.uploadedByUser?.name || finalDocument.uploadedBy,\r\n        uploadedById: finalDocument.uploadedById,\r\n        uploadedAt: new Date(finalDocument.uploadedAt),\r\n        fileUrl: finalDocument.fileUrl,\r\n        fileName: finalDocument.fileName,\r\n        fileType: finalDocument.fileType,\r\n        fileSize: finalDocument.fileSize,\r\n        downloadsCount: finalDocument.downloadsCount || 0,\r\n        viewsCount: finalDocument.viewsCount || 0,\r\n        version: finalDocument.version || 1,\r\n        versionNotes: finalDocument.versionNotes ?? undefined, // Convert null to undefined\r\n        status: finalDocument.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n        createdAt: new Date(finalDocument.createdAt),\r\n        updatedAt: new Date(finalDocument.updatedAt),\r\n        unitId: finalDocument.unitId ?? undefined,\r\n        year: finalDocument.year ?? undefined,\r\n        quarter: finalDocument.quarter ?? undefined,\r\n        isQproDocument: finalDocument.isQproDocument ?? false,\r\n        unit: finalDocument.documentUnit ? {\r\n          id: finalDocument.documentUnit.id,\r\n          name: finalDocument.documentUnit.name,\r\n          code: finalDocument.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: finalDocument.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: finalDocument.documentUnit.createdAt,\r\n          updatedAt: finalDocument.documentUnit.updatedAt,\r\n        } : undefined,\r\n        // Colivara fields\r\n        colivaraDocumentId: finalDocument.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: finalDocument.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: finalDocument.colivaraProcessedAt ? new Date(finalDocument.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: finalDocument.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in createDocument:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a document\r\n   * Enhanced with unit assignment\r\n   */\r\n  async updateDocument(\r\n    id: string,\r\n    title?: string,\r\n    description?: string,\r\n    category?: string,\r\n    tags?: string[],\r\n    unitId?: string, // NEW: Unit assignment\r\n    userId?: string,\r\n    fileUrl?: string, // NEW: File URL for Colivara reprocessing\r\n    base64Content?: string // NEW: Base64 content for Colivara processing\r\n  ): Promise<Document | null> {\r\n    try {\r\n      const document = await prisma.document.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!document) {\r\n        return null;\r\n      }\r\n\r\n      // Check if user has permission to update the document\r\n      let permission = null;\r\n      let user = null;\r\n\r\n      if (userId) {\r\n        // First, try to find the user by the provided userId (which might be the database ID)\r\n        user = await prisma.user.findUnique({\r\n          where: { id: userId },\r\n        });\r\n\r\n        // In the new system, we only use the database ID\r\n        // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n        // The permission checks later will handle access control\r\n\r\n        if (user) {\r\n          permission = await prisma.documentPermission.findFirst({\r\n            where: {\r\n              documentId: id,\r\n              userId: user.id, // Use the database user ID\r\n              permission: { in: ['WRITE', 'ADMIN'] },\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      if (userId && !permission && user?.role !== 'ADMIN' && document.uploadedById !== user?.id) {\r\n        throw new Error('User does not have permission to update this document');\r\n      }\r\n\r\n      // Update document fields that Prisma client recognizes\r\n      const updatedDocument = await prisma.document.update({\r\n        where: { id },\r\n        data: {\r\n          ...(title && { title }),\r\n          ...(description !== undefined && { description: description || \"\" }),\r\n          ...(category !== undefined && { category: category || \"Uncategorized\" }),\r\n          ...(tags !== undefined && { tags: tags || [] }),\r\n          ...(unitId !== undefined && { unitId: unitId }), // Include unitId in the update if provided\r\n          updatedAt: new Date(),\r\n        },\r\n        include: {\r\n          uploadedByUser: true,\r\n          documentUnit: true,\r\n        }\r\n      });\r\n\r\n      // Get the updated document\r\n      const finalDocument = updatedDocument;\r\n      \r\n      if (!finalDocument) {\r\n        throw new Error(`Document with id ${id} not found after update`);\r\n      }\r\n\r\n      // Check if file URL has changed to determine if we need to reprocess with Colivara\r\n      // In this implementation, we pass fileUrl as an optional parameter to determine if reprocessing is needed\r\n      if (fileUrl) {\r\n        try {\r\n          colivaraService.handleDocumentUpdate(id, finalDocument as Document, fileUrl, base64Content);\r\n        } catch (processingError) {\r\n          console.error(`Error triggering Colivara reprocessing for document ${id}:`, processingError);\r\n          // Don't throw error as we don't want to fail the document update due to processing issues\r\n        }\r\n      }\r\n      \r\n      return {\r\n        id: finalDocument.id,\r\n        title: finalDocument.title,\r\n        description: finalDocument.description,\r\n        category: finalDocument.category,\r\n        tags: Array.isArray(finalDocument.tags) ? finalDocument.tags as string[] : [],\r\n        uploadedBy: finalDocument.uploadedByUser?.name || finalDocument.uploadedBy,\r\n        uploadedById: finalDocument.uploadedById,\r\n        uploadedAt: new Date(finalDocument.uploadedAt),\r\n        fileUrl: finalDocument.fileUrl,\r\n        fileName: finalDocument.fileName,\r\n        fileType: finalDocument.fileType,\r\n        fileSize: finalDocument.fileSize,\r\n        downloadsCount: finalDocument.downloadsCount || 0,\r\n        viewsCount: finalDocument.viewsCount || 0,\r\n        version: finalDocument.version || 1,\r\n        versionNotes: finalDocument.versionNotes ?? undefined, // Convert null to undefined\r\n        status: finalDocument.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n        createdAt: new Date(finalDocument.createdAt),\r\n        updatedAt: new Date(finalDocument.updatedAt),\r\n        unitId: finalDocument.unitId ?? undefined,\r\n        unit: finalDocument.documentUnit ? {\r\n          id: finalDocument.documentUnit.id,\r\n          name: finalDocument.documentUnit.name,\r\n          code: finalDocument.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n          description: finalDocument.documentUnit.description || undefined, // Convert null to undefined\r\n          createdAt: finalDocument.documentUnit.createdAt,\r\n          updatedAt: finalDocument.documentUnit.updatedAt,\r\n        } : undefined,\r\n        // Colivara fields\r\n        colivaraDocumentId: finalDocument.colivaraDocumentId ?? undefined,\r\n        colivaraProcessingStatus: finalDocument.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n        colivaraProcessedAt: finalDocument.colivaraProcessedAt ? new Date(finalDocument.colivaraProcessedAt) : undefined,\r\n        colivaraChecksum: finalDocument.colivaraChecksum ?? undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in updateDocument:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get documents by unit\r\n   */\r\n  async getDocumentsByUnit(\r\n    unitId: string,\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    userId?: string\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    return this.getDocuments(page, limit, undefined, undefined, userId, undefined, 'desc', unitId);\r\n  }\r\n\r\n  /**\r\n   * Get documents by unit that were uploaded by admin users only\r\n   */\r\n  async getAdminDocumentsByUnit(\r\n    unitId: string,\r\n    page: number = 1,\r\n    limit: number = 10,\r\n    userId?: string\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    const skip = (page - 1) * limit;\r\n    \r\n    // Build where clause based on permissions and filters\r\n    const whereClause: any = {\r\n      status: 'ACTIVE', // Only show active documents\r\n      unitId: unitId, // Filter by unit\r\n    };\r\n\r\n    // If user is not admin, only show documents they have access to\r\n    if (userId) {\r\n      // First, try to find the user by the provided userId (which might be the database ID)\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      });\r\n\r\n      // In the new system, we only use the database ID\r\n      // If not found by database ID, we just continue with the assumption that the user doesn't have access\r\n      // The permission checks later will handle access control\r\n\r\n      if (user && user.role === 'ADMIN') {\r\n        // Admins can see all documents in the unit regardless of who uploaded them\r\n        // No additional filtering needed for admins\r\n      } else if (user && user.role !== 'FACULTY') {\r\n        // For non-admin and non-faculty users, we need to check document permissions\r\n        const permissionCondition = {\r\n          OR: [\r\n            { uploadedById: user.id }, // Allow access to user's own documents (using db ID)\r\n            { permissions: { some: { userId: user.id, permission: { in: ['READ', 'WRITE', 'ADMIN'] } } } }, // Documents with explicit permissions\r\n          ]\r\n        };\r\n\r\n        // If we already have conditions in whereClause, wrap everything in AND\r\n        if (Object.keys(whereClause).length > 1) { // More than just status\r\n          whereClause.AND = whereClause.AND || [];\r\n          whereClause.AND.push(permissionCondition);\r\n        } else {\r\n          // If no other conditions exist, just add the permission condition\r\n          Object.assign(whereClause, permissionCondition);\r\n        }\r\n      }\r\n    }\r\n\r\n    try {\r\n      const [documents, total] = await Promise.all([\r\n        prisma.document.findMany({\r\n          where: whereClause,\r\n          skip,\r\n          take: limit,\r\n          orderBy: { uploadedAt: 'desc' },\r\n          include: {\r\n            uploadedByUser: true,\r\n            documentUnit: true,\r\n          }\r\n        }),\r\n        prisma.document.count({ where: whereClause }),\r\n      ]);\r\n\r\n      return {\r\n        documents: documents.map((doc: any) => ({\r\n          ...doc,\r\n          tags: Array.isArray(doc.tags) ? doc.tags as string[] : [],\r\n          unitId: doc.unitId ?? undefined,\r\n          versionNotes: doc.versionNotes ?? undefined, // Convert null to undefined\r\n          uploadedBy: doc.uploadedByUser?.name || doc.uploadedBy,\r\n          status: doc.status as 'ACTIVE' | 'ARCHIVED' | 'PENDING_REVIEW', // Ensure proper type\r\n          unit: doc.documentUnit ? {\r\n            id: doc.documentUnit.id,\r\n            name: doc.documentUnit.name,\r\n            code: doc.documentUnit.code || \"\", // Provide empty string as fallback since Unit type requires string\r\n            description: doc.documentUnit.description || undefined, // Convert null to undefined\r\n            createdAt: doc.documentUnit.createdAt,\r\n            updatedAt: doc.documentUnit.updatedAt,\r\n          } : undefined,\r\n          uploadedAt: new Date(doc.uploadedAt),\r\n          createdAt: new Date(doc.createdAt),\r\n          updatedAt: new Date(doc.updatedAt),\r\n          // Colivara fields\r\n          colivaraDocumentId: doc.colivaraDocumentId ?? undefined,\r\n          colivaraProcessingStatus: doc.colivaraProcessingStatus as 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' ?? undefined,\r\n          colivaraProcessedAt: doc.colivaraProcessedAt ? new Date(doc.colivaraProcessedAt) : undefined,\r\n          colivaraChecksum: doc.colivaraChecksum ?? undefined,\r\n        })),\r\n        total,\r\n      };\r\n    } catch (error) {\r\n      console.error('Database connection error in getAdminDocumentsByUnit:', error);\r\n      throw error; // Re-throw to be handled by the calling function\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user's unit permissions\r\n   */\r\n  async getUserUnitPermissions(userId: string, unitId: string): Promise<any | null> {\r\n    // This method is actually part of the unit permission service, not document service\r\n    // Placeholder implementation - this should be moved to the unit permission service\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Search documents with unit filters\r\n   */\r\n  async searchDocuments(\r\n    query: string,\r\n    unitId?: string,\r\n    category?: string,\r\n    tags?: string[],\r\n    userId?: string,\r\n    page: number = 1,\r\n    limit: number = 10\r\n  ): Promise<{ documents: Document[]; total: number }> {\r\n    return this.getDocuments(page, limit, category, query, userId, undefined, 'desc', unitId);\r\n  }\r\n}\r\n\r\nexport default new EnhancedDocumentService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/jwt-service.ts"],"sourcesContent":["// This service is for handling custom JWT tokens for database authentication\r\n\r\nexport interface TokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n  iat: number;\r\n  exp: number;\r\n}\r\n\r\nclass JWTService {\r\n  private readonly secret: string;\r\n\r\n  constructor() {\r\n    this.secret = process.env.JWT_SECRET || '6dFk5d0vbyLnZC0Amy83LtI47DsNr/KB4M+FgbUc6njd4cjk7XB2/8nTuhQDWW8OOgQ6fI74huxJE3a/RP2giw==';\r\n  }\r\n\r\n  /**\r\n   * Convert a string to a Uint8Array (which can be used with Web Crypto API)\r\n   */\r\n private stringToUint8Array(str: string): Uint8Array {\r\n    return new TextEncoder().encode(str);\r\n }\r\n\r\n /**\r\n  * Convert a Uint8Array to a base64url encoded string\r\n  */\r\n private uint8ArrayToBase64Url(uint8Array: Uint8Array): string {\r\n   let binary = '';\r\n   for (let i = 0; i < uint8Array.byteLength; i++) {\r\n     binary += String.fromCharCode(uint8Array[i]);\r\n   }\r\n   return btoa(binary)\r\n     .replace(/\\+/g, '-')\r\n     .replace(/\\//g, '_')\r\n     .replace(/=/g, '');\r\n }\r\n\r\n  /**\r\n   * Import the secret as a CryptoKey for use with Web Crypto API\r\n   */\r\n  private async importSecret(): Promise<CryptoKey> {\r\n    const encoder = new TextEncoder();\r\n    const keyBuffer = encoder.encode(this.secret);\r\n    \r\n    return await crypto.subtle.importKey(\r\n      'raw',\r\n      keyBuffer,\r\n      { name: 'HMAC', hash: 'SHA-256' },\r\n      false,\r\n      ['sign', 'verify']\r\n    );\r\n  }\r\n\r\n /**\r\n   * Generate a JWT token using Web Crypto API\r\n   */\r\n  async generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): Promise<string> {\r\n    try {\r\n      // Create the header\r\n      const header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n      };\r\n\r\n      // Add timestamp and expiration (1 hour from now)\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const expiration = timestamp + 3600; // 1 hour in seconds\r\n\r\n      // Create the payload with the provided data and timestamps\r\n      const fullPayload = {\r\n        ...payload,\r\n        iat: timestamp,\r\n        exp: expiration\r\n      };\r\n\r\n      // Encode header and payload to base64url\r\n      const encodedHeader = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(header))\r\n      );\r\n      const encodedPayload = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(fullPayload))\r\n      );\r\n\r\n      // Create the signing input\r\n      const signingInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Create signing input buffer in the proper format for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const signingInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Sign the token - use type assertion to handle TypeScript compatibility issues\r\n      const signatureBuffer = await crypto.subtle.sign(\r\n        'HMAC',\r\n        key,\r\n        signingInputBuffer as BufferSource\r\n      );\r\n\r\n      // Encode the signature - signatureBuffer is an ArrayBuffer, convert to base64url\r\n      const signatureUint8Array = new Uint8Array(signatureBuffer);\r\n      const encodedSignature = this.uint8ArrayToBase64Url(signatureUint8Array);\r\n\r\n      // Return the complete JWT token\r\n      return `${signingInput}.${encodedSignature}`;\r\n    } catch (error) {\r\n      console.error('JWT token generation failed:', error);\r\n      throw new Error('Failed to generate JWT token');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a JWT token using Web Crypto API\r\n   */\r\n  async verifyToken(token: string): Promise<TokenPayload | null> {\r\n    try {\r\n      // Check if token is valid before attempting to verify\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        console.error('Invalid token provided for verification');\r\n        return null;\r\n      }\r\n      \r\n      // Check if token has proper format (3 parts separated by dots)\r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const [encodedHeader, encodedPayload, encodedSignature] = tokenParts;\r\n\r\n      // Decode header\r\n      const decodedHeader = this.base64UrlDecode(encodedHeader);\r\n      if (!decodedHeader) {\r\n        console.error('Failed to decode token header');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const decodedPayloadStr = this.base64UrlDecode(encodedPayload);\r\n      if (!decodedPayloadStr) {\r\n        console.error('Failed to decode token payload');\r\n        return null;\r\n      }\r\n\r\n      // Parse payload\r\n      const payloadObj = JSON.parse(decodedPayloadStr) as TokenPayload;\r\n      \r\n      // Check if token is expired\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      if (payloadObj.exp && payloadObj.exp < currentTime) {\r\n        console.error('Token has expired');\r\n        return null;\r\n      }\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Verify the signature\r\n      const isValid = await this.verifySignature(\r\n        `${encodedHeader}.${encodedPayload}`,\r\n        encodedSignature,\r\n        key\r\n      );\r\n\r\n      if (!isValid) {\r\n        console.error('Token signature verification failed');\r\n        return null;\r\n      }\r\n\r\n      return payloadObj;\r\n    } catch (error: any) {\r\n      console.error('Token verification failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify the JWT signature using Web Crypto API\r\n   */\r\n  private async verifySignature(\r\n    signingInput: string,\r\n    signature: string,\r\n    key: CryptoKey\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Decode the signature from base64url to Uint8Array\r\n      const signatureBytes = this.base64UrlDecodeToUint8Array(signature);\r\n      if (!signatureBytes) {\r\n        return false;\r\n      }\r\n\r\n      // Create proper buffers for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const verificationInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Use ArrayBufferView for signatureBytes and input buffer\r\n      // Cast to appropriate types to handle TypeScript issues\r\n      const signatureView = new Uint8Array(signatureBytes.buffer, signatureBytes.byteOffset, signatureBytes.byteLength);\r\n      const inputView = new Uint8Array(verificationInputBuffer.buffer, verificationInputBuffer.byteOffset, verificationInputBuffer.byteLength);\r\n      \r\n      // Verify the signature - use type assertion to handle TypeScript compatibility issues\r\n      const isValid = await crypto.subtle.verify(\r\n        'HMAC',\r\n        key,\r\n        signatureView as BufferSource,\r\n        inputView as BufferSource\r\n      );\r\n\r\n      return isValid;\r\n    } catch (error) {\r\n      console.error('Signature verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Decode a JWT token without verification (for edge runtime compatibility)\r\n   * This only extracts the payload without validating the signature\r\n   * Use carefully - only for non-sensitive operations like checking expiration\r\n   */\r\n  decodeToken(token: string): TokenPayload | null {\r\n    try {\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        return null;\r\n      }\r\n      \r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const payload = tokenParts[1];\r\n      const decodedPayload = this.base64UrlDecode(payload);\r\n      if (!decodedPayload) {\r\n        return null;\r\n      }\r\n      \r\n      return JSON.parse(decodedPayload) as TokenPayload;\r\n    } catch (error: any) {\r\n      console.error('Token decoding failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token is expired without full verification\r\n   * This uses the decode method which doesn't require the secret\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      const decoded = this.decodeToken(token);\r\n      if (!decoded || !decoded.exp) {\r\n        return true; // If we can't decode or there's no expiration, consider it expired\r\n      }\r\n      // Compare expiration timestamp with current time (in seconds)\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      return decoded.exp < currentTime;\r\n    } catch (error) {\r\n      console.error('Error checking token expiration:', error);\r\n      return true; // If there's an error, assume token is expired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url encoded strings\r\n   */\r\n  private base64UrlDecode(str: string): string | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      return decodeURIComponent(escape(rawData));\r\n    } catch (error) {\r\n      console.error('Base64 URL decode error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url string to Uint8Array\r\n   */\r\n  private base64UrlDecodeToUint8Array(str: string): Uint8Array | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      \r\n      const buffer = new Uint8Array(rawData.length);\r\n      for (let i = 0; i < rawData.length; i++) {\r\n        buffer[i] = rawData.charCodeAt(i);\r\n      }\r\n      \r\n      return buffer;\r\n    } catch (error) {\r\n      console.error('Base64 URL decode to Uint8Array error:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new JWTService();"],"names":[],"mappings":"AAAA,6EAA6E;;;;;AAU7E,MAAM;IACa,OAAe;IAEhC,aAAc;QACZ,IAAI,CAAC,MAAM,GAAG,QAAQ,GAAG,CAAC,UAAU,IAAI;IAC1C;IAEA;;GAEC,GACF,AAAQ,mBAAmB,GAAW,EAAc;QACjD,OAAO,IAAI,cAAc,MAAM,CAAC;IACnC;IAEA;;EAEC,GACD,AAAQ,sBAAsB,UAAsB,EAAU;QAC5D,IAAI,SAAS;QACb,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,UAAU,EAAE,IAAK;YAC9C,UAAU,OAAO,YAAY,CAAC,UAAU,CAAC,EAAE;QAC7C;QACA,OAAO,KAAK,QACT,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,MAAM;IACnB;IAEC;;GAEC,GACD,MAAc,eAAmC;QAC/C,MAAM,UAAU,IAAI;QACpB,MAAM,YAAY,QAAQ,MAAM,CAAC,IAAI,CAAC,MAAM;QAE5C,OAAO,MAAM,OAAO,MAAM,CAAC,SAAS,CAClC,OACA,WACA;YAAE,MAAM;YAAQ,MAAM;QAAU,GAChC,OACA;YAAC;YAAQ;SAAS;IAEtB;IAED;;GAEE,GACD,MAAM,cAAc,OAA0C,EAAmB;QAC/E,IAAI;YACF,oBAAoB;YACpB,MAAM,SAAS;gBACb,KAAK;gBACL,KAAK;YACP;YAEA,iDAAiD;YACjD,MAAM,YAAY,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;YAC1C,MAAM,aAAa,YAAY,MAAM,oBAAoB;YAEzD,2DAA2D;YAC3D,MAAM,cAAc;gBAClB,GAAG,OAAO;gBACV,KAAK;gBACL,KAAK;YACP;YAEA,yCAAyC;YACzC,MAAM,gBAAgB,IAAI,CAAC,qBAAqB,CAC9C,IAAI,CAAC,kBAAkB,CAAC,KAAK,SAAS,CAAC;YAEzC,MAAM,iBAAiB,IAAI,CAAC,qBAAqB,CAC/C,IAAI,CAAC,kBAAkB,CAAC,KAAK,SAAS,CAAC;YAGzC,2BAA2B;YAC3B,MAAM,eAAe,GAAG,cAAc,CAAC,EAAE,gBAAgB;YAEzD,oCAAoC;YACpC,MAAM,MAAM,MAAM,IAAI,CAAC,YAAY;YAEnC,sEAAsE;YACtE,MAAM,UAAU,IAAI;YACpB,MAAM,qBAAqB,QAAQ,MAAM,CAAC;YAE1C,gFAAgF;YAChF,MAAM,kBAAkB,MAAM,OAAO,MAAM,CAAC,IAAI,CAC9C,QACA,KACA;YAGF,iFAAiF;YACjF,MAAM,sBAAsB,IAAI,WAAW;YAC3C,MAAM,mBAAmB,IAAI,CAAC,qBAAqB,CAAC;YAEpD,gCAAgC;YAChC,OAAO,GAAG,aAAa,CAAC,EAAE,kBAAkB;QAC9C,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;GAEC,GACD,MAAM,YAAY,KAAa,EAAgC;QAC7D,IAAI;YACF,sDAAsD;YACtD,IAAI,CAAC,SAAS,OAAO,UAAU,YAAY,MAAM,IAAI,OAAO,IAAI;gBAC9D,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,+DAA+D;YAC/D,MAAM,aAAa,MAAM,KAAK,CAAC;YAC/B,IAAI,WAAW,MAAM,KAAK,GAAG;gBAC3B,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,MAAM,CAAC,eAAe,gBAAgB,iBAAiB,GAAG;YAE1D,gBAAgB;YAChB,MAAM,gBAAgB,IAAI,CAAC,eAAe,CAAC;YAC3C,IAAI,CAAC,eAAe;gBAClB,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,iBAAiB;YACjB,MAAM,oBAAoB,IAAI,CAAC,eAAe,CAAC;YAC/C,IAAI,CAAC,mBAAmB;gBACtB,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,gBAAgB;YAChB,MAAM,aAAa,KAAK,KAAK,CAAC;YAE9B,4BAA4B;YAC5B,MAAM,cAAc,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;YAC5C,IAAI,WAAW,GAAG,IAAI,WAAW,GAAG,GAAG,aAAa;gBAClD,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,oCAAoC;YACpC,MAAM,MAAM,MAAM,IAAI,CAAC,YAAY;YAEnC,uBAAuB;YACvB,MAAM,UAAU,MAAM,IAAI,CAAC,eAAe,CACxC,GAAG,cAAc,CAAC,EAAE,gBAAgB,EACpC,kBACA;YAGF,IAAI,CAAC,SAAS;gBACZ,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,OAAO;QACT,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,8BAA8B,OAAO,WAAW;YAC9D,OAAO;QACT;IACF;IAEA;;GAEC,GACD,MAAc,gBACZ,YAAoB,EACpB,SAAiB,EACjB,GAAc,EACI;QAClB,IAAI;YACF,oDAAoD;YACpD,MAAM,iBAAiB,IAAI,CAAC,2BAA2B,CAAC;YACxD,IAAI,CAAC,gBAAgB;gBACnB,OAAO;YACT;YAEA,2CAA2C;YAC3C,MAAM,UAAU,IAAI;YACpB,MAAM,0BAA0B,QAAQ,MAAM,CAAC;YAE/C,0DAA0D;YAC1D,wDAAwD;YACxD,MAAM,gBAAgB,IAAI,WAAW,eAAe,MAAM,EAAE,eAAe,UAAU,EAAE,eAAe,UAAU;YAChH,MAAM,YAAY,IAAI,WAAW,wBAAwB,MAAM,EAAE,wBAAwB,UAAU,EAAE,wBAAwB,UAAU;YAEvI,sFAAsF;YACtF,MAAM,UAAU,MAAM,OAAO,MAAM,CAAC,MAAM,CACxC,QACA,KACA,eACA;YAGF,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,OAAO;QACT;IACF;IAED;;;;GAIE,GACD,YAAY,KAAa,EAAuB;QAC9C,IAAI;YACF,IAAI,CAAC,SAAS,OAAO,UAAU,YAAY,MAAM,IAAI,OAAO,IAAI;gBAC9D,OAAO;YACT;YAEA,MAAM,aAAa,MAAM,KAAK,CAAC;YAC/B,IAAI,WAAW,MAAM,KAAK,GAAG;gBAC3B,QAAQ,KAAK,CAAC;gBACd,OAAO;YACT;YAEA,MAAM,UAAU,UAAU,CAAC,EAAE;YAC7B,MAAM,iBAAiB,IAAI,CAAC,eAAe,CAAC;YAC5C,IAAI,CAAC,gBAAgB;gBACnB,OAAO;YACT;YAEA,OAAO,KAAK,KAAK,CAAC;QACpB,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,0BAA0B,OAAO,WAAW;YAC1D,OAAO;QACT;IACF;IAEA;;;GAGC,GACD,eAAe,KAAa,EAAW;QACrC,IAAI;YACF,MAAM,UAAU,IAAI,CAAC,WAAW,CAAC;YACjC,IAAI,CAAC,WAAW,CAAC,QAAQ,GAAG,EAAE;gBAC5B,OAAO,MAAM,mEAAmE;YAClF;YACA,8DAA8D;YAC9D,MAAM,cAAc,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;YAC5C,OAAO,QAAQ,GAAG,GAAG;QACvB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oCAAoC;YAClD,OAAO,MAAM,+CAA+C;QAC9D;IACF;IAEA;;GAEC,GACD,AAAQ,gBAAgB,GAAW,EAAiB;QAClD,IAAI;YACF,wBAAwB;YACxB,MAAM,UAAU,IAAI,MAAM,CAAC,CAAC,IAAK,IAAI,MAAM,GAAG,CAAE,IAAI;YACpD,MAAM,SAAS,IAAI,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,OAAO;YAC3D,MAAM,UAAU,KAAK;YACrB,OAAO,mBAAmB,OAAO;QACnC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,OAAO;QACT;IACF;IAEA;;GAEC,GACD,AAAQ,4BAA4B,GAAW,EAAqB;QAClE,IAAI;YACF,wBAAwB;YACxB,MAAM,UAAU,IAAI,MAAM,CAAC,CAAC,IAAK,IAAI,MAAM,GAAG,CAAE,IAAI;YACpD,MAAM,SAAS,IAAI,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,OAAO;YAC3D,MAAM,UAAU,KAAK;YAErB,MAAM,SAAS,IAAI,WAAW,QAAQ,MAAM;YAC5C,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;gBACvC,MAAM,CAAC,EAAE,GAAG,QAAQ,UAAU,CAAC;YACjC;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0CAA0C;YACxD,OAAO;QACT;IACF;AACF;uCAEe,IAAI"}},
    {"offset": {"line": 2103, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/utils/rbac.ts"],"sourcesContent":["/**\r\n * Role-Based Access Control (RBAC) utilities for LSPU KMIS\r\n * Defines role hierarchies and permission checks\r\n */\r\n\r\nexport type UserRole = 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL';\r\n\r\n// Define role hierarchy - ADMIN has highest privileges, followed by FACULTY, STUDENT, then EXTERNAL\r\nconst ROLE_HIERARCHY: Record<UserRole, number> = {\r\n  'ADMIN': 4,\r\n  'FACULTY': 3,\r\n  'STUDENT': 2,\r\n  'EXTERNAL': 1\r\n};\r\n\r\n/**\r\n * Check if a user has a specific role\r\n */\r\nexport function hasRole(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return userRole === requiredRole;\r\n}\r\n\r\n/**\r\n * Check if a user has any of the specified roles\r\n */\r\nexport function hasAnyRole(userRole: UserRole, requiredRoles: UserRole[]): boolean {\r\n  return requiredRoles.includes(userRole);\r\n}\r\n\r\n/**\r\n * Check if a user's role has higher or equal hierarchy than required role\r\n */\r\nexport function hasRoleHierarchy(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];\r\n}\r\n\r\n/**\r\n * Check if user has admin privileges\r\n */\r\nexport function isAdmin(userRole: UserRole): boolean {\r\n  return userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has faculty privileges\r\n */\r\nexport function isFaculty(userRole: UserRole): boolean {\r\n  return userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has student privileges\r\n */\r\nexport function isStudent(userRole: UserRole): boolean {\r\n  return userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has external privileges\r\n */\r\nexport function isExternal(userRole: UserRole): boolean {\r\n  return userRole === 'EXTERNAL' || userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Get allowed actions based on user role\r\n */\r\nexport function getAllowedActions(userRole: UserRole): string[] {\r\n  switch (userRole) {\r\n    case 'ADMIN':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'DELETE_DOCUMENT',\r\n        'CREATE_USER',\r\n        'READ_USER',\r\n        'UPDATE_USER',\r\n        'DELETE_USER',\r\n        'CREATE_UNIT',\r\n        'READ_UNIT',\r\n        'UPDATE_UNIT',\r\n        'DELETE_UNIT',\r\n        'MANAGE_PERMISSIONS',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'FACULTY':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'STUDENT':\r\n      return [\r\n        'READ_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT'\r\n      ];\r\n    case 'EXTERNAL':\r\n      return [\r\n        'READ_DOCUMENT'\r\n      ];\r\n    default:\r\n      return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a user has permission to perform an action\r\n */\r\nexport function hasPermission(userRole: UserRole, action: string): boolean {\r\n  const allowedActions = getAllowedActions(userRole);\r\n  return allowedActions.includes(action);\r\n}\r\n\r\n/**\r\n * Get all roles that can perform a specific action\r\n */\r\nexport function getRolesForAction(action: string): UserRole[] {\r\n  const roles: UserRole[] = [];\r\n  (Object.keys(ROLE_HIERARCHY) as UserRole[]).forEach(role => {\r\n    if (hasPermission(role, action)) {\r\n      roles.push(role);\r\n    }\r\n  });\r\n  return roles;\r\n}"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;;;AAID,oGAAoG;AACpG,MAAM,iBAA2C;IAC/C,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY;AACd;AAKO,SAAS,QAAQ,QAAkB,EAAE,YAAsB;IAChE,OAAO,aAAa;AACtB;AAKO,SAAS,WAAW,QAAkB,EAAE,aAAyB;IACtE,OAAO,cAAc,QAAQ,CAAC;AAChC;AAKO,SAAS,iBAAiB,QAAkB,EAAE,YAAsB;IACzE,OAAO,cAAc,CAAC,SAAS,IAAI,cAAc,CAAC,aAAa;AACjE;AAKO,SAAS,QAAQ,QAAkB;IACxC,OAAO,aAAa;AACtB;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa;AAChD;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa,aAAa,aAAa;AAC1E;AAKO,SAAS,WAAW,QAAkB;IAC3C,OAAO,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa;AACrG;AAKO,SAAS,kBAAkB,QAAkB;IAClD,OAAQ;QACN,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;aACD;QACH;YACE,OAAO,EAAE;IACb;AACF;AAKO,SAAS,cAAc,QAAkB,EAAE,MAAc;IAC9D,MAAM,iBAAiB,kBAAkB;IACzC,OAAO,eAAe,QAAQ,CAAC;AACjC;AAKO,SAAS,kBAAkB,MAAc;IAC9C,MAAM,QAAoB,EAAE;IAC3B,OAAO,IAAI,CAAC,gBAA+B,OAAO,CAAC,CAAA;QAClD,IAAI,cAAc,MAAM,SAAS;YAC/B,MAAM,IAAI,CAAC;QACb;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 2215, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/middleware/auth-middleware.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { NextResponse } from 'next/server';\r\nimport jwtService from '@/lib/services/jwt-service';\r\nimport prisma from '@/lib/prisma';\r\nimport { hasAnyRole, type UserRole } from '@/lib/utils/rbac';\r\n\r\nexport async function requireAuth(request: NextRequest, roles?: string[]): Promise<{ user: any } | NextResponse> {\r\n  // Extract the token from the Authorization header or cookies\r\n  const authHeader = request.headers.get('authorization');\r\n  let token = null;\r\n  \r\n  if (authHeader && authHeader.startsWith('Bearer ')) {\r\n    token = authHeader.substring(7);\r\n  } else {\r\n    // Try to get token from cookies\r\n    const cookies = request.cookies;\r\n    token = cookies.get('access_token')?.value;\r\n  }\r\n\r\n  if (!token) {\r\n    // For API routes, return a 401 response instead of redirecting\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });\r\n    }\r\n    // For regular routes, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n  }\r\n\r\n  // Verify the JWT token\r\n  const decoded = await jwtService.verifyToken(token);\r\n  if (!decoded) {\r\n    console.error('Token verification failed:', token ? token.substring(0, 20) + '...' : 'null');\r\n    // Token is invalid, return appropriate response based on request type\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 });\r\n    } else {\r\n      // For regular routes, redirect to login\r\n      const response = NextResponse.redirect(new URL('/', request.url));\r\n      return response;\r\n    }\r\n }\r\n\r\n  console.log('Decoded token:', decoded);\r\n\r\n  // Check if decoded.userId is valid\r\n  if (!decoded.userId) {\r\n    console.error('Token does not contain userId:', decoded);\r\n    // Token doesn't contain a valid userId, return error\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid token: missing user ID' }, { status: 401 });\r\n    }\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Get user profile from database using the user ID from the token\r\n  const user = await prisma.user.findUnique({\r\n    where: {\r\n      id: decoded.userId,\r\n    },\r\n    select: {\r\n      id: true,\r\n      email: true,\r\n      name: true,\r\n      role: true,\r\n      unitId: true,\r\n    }\r\n  });\r\n\r\n  if (!user) {\r\n    console.error('User not found with ID from token:', decoded.userId);\r\n    // User doesn't exist in the database, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Check if user has required roles\r\n  if (roles && roles.length > 0 && !hasAnyRole(user.role as UserRole, roles as UserRole[])) {\r\n    // User doesn't have required role, return error for API routes\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'User does not have required role to perform this action' }, { status: 403 });\r\n    }\r\n    // For regular routes, redirect to unauthorized page\r\n    const response = NextResponse.redirect(new URL('/unauthorized', request.url));\r\n    return response;\r\n  }\r\n\r\n  return { user };\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEO,eAAe,YAAY,OAAoB,EAAE,KAAgB;IACtE,6DAA6D;IAC7D,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,QAAQ;IAEZ,IAAI,cAAc,WAAW,UAAU,CAAC,YAAY;QAClD,QAAQ,WAAW,SAAS,CAAC;IAC/B,OAAO;QACL,gCAAgC;QAChC,MAAM,UAAU,QAAQ,OAAO;QAC/B,QAAQ,QAAQ,GAAG,CAAC,iBAAiB;IACvC;IAEA,IAAI,CAAC,OAAO;QACV,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QACA,wCAAwC;QACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACT;IAEA,uBAAuB;IACvB,MAAM,UAAU,MAAM,8IAAU,CAAC,WAAW,CAAC;IAC7C,IAAI,CAAC,SAAS;QACZ,QAAQ,KAAK,CAAC,8BAA8B,QAAQ,MAAM,SAAS,CAAC,GAAG,MAAM,QAAQ;QACrF,sEAAsE;QACtE,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAChF,OAAO;YACL,wCAAwC;YACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;YAC/D,OAAO;QACT;IACH;IAEC,QAAQ,GAAG,CAAC,kBAAkB;IAE9B,mCAAmC;IACnC,IAAI,CAAC,QAAQ,MAAM,EAAE;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,qDAAqD;QACrD,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiC,GAAG;gBAAE,QAAQ;YAAI;QACtF;QACA,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,kEAAkE;IAClE,MAAM,OAAO,MAAM,0HAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YACL,IAAI,QAAQ,MAAM;QACpB;QACA,QAAQ;YACN,IAAI;YACJ,OAAO;YACP,MAAM;YACN,MAAM;YACN,QAAQ;QACV;IACF;IAEA,IAAI,CAAC,MAAM;QACT,QAAQ,KAAK,CAAC,sCAAsC,QAAQ,MAAM;QAClE,wDAAwD;QACxD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,mCAAmC;IACnC,IAAI,SAAS,MAAM,MAAM,GAAG,KAAK,CAAC,IAAA,oIAAU,EAAC,KAAK,IAAI,EAAc,QAAsB;QACxF,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0D,GAAG;gBAAE,QAAQ;YAAI;QAC/G;QACA,oDAAoD;QACpD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;QAC3E,OAAO;IACT;IAEA,OAAO;QAAE;IAAK;AAChB"}},
    {"offset": {"line": 2396, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/file-storage-service.ts"],"sourcesContent":["import { BlobServiceClient, generateBlobSASQueryParameters, BlobSASPermissions } from '@azure/storage-blob';\r\nimport { randomUUID } from 'crypto';\r\nimport { createHash } from 'crypto';\r\n\r\nclass FileStorageService {\r\n  private readonly blobServiceClient: BlobServiceClient;\r\n  private readonly containerName: string = 'repository-files';\r\n\r\n  constructor() {\r\n    const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;\r\n    if (!connectionString) {\r\n      throw new Error('Azure Storage connection string is not configured');\r\n    }\r\n    this.blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);\r\n  }\r\n\r\n  async saveFile(file: File, originalFileName: string): Promise<{url: string, blobName: string, metadata: any}> {\r\n    console.log('Starting file upload process to Azure Blob Storage...');\r\n    \r\n    // Validate file type\r\n    const allowedTypes = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'txt', 'jpg', 'jpeg', 'png'];\r\n    const fileExt = this.getFileExtension(originalFileName).toLowerCase();\r\n    \r\n    if (!allowedTypes.includes(fileExt)) {\r\n      throw new Error(`File type ${fileExt} is not allowed. Allowed types: ${allowedTypes.join(', ')}`);\r\n    }\r\n\r\n    // Validate file size (e.g., max 50MB)\r\n    const maxSize = 50 * 1024 * 1024; // 50MB in bytes\r\n    if (file.size > maxSize) {\r\n      throw new Error(`File size exceeds maximum allowed size of ${maxSize} bytes`);\r\n    }\r\n\r\n    // Generate a unique filename to prevent conflicts\r\n    const uniqueFileName = `${randomUUID()}.${fileExt}`;\r\n    console.log('Generated unique filename:', uniqueFileName);\r\n    \r\n    // Convert File object to buffer\r\n    const buffer = Buffer.from(await file.arrayBuffer());\r\n    console.log('File converted to buffer, size:', buffer.length);\r\n    \r\n    // Basic security: scan file content for known malicious patterns\r\n    await this.scanFileForMaliciousContent(buffer);\r\n    console.log('File security scan completed');\r\n\r\n    // Upload to Azure Blob Storage\r\n    const containerClient = this.blobServiceClient.getContainerClient(this.containerName);\r\n    const blockBlobClient = containerClient.getBlockBlobClient(uniqueFileName);\r\n    \r\n    const uploadOptions = {\r\n      blobHTTPHeaders: {\r\n        blobContentType: file.type || this.getMimeTypeFromExtension(fileExt)\r\n      }\r\n    };\r\n\r\n    const uploadBlobResponse = await blockBlobClient.uploadData(buffer, uploadOptions);\r\n    console.log('Upload result:', uploadBlobResponse.requestId);\r\n\r\n    // Extract basic metadata from the file\r\n    const metadata = {\r\n      originalName: originalFileName,\r\n      size: file.size,\r\n      type: file.type,\r\n      extension: fileExt,\r\n      uploadedAt: new Date(),\r\n      lastModified: file.lastModified ? new Date(file.lastModified) : new Date(),\r\n      hash: createHash('sha256').update(buffer).digest('hex'), // File integrity hash\r\n    };\r\n\r\n    // Return both the URL and metadata, including the blob name\r\n    return {\r\n      url: blockBlobClient.url,\r\n      blobName: uniqueFileName,\r\n      metadata\r\n    };\r\n  }\r\n\r\n  async deleteFile(fileUrl: string): Promise<boolean> {\r\n    try {\r\n      console.log('Deleting file:', fileUrl);\r\n      const fileName = this.getFileNameFromUrl(fileUrl);\r\n      console.log('Extracted filename:', fileName);\r\n      \r\n      const containerClient = this.blobServiceClient.getContainerClient(this.containerName);\r\n      const blockBlobClient = containerClient.getBlockBlobClient(fileName);\r\n      \r\n      const deleteResponse = await blockBlobClient.delete();\r\n      console.log('Delete result:', deleteResponse.requestId);\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting file:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getFileUrl(fileName: string, containerName: string = 'repository-files'): Promise<string> {\r\n    console.log('Getting file URL for:', { fileName, containerName });\r\n    const containerClient = this.blobServiceClient.getContainerClient(containerName);\r\n    const blockBlobClient = containerClient.getBlockBlobClient(fileName);\r\n    \r\n    // Generate a time-limited SAS URL for secure access\r\n    const expiryDate = new Date();\r\n    expiryDate.setHours(expiryDate.getHours() + 1); // URL expires in 1 hour\r\n    \r\n    // Get the account name from the connection string for SAS generation\r\n    const accountName = process.env.AZURE_STORAGE_ACCOUNT_NAME;\r\n    if (!accountName) {\r\n      throw new Error('Azure Storage account name is not configured');\r\n    }\r\n\r\n    // Create SAS permissions object properly\r\n    const permissions = new BlobSASPermissions();\r\n    permissions.read = true;\r\n    \r\n    const sasOptions = {\r\n      containerName: containerName,\r\n      blobName: fileName,\r\n      permissions: permissions,\r\n      expiresOn: expiryDate,\r\n    };\r\n    \r\n    // Get the account key for SAS generation\r\n    const connectionString = process.env.AZURE_STORAGE_CONNECTION_STRING;\r\n    if (!connectionString) {\r\n      throw new Error('Azure Storage connection string is not configured');\r\n    }\r\n\r\n    // Extract account key from connection string\r\n    const accountKeyMatch = connectionString.match(/AccountKey=([^;]+)/);\r\n    if (!accountKeyMatch) {\r\n      throw new Error('Account key not found in connection string');\r\n    }\r\n    const accountKey = accountKeyMatch[1];\r\n    \r\n    // Create a StorageSharedKeyCredential for SAS generation\r\n    const { StorageSharedKeyCredential } = await import('@azure/storage-blob');\r\n    const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);\r\n    \r\n    const sasToken = generateBlobSASQueryParameters(sasOptions, sharedKeyCredential);\r\n    return `${blockBlobClient.url}?${sasToken}`;\r\n  }\r\n\r\n  async validateAndExtractMetadata(file: File, originalFileName: string) {\r\n    // Validate file type\r\n    const allowedTypes = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'txt', 'jpg', 'jpeg', 'png'];\r\n    const fileExt = this.getFileExtension(originalFileName).toLowerCase();\r\n    \r\n    if (!allowedTypes.includes(fileExt)) {\r\n      throw new Error(`File type ${fileExt} is not allowed. Allowed types: ${allowedTypes.join(', ')}`);\r\n    }\r\n\r\n    // Validate file size (e.g., max 50MB)\r\n    const maxSize = 50 * 1024 * 1024; // 50MB in bytes\r\n    if (file.size > maxSize) {\r\n      throw new Error(`File size exceeds maximum allowed size of ${maxSize} bytes`);\r\n    }\r\n\r\n    // Extract metadata from the file\r\n    const metadata = {\r\n      originalName: originalFileName,\r\n      size: file.size,\r\n      type: file.type,\r\n      extension: fileExt,\r\n      uploadedAt: new Date(),\r\n      lastModified: file.lastModified ? new Date(file.lastModified) : new Date(),\r\n    };\r\n\r\n    return metadata;\r\n  }\r\n\r\n  private async scanFileForMaliciousContent(buffer: Buffer): Promise<void> {\r\n    // Basic security check: scan for known malicious patterns in file content\r\n    const maliciousPatterns = [\r\n      /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, // JavaScript in HTML\r\n      /<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, // iframe tags\r\n      /<object\\b[^<]*(?:(?!<\\/object>)<[^<]*)*<\\/object>/gi, // object tags\r\n      /<embed\\b[^<]*(?:(?!<\\/embed>)<[^<]*)*<\\/embed>/gi, // embed tags\r\n      /<form\\b[^<]*(?:(?!<\\/form>)<[^<]*)*<\\/form>/gi, // form tags\r\n      /javascript:/gi, // javascript: URLs\r\n      /vbscript:/gi, // vbscript: URLs\r\n      /onload=/gi, // onload events\r\n      /onerror=/gi, // onerror events\r\n      /onmouseover=/gi, // mouseover events\r\n      /onfocus=/gi, // focus events\r\n    ];\r\n\r\n    const fileContent = buffer.toString('utf-8');\r\n\r\n    for (const pattern of maliciousPatterns) {\r\n      if (pattern.test(fileContent)) {\r\n        throw new Error('File contains potentially malicious content');\r\n      }\r\n    }\r\n  }\r\n\r\n  private getFileExtension(fileName: string): string {\r\n    return fileName.split('.').pop() || '';\r\n  }\r\n\r\n  private getFileNameFromUrl(fileUrl: string): string {\r\n    // Remove query parameters first (e.g., SAS tokens)\r\n    const urlWithoutParams = fileUrl.split('?')[0];\r\n    return urlWithoutParams.split('/').pop() || '';\r\n  }\r\n\r\n  private getMimeTypeFromExtension(extension: string): string {\r\n    const mimeTypes: { [key: string]: string } = {\r\n      'pdf': 'application/pdf',\r\n      'doc': 'application/msword',\r\n      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n      'ppt': 'application/vnd.ms-powerpoint',\r\n      'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\r\n      'xls': 'application/vnd.ms-excel',\r\n      'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n      'txt': 'text/plain',\r\n      'jpg': 'image/jpeg',\r\n      'jpeg': 'image/jpeg',\r\n      'png': 'image/png'\r\n    };\r\n\r\n    return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';\r\n  }\r\n}\r\n\r\nexport default new FileStorageService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2622, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/app/api/documents/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { NextResponse } from 'next/server';\r\nimport enhancedDocumentService from '@/lib/services/enhanced-document-service';\r\nimport { requireAuth } from '@/lib/middleware/auth-middleware';\r\nimport fileStorageService from '@/lib/services/file-storage-service';\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // Verify authentication\r\n    const authResult = await requireAuth(request);\r\n    if ('status' in authResult) { // Check if it's a NextResponse (error case)\r\n      return authResult;\r\n    }\r\n    \r\n    const { user } = authResult;\r\n\r\n    // Extract query parameters\r\n    const { searchParams } = new URL(request.url);\r\n    const page = Math.max(1, parseInt(searchParams.get('page') || '1'));\r\n    const limit = Math.min(100, Math.max(1, parseInt(searchParams.get('limit') || '10'))); // Limit to 100 max, 1 min\r\n    const category = searchParams.get('category') || undefined;\r\n    const search = searchParams.get('search') || undefined;\r\n    const unitId = searchParams.get('unit') || undefined; // NEW: Unit filter\r\n    const adminOnly = searchParams.get('adminOnly') === 'true'; // NEW: Admin only filter\r\n    const sort = searchParams.get('sort') || undefined;\r\n    const orderParam = searchParams.get('order') || 'desc';\r\n    const order = orderParam === 'asc' ? 'asc' : 'desc'; // Ensure order is either 'asc' or 'desc'\r\n    const yearParam = searchParams.get('year');\r\n    const quarterParam = searchParams.get('quarter');\r\n    const year = yearParam ? parseInt(yearParam) : undefined; // NEW: Year filter (2025-2029)\r\n    const quarter = quarterParam ? parseInt(quarterParam) : undefined; // NEW: Quarter filter (1-4)\r\n\r\n    const userId = user.id;\r\n\r\n    let result;\r\n    if (adminOnly && unitId) {\r\n      // Get documents by unit - this function now allows admins to see all documents in the unit\r\n      result = await enhancedDocumentService.getAdminDocumentsByUnit(unitId, page, limit, userId);\r\n    } else {\r\n      // Get documents using the enhanced document service\r\n      // Note: The document service expects parameters in this order: page, limit, category, search, userId, sort, order, unitId, year, quarter\r\n      result = await enhancedDocumentService.getDocuments(\r\n        page,\r\n        limit,\r\n        category,\r\n        search,\r\n        userId,\r\n        sort,\r\n        order,\r\n        unitId, // NEW: Unit filter\r\n        year, // NEW: Year filter\r\n        quarter // NEW: Quarter filter\r\n      );\r\n    }\r\n\r\n    const { documents, total } = result;\r\n\r\n    return NextResponse.json({\r\n      documents,\r\n      total,\r\n      page,\r\n      limit,\r\n      totalPages: Math.ceil(total / limit),\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching documents:', error);\r\n    // More specific error handling\r\n    if (error instanceof Error) {\r\n      // Check for specific error types\r\n      if (error.message.includes('database') || error.message.includes('connection')) {\r\n        return NextResponse.json(\r\n          { error: 'Database connection error' },\r\n          { status: 500 }\r\n        );\r\n      } else if (error.message.includes('permission') || error.message.includes('auth')) {\r\n        return NextResponse.json(\r\n          { error: 'Permission denied' },\r\n          { status: 403 }\r\n        );\r\n      } else {\r\n        return NextResponse.json(\r\n          { error: error.message || 'Internal server error' },\r\n          { status: 500 }\r\n        );\r\n      }\r\n    } else {\r\n      return NextResponse.json(\r\n        { error: 'Internal server error' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    console.log('Starting document upload process...');\r\n    // Verify authentication and check role\r\n    const authResult = await requireAuth(request, ['ADMIN', 'FACULTY']);\r\n    if ('status' in authResult) { // Check if it's a NextResponse (error case)\r\n      console.log('Authentication failed:', authResult);\r\n      return authResult;\r\n    }\r\n    \r\n    const { user } = authResult;\r\n    console.log('User authenticated:', user.id, user.role);\r\n\r\n    const userId = user.id;\r\n    const userRole = user.role;\r\n\r\n    // Parse form data for file upload\r\n    console.log('Parsing form data...');\r\n    const formData = await request.formData();\r\n    const title = formData.get('title') as string;\r\n    const description = formData.get('description') as string;\r\n    const unitId = formData.get('unitId') as string; // NEW: Unit assignment\r\n    const file = formData.get('file') as File | null;\r\n\r\n    if (!title || !file) {\r\n      console.log('Missing required fields');\r\n      return NextResponse.json(\r\n        { error: 'Missing required fields' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Process tags - not provided in form anymore, will be handled by AI\r\n    const tagArray: string[] = [];\r\n\r\n    // Additional validation\r\n    if (title.length > 255) {\r\n      return NextResponse.json(\r\n        { error: 'Title exceeds maximum length of 255 characters' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (description.length > 1000) {\r\n      return NextResponse.json(\r\n        { error: 'Description exceeds maximum length of 1000 characters' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    try {\r\n      // Save file to storage\r\n      console.log('Starting file upload process...');\r\n      console.log('File details:', {\r\n        name: file.name,\r\n        size: file.size,\r\n        type: file.type\r\n      });\r\n      \r\n      const result = await fileStorageService.saveFile(file, file.name);\r\n      console.log('File uploaded successfully:', result.url);\r\n      const fileName = file.name;\r\n      const fileType = file.type;\r\n      const fileSize = file.size;\r\n      const blobName = result.blobName; // NEW: Store the blob name\r\n      // Get the full URL for the file from Azure Storage\r\n      const fileUrl = result.url; // The URL is already returned by the saveFile function\r\n      console.log('File URL generated:', fileUrl);\r\n\r\n      // Convert file to base64 for Colivara processing since Azure Blob Storage is private\r\n      let base64Content: string | undefined;\r\n      try {\r\n        // Read the file as ArrayBuffer and convert to base64\r\n        const arrayBuffer = await file.arrayBuffer();\r\n        const buffer = Buffer.from(arrayBuffer);\r\n        base64Content = buffer.toString('base64');\r\n        console.log('File converted to base64 successfully');\r\n      } catch (error) {\r\n        console.error('Error converting file to base64:', error);\r\n        // Continue without base64 content, Colivara service will fall back to URL\r\n        base64Content = undefined;\r\n      }\r\n\r\n      // Create the document in the database\r\n      console.log('Creating document in database...');\r\n      // Use default category since it's no longer provided in form\r\n      const defaultCategory = \"Uncategorized\";\r\n      \r\n      const document = await enhancedDocumentService.createDocument(\r\n        title,\r\n        description || \"\", // Ensure description is not null\r\n        defaultCategory,\r\n        tagArray,\r\n        user.email, // Using email as name for now\r\n        fileUrl,\r\n        fileName,\r\n        fileType,\r\n        fileSize,\r\n        userId,\r\n        unitId || undefined, // NEW: Pass unitId if provided\r\n        base64Content, // NEW: Pass base64 content for Colivara processing\r\n        blobName // NEW: Pass blob name\r\n      );\r\n      console.log('Document created successfully:', document.id);\r\n\r\n      return NextResponse.json(document, { status: 201 });\r\n    } catch (storageError) {\r\n      console.error('Error in file storage or document creation:', storageError);\r\n      const errorMessage = storageError instanceof Error ? storageError.message : 'Failed to create document';\r\n      // Check if this is specifically a file storage error to return a more specific status\r\n      if (storageError instanceof Error && storageError.message.includes('Failed to upload file to')) {\r\n        return NextResponse.json(\r\n          { error: `File upload failed: ${storageError.message}` },\r\n          { status: 500 }\r\n        );\r\n      } else if (storageError instanceof Error && storageError.message.includes('Error accessing file')) {\r\n        return NextResponse.json(\r\n          { error: `File access error: ${storageError.message}` },\r\n          { status: 500 }\r\n        );\r\n      } else {\r\n        return NextResponse.json(\r\n          { error: errorMessage },\r\n          { status: 500 }\r\n        );\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error creating document:', error);\r\n    if (error instanceof Error) {\r\n      if (error.message.includes('Unauthorized') || error.message.includes('Forbidden')) {\r\n        return NextResponse.json(\r\n          { error: error.message },\r\n          { status: 401 }\r\n        );\r\n      } else if (error.message.includes('malicious')) {\r\n        return NextResponse.json(\r\n          { error: 'File contains potentially malicious content and cannot be uploaded' },\r\n          { status: 400 }\r\n        );\r\n      } else if (error.message.includes('token')) {\r\n        return NextResponse.json(\r\n          { error: 'Authentication token is invalid or expired' },\r\n          { status: 401 }\r\n        );\r\n      } else if (error.message.includes('Failed to upload file to')) {\r\n        return NextResponse.json(\r\n          { error: `File upload failed: ${error.message}` },\r\n          { status: 500 }\r\n        );\r\n      } else {\r\n        return NextResponse.json(\r\n          { error: error.message },\r\n          { status: 400 }\r\n        );\r\n      }\r\n    }\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}"],"names":[],"mappings":"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"}}]
}