{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/jwt-service.ts"],"sourcesContent":["// This service is for handling custom JWT tokens for database authentication\r\n\r\nexport interface TokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n  iat: number;\r\n  exp: number;\r\n}\r\n\r\nclass JWTService {\r\n  private readonly secret: string;\r\n\r\n  constructor() {\r\n    this.secret = process.env.JWT_SECRET || '6dFk5d0vbyLnZC0Amy83LtI47DsNr/KB4M+FgbUc6njd4cjk7XB2/8nTuhQDWW8OOgQ6fI74huxJE3a/RP2giw==';\r\n  }\r\n\r\n  /**\r\n   * Convert a string to a Uint8Array (which can be used with Web Crypto API)\r\n   */\r\n private stringToUint8Array(str: string): Uint8Array {\r\n    return new TextEncoder().encode(str);\r\n }\r\n\r\n /**\r\n  * Convert a Uint8Array to a base64url encoded string\r\n  */\r\n private uint8ArrayToBase64Url(uint8Array: Uint8Array): string {\r\n   let binary = '';\r\n   for (let i = 0; i < uint8Array.byteLength; i++) {\r\n     binary += String.fromCharCode(uint8Array[i]);\r\n   }\r\n   return btoa(binary)\r\n     .replace(/\\+/g, '-')\r\n     .replace(/\\//g, '_')\r\n     .replace(/=/g, '');\r\n }\r\n\r\n  /**\r\n   * Import the secret as a CryptoKey for use with Web Crypto API\r\n   */\r\n  private async importSecret(): Promise<CryptoKey> {\r\n    const encoder = new TextEncoder();\r\n    const keyBuffer = encoder.encode(this.secret);\r\n    \r\n    return await crypto.subtle.importKey(\r\n      'raw',\r\n      keyBuffer,\r\n      { name: 'HMAC', hash: 'SHA-256' },\r\n      false,\r\n      ['sign', 'verify']\r\n    );\r\n  }\r\n\r\n /**\r\n   * Generate a JWT token using Web Crypto API\r\n   */\r\n  async generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): Promise<string> {\r\n    try {\r\n      // Create the header\r\n      const header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n      };\r\n\r\n      // Add timestamp and expiration (1 hour from now)\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const expiration = timestamp + 3600; // 1 hour in seconds\r\n\r\n      // Create the payload with the provided data and timestamps\r\n      const fullPayload = {\r\n        ...payload,\r\n        iat: timestamp,\r\n        exp: expiration\r\n      };\r\n\r\n      // Encode header and payload to base64url\r\n      const encodedHeader = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(header))\r\n      );\r\n      const encodedPayload = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(fullPayload))\r\n      );\r\n\r\n      // Create the signing input\r\n      const signingInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Create signing input buffer in the proper format for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const signingInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Sign the token - use type assertion to handle TypeScript compatibility issues\r\n      const signatureBuffer = await crypto.subtle.sign(\r\n        'HMAC',\r\n        key,\r\n        signingInputBuffer as BufferSource\r\n      );\r\n\r\n      // Encode the signature - signatureBuffer is an ArrayBuffer, convert to base64url\r\n      const signatureUint8Array = new Uint8Array(signatureBuffer);\r\n      const encodedSignature = this.uint8ArrayToBase64Url(signatureUint8Array);\r\n\r\n      // Return the complete JWT token\r\n      return `${signingInput}.${encodedSignature}`;\r\n    } catch (error) {\r\n      console.error('JWT token generation failed:', error);\r\n      throw new Error('Failed to generate JWT token');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a JWT token using Web Crypto API\r\n   */\r\n  async verifyToken(token: string): Promise<TokenPayload | null> {\r\n    try {\r\n      // Check if token is valid before attempting to verify\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        console.error('Invalid token provided for verification');\r\n        return null;\r\n      }\r\n      \r\n      // Check if token has proper format (3 parts separated by dots)\r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const [encodedHeader, encodedPayload, encodedSignature] = tokenParts;\r\n\r\n      // Decode header\r\n      const decodedHeader = this.base64UrlDecode(encodedHeader);\r\n      if (!decodedHeader) {\r\n        console.error('Failed to decode token header');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const decodedPayloadStr = this.base64UrlDecode(encodedPayload);\r\n      if (!decodedPayloadStr) {\r\n        console.error('Failed to decode token payload');\r\n        return null;\r\n      }\r\n\r\n      // Parse payload\r\n      const payloadObj = JSON.parse(decodedPayloadStr) as TokenPayload;\r\n      \r\n      // Check if token is expired\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      if (payloadObj.exp && payloadObj.exp < currentTime) {\r\n        console.error('Token has expired');\r\n        return null;\r\n      }\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Verify the signature\r\n      const isValid = await this.verifySignature(\r\n        `${encodedHeader}.${encodedPayload}`,\r\n        encodedSignature,\r\n        key\r\n      );\r\n\r\n      if (!isValid) {\r\n        console.error('Token signature verification failed');\r\n        return null;\r\n      }\r\n\r\n      return payloadObj;\r\n    } catch (error: any) {\r\n      console.error('Token verification failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify the JWT signature using Web Crypto API\r\n   */\r\n  private async verifySignature(\r\n    signingInput: string,\r\n    signature: string,\r\n    key: CryptoKey\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Decode the signature from base64url to Uint8Array\r\n      const signatureBytes = this.base64UrlDecodeToUint8Array(signature);\r\n      if (!signatureBytes) {\r\n        return false;\r\n      }\r\n\r\n      // Create proper buffers for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const verificationInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Use ArrayBufferView for signatureBytes and input buffer\r\n      // Cast to appropriate types to handle TypeScript issues\r\n      const signatureView = new Uint8Array(signatureBytes.buffer, signatureBytes.byteOffset, signatureBytes.byteLength);\r\n      const inputView = new Uint8Array(verificationInputBuffer.buffer, verificationInputBuffer.byteOffset, verificationInputBuffer.byteLength);\r\n      \r\n      // Verify the signature - use type assertion to handle TypeScript compatibility issues\r\n      const isValid = await crypto.subtle.verify(\r\n        'HMAC',\r\n        key,\r\n        signatureView as BufferSource,\r\n        inputView as BufferSource\r\n      );\r\n\r\n      return isValid;\r\n    } catch (error) {\r\n      console.error('Signature verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Decode a JWT token without verification (for edge runtime compatibility)\r\n   * This only extracts the payload without validating the signature\r\n   * Use carefully - only for non-sensitive operations like checking expiration\r\n   */\r\n  decodeToken(token: string): TokenPayload | null {\r\n    try {\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        return null;\r\n      }\r\n      \r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const payload = tokenParts[1];\r\n      const decodedPayload = this.base64UrlDecode(payload);\r\n      if (!decodedPayload) {\r\n        return null;\r\n      }\r\n      \r\n      return JSON.parse(decodedPayload) as TokenPayload;\r\n    } catch (error: any) {\r\n      console.error('Token decoding failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token is expired without full verification\r\n   * This uses the decode method which doesn't require the secret\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      const decoded = this.decodeToken(token);\r\n      if (!decoded || !decoded.exp) {\r\n        return true; // If we can't decode or there's no expiration, consider it expired\r\n      }\r\n      // Compare expiration timestamp with current time (in seconds)\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      return decoded.exp < currentTime;\r\n    } catch (error) {\r\n      console.error('Error checking token expiration:', error);\r\n      return true; // If there's an error, assume token is expired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url encoded strings\r\n   */\r\n  private base64UrlDecode(str: string): string | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      return decodeURIComponent(escape(rawData));\r\n    } catch (error) {\r\n      console.error('Base64 URL decode error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url string to Uint8Array\r\n   */\r\n  private base64UrlDecodeToUint8Array(str: string): Uint8Array | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      \r\n      const buffer = new Uint8Array(rawData.length);\r\n      for (let i = 0; i < rawData.length; i++) {\r\n        buffer[i] = rawData.charCodeAt(i);\r\n      }\r\n      \r\n      return buffer;\r\n    } catch (error) {\r\n      console.error('Base64 URL decode to Uint8Array error:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new JWTService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\n// Create Prisma client instance\r\nconst createPrismaClient = () => {\r\n  return new PrismaClient({\r\n    log: ['query', 'info', 'warn', 'error'], // Enable detailed logging\r\n  })\r\n}\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined\r\n}\r\n\r\n// Use the global instance in development to prevent exceeding connection limits\r\nconst client = globalThis.prisma || createPrismaClient()\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = client\r\n\r\nexport default client"],"names":[],"mappings":";;;;AAAA;;AAEA,gCAAgC;AAChC,MAAM,qBAAqB;IACzB,OAAO,IAAI,6IAAY,CAAC;QACtB,KAAK;YAAC;YAAS;YAAQ;YAAQ;SAAQ;IACzC;AACF;AAOA,gFAAgF;AAChF,MAAM,SAAS,WAAW,MAAM,IAAI;AACpC,wCAA2C,WAAW,MAAM,GAAG;uCAEhD"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/utils/rbac.ts"],"sourcesContent":["/**\r\n * Role-Based Access Control (RBAC) utilities for LSPU KMIS\r\n * Defines role hierarchies and permission checks\r\n */\r\n\r\nexport type UserRole = 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL';\r\n\r\n// Define role hierarchy - ADMIN has highest privileges, followed by FACULTY, STUDENT, then EXTERNAL\r\nconst ROLE_HIERARCHY: Record<UserRole, number> = {\r\n  'ADMIN': 4,\r\n  'FACULTY': 3,\r\n  'STUDENT': 2,\r\n  'EXTERNAL': 1\r\n};\r\n\r\n/**\r\n * Check if a user has a specific role\r\n */\r\nexport function hasRole(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return userRole === requiredRole;\r\n}\r\n\r\n/**\r\n * Check if a user has any of the specified roles\r\n */\r\nexport function hasAnyRole(userRole: UserRole, requiredRoles: UserRole[]): boolean {\r\n  return requiredRoles.includes(userRole);\r\n}\r\n\r\n/**\r\n * Check if a user's role has higher or equal hierarchy than required role\r\n */\r\nexport function hasRoleHierarchy(userRole: UserRole, requiredRole: UserRole): boolean {\r\n  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];\r\n}\r\n\r\n/**\r\n * Check if user has admin privileges\r\n */\r\nexport function isAdmin(userRole: UserRole): boolean {\r\n  return userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has faculty privileges\r\n */\r\nexport function isFaculty(userRole: UserRole): boolean {\r\n  return userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has student privileges\r\n */\r\nexport function isStudent(userRole: UserRole): boolean {\r\n  return userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Check if user has external privileges\r\n */\r\nexport function isExternal(userRole: UserRole): boolean {\r\n  return userRole === 'EXTERNAL' || userRole === 'STUDENT' || userRole === 'FACULTY' || userRole === 'ADMIN';\r\n}\r\n\r\n/**\r\n * Get allowed actions based on user role\r\n */\r\nexport function getAllowedActions(userRole: UserRole): string[] {\r\n  switch (userRole) {\r\n    case 'ADMIN':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'DELETE_DOCUMENT',\r\n        'CREATE_USER',\r\n        'READ_USER',\r\n        'UPDATE_USER',\r\n        'DELETE_USER',\r\n        'CREATE_UNIT',\r\n        'READ_UNIT',\r\n        'UPDATE_UNIT',\r\n        'DELETE_UNIT',\r\n        'MANAGE_PERMISSIONS',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'FACULTY':\r\n      return [\r\n        'CREATE_DOCUMENT',\r\n        'READ_DOCUMENT',\r\n        'UPDATE_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT',\r\n        'VIEW_ANALYTICS'\r\n      ];\r\n    case 'STUDENT':\r\n      return [\r\n        'READ_DOCUMENT',\r\n        'READ_USER',\r\n        'READ_UNIT'\r\n      ];\r\n    case 'EXTERNAL':\r\n      return [\r\n        'READ_DOCUMENT'\r\n      ];\r\n    default:\r\n      return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a user has permission to perform an action\r\n */\r\nexport function hasPermission(userRole: UserRole, action: string): boolean {\r\n  const allowedActions = getAllowedActions(userRole);\r\n  return allowedActions.includes(action);\r\n}\r\n\r\n/**\r\n * Get all roles that can perform a specific action\r\n */\r\nexport function getRolesForAction(action: string): UserRole[] {\r\n  const roles: UserRole[] = [];\r\n  (Object.keys(ROLE_HIERARCHY) as UserRole[]).forEach(role => {\r\n    if (hasPermission(role, action)) {\r\n      roles.push(role);\r\n    }\r\n  });\r\n  return roles;\r\n}"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;;;AAID,oGAAoG;AACpG,MAAM,iBAA2C;IAC/C,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY;AACd;AAKO,SAAS,QAAQ,QAAkB,EAAE,YAAsB;IAChE,OAAO,aAAa;AACtB;AAKO,SAAS,WAAW,QAAkB,EAAE,aAAyB;IACtE,OAAO,cAAc,QAAQ,CAAC;AAChC;AAKO,SAAS,iBAAiB,QAAkB,EAAE,YAAsB;IACzE,OAAO,cAAc,CAAC,SAAS,IAAI,cAAc,CAAC,aAAa;AACjE;AAKO,SAAS,QAAQ,QAAkB;IACxC,OAAO,aAAa;AACtB;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa;AAChD;AAKO,SAAS,UAAU,QAAkB;IAC1C,OAAO,aAAa,aAAa,aAAa,aAAa,aAAa;AAC1E;AAKO,SAAS,WAAW,QAAkB;IAC3C,OAAO,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa;AACrG;AAKO,SAAS,kBAAkB,QAAkB;IAClD,OAAQ;QACN,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;gBACA;gBACA;aACD;QACH,KAAK;YACH,OAAO;gBACL;aACD;QACH;YACE,OAAO,EAAE;IACb;AACF;AAKO,SAAS,cAAc,QAAkB,EAAE,MAAc;IAC9D,MAAM,iBAAiB,kBAAkB;IACzC,OAAO,eAAe,QAAQ,CAAC;AACjC;AAKO,SAAS,kBAAkB,MAAc;IAC9C,MAAM,QAAoB,EAAE;IAC3B,OAAO,IAAI,CAAC,gBAA+B,OAAO,CAAC,CAAA;QAClD,IAAI,cAAc,MAAM,SAAS;YAC/B,MAAM,IAAI,CAAC;QACb;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/middleware/auth-middleware.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { NextResponse } from 'next/server';\r\nimport jwtService from '@/lib/services/jwt-service';\r\nimport prisma from '@/lib/prisma';\r\nimport { hasAnyRole, type UserRole } from '@/lib/utils/rbac';\r\n\r\nexport async function requireAuth(request: NextRequest, roles?: string[]): Promise<{ user: any } | NextResponse> {\r\n  // Extract the token from the Authorization header or cookies\r\n  const authHeader = request.headers.get('authorization');\r\n  let token = null;\r\n  \r\n  if (authHeader && authHeader.startsWith('Bearer ')) {\r\n    token = authHeader.substring(7);\r\n  } else {\r\n    // Try to get token from cookies\r\n    const cookies = request.cookies;\r\n    token = cookies.get('access_token')?.value;\r\n  }\r\n\r\n  if (!token) {\r\n    // For API routes, return a 401 response instead of redirecting\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });\r\n    }\r\n    // For regular routes, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n  }\r\n\r\n  // Verify the JWT token\r\n  const decoded = await jwtService.verifyToken(token);\r\n  if (!decoded) {\r\n    console.error('Token verification failed:', token ? token.substring(0, 20) + '...' : 'null');\r\n    // Token is invalid, return appropriate response based on request type\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 });\r\n    } else {\r\n      // For regular routes, redirect to login\r\n      const response = NextResponse.redirect(new URL('/', request.url));\r\n      return response;\r\n    }\r\n }\r\n\r\n  console.log('Decoded token:', decoded);\r\n\r\n  // Check if decoded.userId is valid\r\n  if (!decoded.userId) {\r\n    console.error('Token does not contain userId:', decoded);\r\n    // Token doesn't contain a valid userId, return error\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'Invalid token: missing user ID' }, { status: 401 });\r\n    }\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Get user profile from database using the user ID from the token\r\n  const user = await prisma.user.findUnique({\r\n    where: {\r\n      id: decoded.userId,\r\n    },\r\n    select: {\r\n      id: true,\r\n      email: true,\r\n      name: true,\r\n      role: true,\r\n      unitId: true,\r\n    }\r\n  });\r\n\r\n  if (!user) {\r\n    console.error('User not found with ID from token:', decoded.userId);\r\n    // User doesn't exist in the database, redirect to login\r\n    const response = NextResponse.redirect(new URL('/login', request.url));\r\n    return response;\r\n }\r\n\r\n  // Check if user has required roles\r\n  if (roles && roles.length > 0 && !hasAnyRole(user.role as UserRole, roles as UserRole[])) {\r\n    // User doesn't have required role, return error for API routes\r\n    if (request.nextUrl.pathname.startsWith('/api/')) {\r\n      return NextResponse.json({ error: 'User does not have required role to perform this action' }, { status: 403 });\r\n    }\r\n    // For regular routes, redirect to unauthorized page\r\n    const response = NextResponse.redirect(new URL('/unauthorized', request.url));\r\n    return response;\r\n  }\r\n\r\n  return { user };\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEO,eAAe,YAAY,OAAoB,EAAE,KAAgB;IACtE,6DAA6D;IAC7D,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,QAAQ;IAEZ,IAAI,cAAc,WAAW,UAAU,CAAC,YAAY;QAClD,QAAQ,WAAW,SAAS,CAAC;IAC/B,OAAO;QACL,gCAAgC;QAChC,MAAM,UAAU,QAAQ,OAAO;QAC/B,QAAQ,QAAQ,GAAG,CAAC,iBAAiB;IACvC;IAEA,IAAI,CAAC,OAAO;QACV,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QACA,wCAAwC;QACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACT;IAEA,uBAAuB;IACvB,MAAM,UAAU,MAAM,8IAAU,CAAC,WAAW,CAAC;IAC7C,IAAI,CAAC,SAAS;QACZ,QAAQ,KAAK,CAAC,8BAA8B,QAAQ,MAAM,SAAS,CAAC,GAAG,MAAM,QAAQ;QACrF,sEAAsE;QACtE,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAChF,OAAO;YACL,wCAAwC;YACxC,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;YAC/D,OAAO;QACT;IACH;IAEC,QAAQ,GAAG,CAAC,kBAAkB;IAE9B,mCAAmC;IACnC,IAAI,CAAC,QAAQ,MAAM,EAAE;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,qDAAqD;QACrD,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiC,GAAG;gBAAE,QAAQ;YAAI;QACtF;QACA,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,kEAAkE;IAClE,MAAM,OAAO,MAAM,0HAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YACL,IAAI,QAAQ,MAAM;QACpB;QACA,QAAQ;YACN,IAAI;YACJ,OAAO;YACP,MAAM;YACN,MAAM;YACN,QAAQ;QACV;IACF;IAEA,IAAI,CAAC,MAAM;QACT,QAAQ,KAAK,CAAC,sCAAsC,QAAQ,MAAM;QAClE,wDAAwD;QACxD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,OAAO;IACV;IAEC,mCAAmC;IACnC,IAAI,SAAS,MAAM,MAAM,GAAG,KAAK,CAAC,IAAA,oIAAU,EAAC,KAAK,IAAI,EAAc,QAAsB;QACxF,+DAA+D;QAC/D,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU;YAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0D,GAAG;gBAAE,QAAQ;YAAI;QAC/G;QACA,oDAAoD;QACpD,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;QAC3E,OAAO;IACT;IAEA,OAAO;QAAE;IAAK;AAChB"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/app/api/analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireAuth } from '@/lib/middleware/auth-middleware';\r\nimport prisma from '@/lib/prisma';\r\n\r\nexport async function GET(request: NextRequest) {\r\n  // Require authentication\r\n  const authResult = await requireAuth(request);\r\n  if ('status' in authResult) {\r\n    return authResult;\r\n  }\r\n  \r\n  const { user } = authResult;\r\n\r\n  try {\r\n    // Get basic stats based on user role\r\n    let totalDocuments = 0;\r\n    let totalUsers = 0;\r\n    let totalDownloads = 0;\r\n    let totalViews = 0;\r\n    let recentActivity: any[] = [];\r\n    let categoryDistribution: any[] = [];\r\n    let popularDocuments: any[] = [];\r\n\r\n    if (user.role === 'ADMIN') {\r\n      // Admin can see all stats\r\n      totalDocuments = await prisma.document.count();\r\n      totalUsers = await prisma.user.count();\r\n      \r\n      // Get total downloads and views from all documents\r\n      const documents = await prisma.document.findMany({\r\n        select: {\r\n          downloadsCount: true,\r\n          viewsCount: true,\r\n        },\r\n      });\r\n      \r\n      totalDownloads = documents.reduce((sum, doc) => sum + (doc.downloadsCount || 0), 0);\r\n      totalViews = documents.reduce((sum, doc) => sum + (doc.viewsCount || 0), 0);\r\n\r\n      // Get category distribution\r\n      const categories = await prisma.document.groupBy({\r\n        by: ['category'],\r\n        _count: {\r\n          category: true,\r\n        },\r\n        orderBy: {\r\n          _count: {\r\n            category: 'desc',\r\n          },\r\n        },\r\n        take: 10,\r\n      });\r\n\r\n      categoryDistribution = categories.map((cat) => ({\r\n        category: cat.category || 'Uncategorized',\r\n        count: cat._count.category,\r\n      }));\r\n\r\n      // Get popular documents\r\n      const topDocs = await prisma.document.findMany({\r\n        orderBy: {\r\n          downloadsCount: 'desc',\r\n        },\r\n        take: 5,\r\n        select: {\r\n          id: true,\r\n          title: true,\r\n          downloadsCount: true,\r\n          viewsCount: true,\r\n        },\r\n      });\r\n\r\n      popularDocuments = topDocs.map(doc => ({\r\n        id: doc.id,\r\n        title: doc.title,\r\n        downloads: doc.downloadsCount,\r\n        views: doc.viewsCount,\r\n      }));\r\n\r\n      // Get recent activity (simple version using document createdAt)\r\n      const recentDocs = await prisma.document.findMany({\r\n        orderBy: {\r\n          createdAt: 'desc',\r\n        },\r\n        take: 10,\r\n        select: {\r\n          id: true,\r\n          title: true,\r\n          createdAt: true,\r\n          uploadedByUser: {\r\n            select: {\r\n              name: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      recentActivity = recentDocs.map((doc) => ({\r\n        id: doc.id,\r\n        description: `New document uploaded: ${doc.title}`,\r\n        user: doc.uploadedByUser?.name || 'Unknown',\r\n        timestamp: doc.createdAt,\r\n        type: 'upload',\r\n      }));\r\n\r\n    } else if (user.role === 'FACULTY') {\r\n      // Faculty can see their unit's stats\r\n      const userWithUnit = await prisma.user.findUnique({\r\n        where: { id: user.id },\r\n        select: { unitId: true },\r\n      });\r\n\r\n      if (userWithUnit?.unitId) {\r\n        totalDocuments = await prisma.document.count({\r\n          where: { unitId: userWithUnit.unitId },\r\n        });\r\n\r\n        const documents = await prisma.document.findMany({\r\n          where: { unitId: userWithUnit.unitId },\r\n          select: {\r\n            downloadsCount: true,\r\n            viewsCount: true,\r\n          },\r\n        });\r\n\r\n        totalDownloads = documents.reduce((sum, doc) => sum + (doc.downloadsCount || 0), 0);\r\n        totalViews = documents.reduce((sum, doc) => sum + (doc.viewsCount || 0), 0);\r\n\r\n        // Get recent documents from their unit\r\n        const recentDocs = await prisma.document.findMany({\r\n          where: { unitId: userWithUnit.unitId },\r\n          orderBy: {\r\n            createdAt: 'desc',\r\n          },\r\n          take: 10,\r\n          select: {\r\n            id: true,\r\n            title: true,\r\n            createdAt: true,\r\n            uploadedByUser: {\r\n              select: {\r\n                name: true,\r\n              },\r\n            },\r\n          },\r\n        });\r\n\r\n        recentActivity = recentDocs.map((doc) => ({\r\n          id: doc.id,\r\n          description: `New document uploaded: ${doc.title}`,\r\n          user: doc.uploadedByUser?.name || 'Unknown',\r\n          timestamp: doc.createdAt,\r\n          type: 'upload',\r\n        }));\r\n      }\r\n\r\n      // Faculty can see total users in system\r\n      totalUsers = await prisma.user.count();\r\n    } else {\r\n      // Students and external users see limited stats\r\n      totalDocuments = await prisma.document.count({\r\n        where: {\r\n          status: 'ACTIVE',\r\n        },\r\n      });\r\n\r\n      // Get recent active documents\r\n      const recentDocs = await prisma.document.findMany({\r\n        where: {\r\n          status: 'ACTIVE',\r\n        },\r\n        orderBy: {\r\n          createdAt: 'desc',\r\n        },\r\n        take: 5,\r\n        select: {\r\n          id: true,\r\n          title: true,\r\n          createdAt: true,\r\n          uploadedByUser: {\r\n            select: {\r\n              name: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      recentActivity = recentDocs.map((doc) => ({\r\n        id: doc.id,\r\n        description: `New document available: ${doc.title}`,\r\n        user: doc.uploadedByUser?.name || 'Unknown',\r\n        timestamp: doc.createdAt,\r\n        type: 'upload',\r\n      }));\r\n    }\r\n\r\n    return NextResponse.json({\r\n      totalDocuments,\r\n      totalUsers,\r\n      totalDownloads,\r\n      totalViews,\r\n      recentActivity,\r\n      popularDocuments,\r\n      categoryDistribution,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching analytics:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to fetch analytics data' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}