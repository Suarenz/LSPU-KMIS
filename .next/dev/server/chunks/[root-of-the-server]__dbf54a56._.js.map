{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\n// Create Prisma client instance\r\nconst createPrismaClient = () => {\r\n  return new PrismaClient({\r\n    log: ['query', 'info', 'warn', 'error'], // Enable detailed logging\r\n  })\r\n}\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined\r\n}\r\n\r\n// Use the global instance in development to prevent exceeding connection limits\r\nconst client = globalThis.prisma || createPrismaClient()\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = client\r\n\r\nexport default client"],"names":[],"mappings":";;;;AAAA;;AAEA,gCAAgC;AAChC,MAAM,qBAAqB;IACzB,OAAO,IAAI,6IAAY,CAAC;QACtB,KAAK;YAAC;YAAS;YAAQ;YAAQ;SAAQ;IACzC;AACF;AAOA,gFAAgF;AAChF,MAAM,SAAS,WAAW,MAAM,IAAI;AACpC,wCAA2C,WAAW,MAAM,GAAG;uCAEhD"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/password-service.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\r\n\r\nexport class PasswordService {\r\n  private readonly saltRounds: number;\r\n\r\n  constructor() {\r\n    this.saltRounds = parseInt(process.env.SALT_ROUNDS || '12');\r\n  }\r\n\r\n  async hashPassword(password: string): Promise<string> {\r\n    return await bcrypt.hash(password, this.saltRounds);\r\n  }\r\n\r\n  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\r\n    return await bcrypt.compare(password, hashedPassword);\r\n  }\r\n}\r\n\r\nexport default new PasswordService();"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM;IACM,WAAmB;IAEpC,aAAc;QACZ,IAAI,CAAC,UAAU,GAAG,SAAS,QAAQ,GAAG,CAAC,WAAW,IAAI;IACxD;IAEA,MAAM,aAAa,QAAgB,EAAmB;QACpD,OAAO,MAAM,8IAAM,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,UAAU;IACpD;IAEA,MAAM,eAAe,QAAgB,EAAE,cAAsB,EAAoB;QAC/E,OAAO,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU;IACxC;AACF;uCAEe,IAAI"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/lib/services/jwt-service.ts"],"sourcesContent":["// This service is for handling custom JWT tokens for database authentication\r\n\r\nexport interface TokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n  iat: number;\r\n  exp: number;\r\n}\r\n\r\nclass JWTService {\r\n  private readonly secret: string;\r\n\r\n  constructor() {\r\n    this.secret = process.env.JWT_SECRET || '6dFk5d0vbyLnZC0Amy83LtI47DsNr/KB4M+FgbUc6njd4cjk7XB2/8nTuhQDWW8OOgQ6fI74huxJE3a/RP2giw==';\r\n  }\r\n\r\n  /**\r\n   * Convert a string to a Uint8Array (which can be used with Web Crypto API)\r\n   */\r\n private stringToUint8Array(str: string): Uint8Array {\r\n    return new TextEncoder().encode(str);\r\n }\r\n\r\n /**\r\n  * Convert a Uint8Array to a base64url encoded string\r\n  */\r\n private uint8ArrayToBase64Url(uint8Array: Uint8Array): string {\r\n   let binary = '';\r\n   for (let i = 0; i < uint8Array.byteLength; i++) {\r\n     binary += String.fromCharCode(uint8Array[i]);\r\n   }\r\n   return btoa(binary)\r\n     .replace(/\\+/g, '-')\r\n     .replace(/\\//g, '_')\r\n     .replace(/=/g, '');\r\n }\r\n\r\n  /**\r\n   * Import the secret as a CryptoKey for use with Web Crypto API\r\n   */\r\n  private async importSecret(): Promise<CryptoKey> {\r\n    const encoder = new TextEncoder();\r\n    const keyBuffer = encoder.encode(this.secret);\r\n    \r\n    return await crypto.subtle.importKey(\r\n      'raw',\r\n      keyBuffer,\r\n      { name: 'HMAC', hash: 'SHA-256' },\r\n      false,\r\n      ['sign', 'verify']\r\n    );\r\n  }\r\n\r\n /**\r\n   * Generate a JWT token using Web Crypto API\r\n   */\r\n  async generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): Promise<string> {\r\n    try {\r\n      // Create the header\r\n      const header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n      };\r\n\r\n      // Add timestamp and expiration (1 hour from now)\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const expiration = timestamp + 3600; // 1 hour in seconds\r\n\r\n      // Create the payload with the provided data and timestamps\r\n      const fullPayload = {\r\n        ...payload,\r\n        iat: timestamp,\r\n        exp: expiration\r\n      };\r\n\r\n      // Encode header and payload to base64url\r\n      const encodedHeader = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(header))\r\n      );\r\n      const encodedPayload = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(fullPayload))\r\n      );\r\n\r\n      // Create the signing input\r\n      const signingInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Create signing input buffer in the proper format for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const signingInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Sign the token - use type assertion to handle TypeScript compatibility issues\r\n      const signatureBuffer = await crypto.subtle.sign(\r\n        'HMAC',\r\n        key,\r\n        signingInputBuffer as BufferSource\r\n      );\r\n\r\n      // Encode the signature - signatureBuffer is an ArrayBuffer, convert to base64url\r\n      const signatureUint8Array = new Uint8Array(signatureBuffer);\r\n      const encodedSignature = this.uint8ArrayToBase64Url(signatureUint8Array);\r\n\r\n      // Return the complete JWT token\r\n      return `${signingInput}.${encodedSignature}`;\r\n    } catch (error) {\r\n      console.error('JWT token generation failed:', error);\r\n      throw new Error('Failed to generate JWT token');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a JWT token using Web Crypto API\r\n   */\r\n  async verifyToken(token: string): Promise<TokenPayload | null> {\r\n    try {\r\n      // Check if token is valid before attempting to verify\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        console.error('Invalid token provided for verification');\r\n        return null;\r\n      }\r\n      \r\n      // Check if token has proper format (3 parts separated by dots)\r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const [encodedHeader, encodedPayload, encodedSignature] = tokenParts;\r\n\r\n      // Decode header\r\n      const decodedHeader = this.base64UrlDecode(encodedHeader);\r\n      if (!decodedHeader) {\r\n        console.error('Failed to decode token header');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const decodedPayloadStr = this.base64UrlDecode(encodedPayload);\r\n      if (!decodedPayloadStr) {\r\n        console.error('Failed to decode token payload');\r\n        return null;\r\n      }\r\n\r\n      // Parse payload\r\n      const payloadObj = JSON.parse(decodedPayloadStr) as TokenPayload;\r\n      \r\n      // Check if token is expired\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      if (payloadObj.exp && payloadObj.exp < currentTime) {\r\n        console.error('Token has expired');\r\n        return null;\r\n      }\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Verify the signature\r\n      const isValid = await this.verifySignature(\r\n        `${encodedHeader}.${encodedPayload}`,\r\n        encodedSignature,\r\n        key\r\n      );\r\n\r\n      if (!isValid) {\r\n        console.error('Token signature verification failed');\r\n        return null;\r\n      }\r\n\r\n      return payloadObj;\r\n    } catch (error: any) {\r\n      console.error('Token verification failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify the JWT signature using Web Crypto API\r\n   */\r\n  private async verifySignature(\r\n    signingInput: string,\r\n    signature: string,\r\n    key: CryptoKey\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Decode the signature from base64url to Uint8Array\r\n      const signatureBytes = this.base64UrlDecodeToUint8Array(signature);\r\n      if (!signatureBytes) {\r\n        return false;\r\n      }\r\n\r\n      // Create proper buffers for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const verificationInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Use ArrayBufferView for signatureBytes and input buffer\r\n      // Cast to appropriate types to handle TypeScript issues\r\n      const signatureView = new Uint8Array(signatureBytes.buffer, signatureBytes.byteOffset, signatureBytes.byteLength);\r\n      const inputView = new Uint8Array(verificationInputBuffer.buffer, verificationInputBuffer.byteOffset, verificationInputBuffer.byteLength);\r\n      \r\n      // Verify the signature - use type assertion to handle TypeScript compatibility issues\r\n      const isValid = await crypto.subtle.verify(\r\n        'HMAC',\r\n        key,\r\n        signatureView as BufferSource,\r\n        inputView as BufferSource\r\n      );\r\n\r\n      return isValid;\r\n    } catch (error) {\r\n      console.error('Signature verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Decode a JWT token without verification (for edge runtime compatibility)\r\n   * This only extracts the payload without validating the signature\r\n   * Use carefully - only for non-sensitive operations like checking expiration\r\n   */\r\n  decodeToken(token: string): TokenPayload | null {\r\n    try {\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        return null;\r\n      }\r\n      \r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const payload = tokenParts[1];\r\n      const decodedPayload = this.base64UrlDecode(payload);\r\n      if (!decodedPayload) {\r\n        return null;\r\n      }\r\n      \r\n      return JSON.parse(decodedPayload) as TokenPayload;\r\n    } catch (error: any) {\r\n      console.error('Token decoding failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token is expired without full verification\r\n   * This uses the decode method which doesn't require the secret\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      const decoded = this.decodeToken(token);\r\n      if (!decoded || !decoded.exp) {\r\n        return true; // If we can't decode or there's no expiration, consider it expired\r\n      }\r\n      // Compare expiration timestamp with current time (in seconds)\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      return decoded.exp < currentTime;\r\n    } catch (error) {\r\n      console.error('Error checking token expiration:', error);\r\n      return true; // If there's an error, assume token is expired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url encoded strings\r\n   */\r\n  private base64UrlDecode(str: string): string | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      return decodeURIComponent(escape(rawData));\r\n    } catch (error) {\r\n      console.error('Base64 URL decode error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url string to Uint8Array\r\n   */\r\n  private base64UrlDecodeToUint8Array(str: string): Uint8Array | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      \r\n      const buffer = new Uint8Array(rawData.length);\r\n      for (let i = 0; i < rawData.length; i++) {\r\n        buffer[i] = rawData.charCodeAt(i);\r\n      }\r\n      \r\n      return buffer;\r\n    } catch (error) {\r\n      console.error('Base64 URL decode to Uint8Array error:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new JWTService();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file:///D:/downloads/Downloads%20from%20web/LSPU%20KMIS/app/api/auth/login/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport prisma from '@/lib/prisma';\r\nimport passwordService from '@/lib/services/password-service';\r\nimport jwtService from '@/lib/services/jwt-service';\r\n\r\ninterface LoginRequestBody {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body: LoginRequestBody = await request.json();\r\n    const { email, password } = body;\r\n\r\n    // Validate input\r\n    if (!email || !password) {\r\n      return NextResponse.json(\r\n        { error: 'Email and password are required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Find user by email in the database\r\n    const user = await prisma.user.findUnique({\r\n      where: {\r\n        email: email,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid email or password' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Verify password\r\n    if (!user.password) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid email or password' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n    \r\n    const isValidPassword = await passwordService.verifyPassword(password, user.password);\r\n    if (!isValidPassword) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid email or password' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Generate JWT token\r\n    const token = await jwtService.generateToken({\r\n      userId: user.id,\r\n      email: user.email,\r\n      role: user.role,\r\n    });\r\n\r\n    // Return user data and token\r\n    return NextResponse.json({\r\n      success: true,\r\n      token,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        name: user.name,\r\n        role: user.role,\r\n        unitId: user.unitId,\r\n      },\r\n    });\r\n } catch (error) {\r\n    console.error('Login error:', error);\r\n    return NextResponse.json(\r\n      { error: 'An unexpected error occurred during login' },\r\n      { status: 500 }\r\n    );\r\n }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAOO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAyB,MAAM,QAAQ,IAAI;QACjD,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG;QAE5B,iBAAiB;QACjB,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAElB;QAEA,qCAAqC;QACrC,MAAM,OAAO,MAAM,0HAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACxC,OAAO;gBACL,OAAO;YACT;QACF;QAEA,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,IAAI,CAAC,KAAK,QAAQ,EAAE;YAClB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,kBAAkB,MAAM,mJAAe,CAAC,cAAc,CAAC,UAAU,KAAK,QAAQ;QACpF,IAAI,CAAC,iBAAiB;YACpB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,QAAQ,MAAM,8IAAU,CAAC,aAAa,CAAC;YAC3C,QAAQ,KAAK,EAAE;YACf,OAAO,KAAK,KAAK;YACjB,MAAM,KAAK,IAAI;QACjB;QAEA,6BAA6B;QAC7B,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB,MAAM,KAAK,IAAI;gBACf,MAAM,KAAK,IAAI;gBACf,QAAQ,KAAK,MAAM;YACrB;QACF;IACH,EAAE,OAAO,OAAO;QACb,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4C,GACrD;YAAE,QAAQ;QAAI;IAEnB;AACD"}}]
}