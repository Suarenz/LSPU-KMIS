{"version":3,"sources":["../../../lib/utils/qpro-aggregation.ts","../../../lib/services/qpro-cache-service.ts"],"sourcesContent":["export type TargetScope = 'INSTITUTIONAL' | 'PER_UNIT';\r\n\r\nexport type TargetType = 'count' | 'percentage' | 'financial' | 'milestone' | 'text_condition' | string;\r\n\r\nexport interface TimelineDatum {\r\n  year: number;\r\n  target_value: string | number;\r\n}\r\n\r\nexport interface InitiativeLike {\r\n  id: string;\r\n  key_performance_indicator?: {\r\n    outputs?: string;\r\n    outcomes?: string | string[];\r\n  };\r\n  targets?: {\r\n    type?: TargetType;\r\n    unit_basis?: string;\r\n    target_scope?: TargetScope;\r\n    timeline_data?: TimelineDatum[];\r\n  };\r\n}\r\n\r\nexport interface StrategicPlanLike {\r\n  kras?: Array<{\r\n    kra_id: string;\r\n    kra_title?: string;\r\n    initiatives?: InitiativeLike[];\r\n  }>;\r\n}\r\n\r\nexport function toNumberOrNull(value: unknown): number | null {\r\n  if (value === null || value === undefined) return null;\r\n  if (typeof value === 'number') return Number.isFinite(value) ? value : null;\r\n  const cleaned = String(value).replace(/,/g, '').trim();\r\n  if (!cleaned) return null;\r\n  const parsed = Number(cleaned);\r\n  return Number.isFinite(parsed) ? parsed : null;\r\n}\r\n\r\nexport function getTargetValueForYear(timeline: any[] | undefined, year: number): number | null {\r\n  if (!Array.isArray(timeline) || timeline.length === 0) return null;\r\n\r\n  const exact = timeline.find((t: any) => Number(t?.year) === year);\r\n  const exactValue = toNumberOrNull(exact?.target_value);\r\n  if (exactValue !== null) return exactValue;\r\n\r\n  const candidates = timeline\r\n    .map((t: any) => ({ year: Number(t?.year), target: toNumberOrNull(t?.target_value) }))\r\n    .filter((t: any) => Number.isFinite(t.year) && t.target !== null) as Array<{ year: number; target: number }>;\r\n\r\n  const pastOrEqual = candidates.filter((t) => t.year <= year).sort((a, b) => b.year - a.year);\r\n  if (pastOrEqual.length > 0) return pastOrEqual[0].target;\r\n\r\n  const future = candidates.sort((a, b) => a.year - b.year);\r\n  return future.length > 0 ? future[0].target : null;\r\n}\r\n\r\nexport function normalizeInitiativeId(id: string): string {\r\n  return String(id || '').replace(/\\s+/g, '');\r\n}\r\n\r\n/**\r\n * Normalize KRA ID by removing extra spaces and ensuring consistent format.\r\n * Handles: \"KRA5\", \"KRA 5\", \"KRA  5\" â†’ \"KRA 5\" (canonical format in strategic_plan.json)\r\n */\r\nexport function normalizeKraId(kraId: string): string {\r\n  const cleaned = String(kraId || '').trim().replace(/\\s+/g, ' ');\r\n  // Match \"KRA\" followed by number(s), normalize to \"KRA {number}\"\r\n  const match = cleaned.match(/^KRA\\s*(\\d+)$/i);\r\n  if (match) {\r\n    return `KRA ${match[1]}`;\r\n  }\r\n  return cleaned;\r\n}\r\n\r\nexport function findInitiative(\r\n  plan: StrategicPlanLike,\r\n  kraId: string,\r\n  initiativeId: string | undefined | null\r\n): InitiativeLike | null {\r\n  if (!kraId || !initiativeId) return null;\r\n  const kras = plan?.kras || [];\r\n  const normalizedKraId = normalizeKraId(kraId);\r\n  const kra = kras.find((k) => normalizeKraId(k.kra_id) === normalizedKraId);\r\n  if (!kra?.initiatives) return null;\r\n\r\n  const normalizedId = normalizeInitiativeId(String(initiativeId));\r\n  let initiative = kra.initiatives.find((i) => normalizeInitiativeId(String(i.id)) === normalizedId);\r\n\r\n  if (!initiative) {\r\n    const kpiMatch = String(initiativeId).match(/KPI(\\d+)/i);\r\n    if (kpiMatch) {\r\n      initiative = kra.initiatives.find((i) => String(i.id).includes(`KPI${kpiMatch[1]}`));\r\n    }\r\n  }\r\n\r\n  return initiative || null;\r\n}\r\n\r\nexport function getInitiativeTargetMeta(\r\n  plan: StrategicPlanLike,\r\n  kraId: string,\r\n  initiativeId: string | undefined | null,\r\n  year: number\r\n): {\r\n  targetType: TargetType | null;\r\n  targetValue: number | null;\r\n  targetScope: TargetScope;\r\n  unitBasis: string | null;\r\n} {\r\n  const initiative = findInitiative(plan, kraId, initiativeId);\r\n  const targetType = initiative?.targets?.type ?? null;\r\n  const unitBasis = typeof initiative?.targets?.unit_basis === 'string' ? initiative.targets.unit_basis : null;\r\n\r\n  // IMPORTANT DEFAULT:\r\n  // If strategic_plan.json doesn't explicitly specify scope, treat targets as INSTITUTIONAL\r\n  // to prevent accidental inflation (e.g., multiplying by activities/programs).\r\n  const targetScope: TargetScope = initiative?.targets?.target_scope === 'PER_UNIT' ? 'PER_UNIT' : 'INSTITUTIONAL';\r\n\r\n  const timeline = (initiative?.targets?.timeline_data || []) as any[];\r\n  const targetValue = getTargetValueForYear(timeline, year);\r\n\r\n  return { targetType, targetValue, targetScope, unitBasis };\r\n}\r\n\r\nexport interface ActivityValueLike {\r\n  reported?: number | string | null;\r\n  target?: number | string | null;\r\n  dataType?: string | null;\r\n  initiativeId?: string | null;\r\n}\r\n\r\nexport function sumNumbers(values: Array<number | null | undefined>): number {\r\n  return values.reduce<number>(\r\n    (acc, v) => acc + (typeof v === 'number' && Number.isFinite(v) ? v : 0),\r\n    0\r\n  );\r\n}\r\n\r\nexport function averageNumbers(values: Array<number | null | undefined>): number {\r\n  const nums = values.filter((v): v is number => typeof v === 'number' && Number.isFinite(v));\r\n  if (nums.length === 0) return 0;\r\n  return nums.reduce<number>((acc, n) => acc + n, 0) / nums.length;\r\n}\r\n\r\nexport function computeAggregatedAchievement(args: {\r\n  targetType: TargetType | null;\r\n  targetValue: number;\r\n  targetScope?: TargetScope;\r\n  unitMultiplier?: number;\r\n  activities: ActivityValueLike[];\r\n}): {\r\n  totalReported: number;\r\n  totalTarget: number;\r\n  achievementPercent: number;\r\n} {\r\n  const {\r\n    targetType,\r\n    targetValue,\r\n    targetScope = 'INSTITUTIONAL',\r\n    unitMultiplier,\r\n    activities,\r\n  } = args;\r\n\r\n  const normalizedType = String(targetType || '').toLowerCase();\r\n\r\n  // IMPORTANT: targets are applied ONCE per KPI by default.\r\n  // If a KPI explicitly declares PER_UNIT scope, callers should pass a true unitMultiplier\r\n  // (e.g., number of programs/units). We intentionally default to 1 (not activities.length)\r\n  // because an activity count is not the same as a unit count.\r\n  const effectiveTarget =\r\n    targetScope === 'PER_UNIT'\r\n      ? targetValue * (typeof unitMultiplier === 'number' && Number.isFinite(unitMultiplier) ? unitMultiplier : 1)\r\n      : targetValue;\r\n\r\n  // Rate metrics: use mean reported against single target\r\n  if (normalizedType === 'percentage') {\r\n    // Percent KPIs need special handling:\r\n    // - If reported is already 0..100, use it.\r\n    // - If reported is a count (e.g., 154 employed) and activity.target is a denominator (e.g., 200 graduates),\r\n    //   convert to percent: (reported/target)*100.\r\n    // - Ignore invalid values we can't normalize (prevents nonsense like 154% being treated as a percent).\r\n    const toNormalizedPercent = (a: ActivityValueLike): number | null => {\r\n      const reported = toNumberOrNull(a.reported);\r\n      if (reported === null) return null;\r\n\r\n      // Already a valid percent\r\n      if (reported >= 0 && reported <= 100) return reported;\r\n\r\n      // Try to normalize count/denominator into a percent\r\n      const denom = toNumberOrNull(a.target);\r\n      if (denom !== null && denom > 0 && reported >= 0) {\r\n        const pct = (reported / denom) * 100;\r\n        if (pct >= 0 && pct <= 100) return pct;\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    const avgReported = averageNumbers(activities.map(toNormalizedPercent));\r\n    const achievementPercent = effectiveTarget > 0 ? (avgReported / effectiveTarget) * 100 : 0;\r\n    return { totalReported: avgReported, totalTarget: effectiveTarget, achievementPercent };\r\n  }\r\n\r\n  // Financial and counts: additive\r\n  if (normalizedType === 'financial' || normalizedType === 'count') {\r\n    // For COUNT types, if reported values are all 0/null/undefined, \r\n    // assume each activity represents 1 item (e.g., 1 research output)\r\n    const reportedValues = activities.map((a) => toNumberOrNull(a.reported));\r\n    let sumReported = sumNumbers(reportedValues);\r\n    \r\n    // If sum is 0 but we have activities, count each activity as 1 item\r\n    // This handles cases where activities don't have explicit reported values\r\n    if (sumReported === 0 && activities.length > 0 && normalizedType === 'count') {\r\n      sumReported = activities.length;\r\n    }\r\n    \r\n    const achievementPercent = effectiveTarget > 0 ? (sumReported / effectiveTarget) * 100 : 0;\r\n    return { totalReported: sumReported, totalTarget: effectiveTarget, achievementPercent };\r\n  }\r\n\r\n  // Milestone / text_condition: interpret as completed if any reported is truthy\r\n  if (normalizedType === 'milestone' || normalizedType === 'text_condition') {\r\n    const anyReported = activities.some((a) => {\r\n      const v = a.reported;\r\n      if (typeof v === 'number') return v > 0;\r\n      if (typeof v === 'string') return v.trim().length > 0;\r\n      return false;\r\n    });\r\n    const achievementPercent = anyReported ? 100 : 0;\r\n    return { totalReported: anyReported ? 1 : 0, totalTarget: 1, achievementPercent };\r\n  }\r\n\r\n  // Default: treat as additive numeric (count-like behavior)\r\n  const reportedValues = activities.map((a) => toNumberOrNull(a.reported));\r\n  let sumReported = sumNumbers(reportedValues);\r\n  \r\n  // If sum is 0 but we have activities, count each activity as 1 item\r\n  if (sumReported === 0 && activities.length > 0) {\r\n    sumReported = activities.length;\r\n  }\r\n  \r\n  const achievementPercent = effectiveTarget > 0 ? (sumReported / effectiveTarget) * 100 : 0;\r\n  return { totalReported: sumReported, totalTarget: effectiveTarget, achievementPercent };\r\n}\r\n","import { redisService } from './redis-service';\r\n\r\ninterface QProCacheConfig {\r\n  uploadCacheTtl: number; // TTL for upload metadata cache in seconds\r\n  analysisCacheTtl: number; // TTL for analysis results cache in seconds\r\n  processingStatusTtl: number; // TTL for processing status cache in seconds\r\n}\r\n\r\ninterface QProUploadCache {\r\n  documentId: string;\r\n  fileName: string;\r\n  fileSize: number;\r\n  fileType: string;\r\n  fileUrl: string;\r\n  uploadedAt: Date;\r\n  userId: string;\r\n  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED';\r\n}\r\n\r\ninterface QProAnalysisCache {\r\n  documentId: string;\r\n  analysisId: string;\r\n  status: string;\r\n  achievementScore?: number;\r\n  kras?: any[];\r\n  activities?: any[];\r\n  timestamp?: number;\r\n}\r\n\r\nclass QProCacheService {\r\n  private readonly config: QProCacheConfig = {\r\n    uploadCacheTtl: 60 * 60, // 1 hour for upload metadata\r\n    analysisCacheTtl: 24 * 60 * 60, // 24 hours for analysis results\r\n    processingStatusTtl: 30 * 60, // 30 minutes for processing status\r\n  };\r\n\r\n  constructor(config?: Partial<QProCacheConfig>) {\r\n    if (config) {\r\n      this.config = { ...this.config, ...config };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for QPRO upload\r\n   */\r\n  private generateUploadCacheKey(documentId: string): string {\r\n    return `qpro:upload:${documentId}`;\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for QPRO analysis\r\n   */\r\n  private generateAnalysisCacheKey(documentId: string): string {\r\n    return `qpro:analysis:${documentId}`;\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for QPRO processing status\r\n   */\r\n  private generateProcessingStatusCacheKey(analysisId: string): string {\r\n    return `qpro:processing:${analysisId}`;\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for user's QPRO analyses list\r\n   */\r\n  private generateUserAnalysesCacheKey(userId: string): string {\r\n    return `qpro:user:${userId}:analyses`;\r\n  }\r\n\r\n  /**\r\n   * Cache upload metadata\r\n   */\r\n  async cacheUpload(uploadData: QProUploadCache): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateUploadCacheKey(uploadData.documentId);\r\n      await redisService.set(cacheKey, uploadData, this.config.uploadCacheTtl);\r\n      console.log(`[QPRO Cache] Cached upload for document: ${uploadData.documentId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error caching upload:', error);\r\n      // Don't throw - cache is optional\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached upload metadata\r\n   */\r\n  async getUploadCache(documentId: string): Promise<QProUploadCache | null> {\r\n    try {\r\n      const cacheKey = this.generateUploadCacheKey(documentId);\r\n      const cached = await redisService.get<QProUploadCache>(cacheKey);\r\n      if (cached) {\r\n        console.log(`[QPRO Cache] Hit for upload: ${documentId}`);\r\n      }\r\n      return cached;\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error retrieving upload cache:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cache QPRO analysis result\r\n   */\r\n  async cacheAnalysis(analysisData: QProAnalysisCache): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateAnalysisCacheKey(analysisData.documentId);\r\n      const dataWithTimestamp = { ...analysisData, timestamp: Date.now() };\r\n      await redisService.set(cacheKey, dataWithTimestamp, this.config.analysisCacheTtl);\r\n      console.log(`[QPRO Cache] Cached analysis for document: ${analysisData.documentId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error caching analysis:', error);\r\n      // Don't throw - cache is optional\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached analysis result\r\n   */\r\n  async getAnalysisCache(documentId: string): Promise<QProAnalysisCache | null> {\r\n    try {\r\n      const cacheKey = this.generateAnalysisCacheKey(documentId);\r\n      const cached = await redisService.get<QProAnalysisCache>(cacheKey);\r\n      if (cached) {\r\n        console.log(`[QPRO Cache] Hit for analysis: ${documentId}`);\r\n      }\r\n      return cached;\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error retrieving analysis cache:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update processing status cache\r\n   */\r\n  async updateProcessingStatus(analysisId: string, status: string, progress?: number): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateProcessingStatusCacheKey(analysisId);\r\n      const statusData = { analysisId, status, progress: progress || 0, timestamp: Date.now() };\r\n      await redisService.set(cacheKey, statusData, this.config.processingStatusTtl);\r\n      console.log(`[QPRO Cache] Updated processing status for analysis: ${analysisId} - ${status}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error updating processing status:', error);\r\n      // Don't throw - cache is optional\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get processing status from cache\r\n   */\r\n  async getProcessingStatus(analysisId: string): Promise<{ status: string; progress?: number } | null> {\r\n    try {\r\n      const cacheKey = this.generateProcessingStatusCacheKey(analysisId);\r\n      const cached = await redisService.get<any>(cacheKey);\r\n      if (cached) {\r\n        console.log(`[QPRO Cache] Hit for processing status: ${analysisId}`);\r\n        return { status: cached.status, progress: cached.progress };\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error retrieving processing status:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cache user's QPRO analyses list\r\n   */\r\n  async cacheUserAnalyses(userId: string, analyses: any[]): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateUserAnalysesCacheKey(userId);\r\n      await redisService.set(cacheKey, { analyses, timestamp: Date.now() }, this.config.analysisCacheTtl);\r\n      console.log(`[QPRO Cache] Cached ${analyses.length} analyses for user: ${userId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error caching user analyses:', error);\r\n      // Don't throw - cache is optional\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached user analyses list\r\n   */\r\n  async getUserAnalysesCache(userId: string): Promise<any[] | null> {\r\n    try {\r\n      const cacheKey = this.generateUserAnalysesCacheKey(userId);\r\n      const cached = await redisService.get<{ analyses: any[] }>(cacheKey);\r\n      if (cached) {\r\n        console.log(`[QPRO Cache] Hit for user analyses: ${userId}`);\r\n        return cached.analyses;\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error retrieving user analyses cache:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate upload cache for a document\r\n   */\r\n  async invalidateUploadCache(documentId: string): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateUploadCacheKey(documentId);\r\n      await redisService.del(cacheKey);\r\n      console.log(`[QPRO Cache] Invalidated upload cache for document: ${documentId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error invalidating upload cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate analysis cache for a document\r\n   */\r\n  async invalidateAnalysisCache(documentId: string): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateAnalysisCacheKey(documentId);\r\n      await redisService.del(cacheKey);\r\n      console.log(`[QPRO Cache] Invalidated analysis cache for document: ${documentId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error invalidating analysis cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate processing status cache\r\n   */\r\n  async invalidateProcessingStatus(analysisId: string): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateProcessingStatusCacheKey(analysisId);\r\n      await redisService.del(cacheKey);\r\n      console.log(`[QPRO Cache] Invalidated processing status for analysis: ${analysisId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error invalidating processing status:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate user's analyses cache\r\n   */\r\n  async invalidateUserAnalysesCache(userId: string): Promise<void> {\r\n    try {\r\n      const cacheKey = this.generateUserAnalysesCacheKey(userId);\r\n      await redisService.del(cacheKey);\r\n      console.log(`[QPRO Cache] Invalidated user analyses cache for user: ${userId}`);\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error invalidating user analyses cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all QPRO caches for a user\r\n   */\r\n  async invalidateAllUserCaches(userId: string): Promise<void> {\r\n    try {\r\n      const pattern = `qpro:user:${userId}:*`;\r\n      const keys = await redisService.keys(pattern);\r\n      if (keys.length > 0) {\r\n        for (const key of keys) {\r\n          await redisService.del(key);\r\n        }\r\n        console.log(`[QPRO Cache] Invalidated ${keys.length} caches for user: ${userId}`);\r\n      }\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error invalidating all user caches:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics for QPRO\r\n   */\r\n  async getCacheStats(): Promise<{ size: number; keys: string[] }> {\r\n    try {\r\n      const keys = await redisService.keys('qpro:*');\r\n      return {\r\n        size: keys.length,\r\n        keys,\r\n      };\r\n    } catch (error) {\r\n      console.error('[QPRO Cache] Error getting cache stats:', error);\r\n      return { size: 0, keys: [] };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const qproCacheService = new QProCacheService();\r\nexport { QProCacheService };\r\n"],"names":[],"mappings":"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"}