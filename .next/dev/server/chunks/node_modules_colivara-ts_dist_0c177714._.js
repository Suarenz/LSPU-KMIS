module.exports = [
"[project]/node_modules/colivara-ts/dist/base.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * ColiVara
 * Colivara is a suite of services that allows you to store, search, and retrieve documents based on their visual embeddings.      It is a web-first implementation of the ColPali paper using ColQwen2 as backend model. It works exacly like RAG from the end-user standpoint - but using vision models instead of chunking and text-processing for documents.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@colivara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.operationServerMap = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
const axios_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-route] (ecmascript)"));
exports.BASE_PATH = "https://api.colivara.com".replace(/\/+$/, "");
/**
 *
 * @export
 */ exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
/**
 *
 * @export
 * @class BaseAPI
 */ class BaseAPI {
    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default){
        var _a;
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = (_a = configuration.basePath) !== null && _a !== void 0 ? _a : basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */ class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
/**
 *
 * @export
 */ exports.operationServerMap = {};
}),
"[project]/node_modules/colivara-ts/dist/common.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * ColiVara
 * Colivara is a suite of services that allows you to store, search, and retrieve documents based on their visual embeddings.      It is a web-first implementation of the ColPali paper using ColQwen2 as backend model. It works exacly like RAG from the end-user standpoint - but using vision models instead of chunking and text-processing for documents.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@colivara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/colivara-ts/dist/base.js [app-route] (ecmascript)");
/**
 *
 * @export
 */ exports.DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */ const assertParamExists = function(functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
exports.assertParamExists = assertParamExists;
/**
 *
 * @export
 */ const setApiKeyToObject = async function(object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function' ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
exports.setApiKeyToObject = setApiKeyToObject;
/**
 *
 * @export
 */ const setBasicAuthToObject = function(object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = {
            username: configuration.username,
            password: configuration.password
        };
    }
};
exports.setBasicAuthToObject = setBasicAuthToObject;
/**
 *
 * @export
 */ const setBearerAuthToObject = async function(object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function' ? await configuration.accessToken() : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
exports.setBearerAuthToObject = setBearerAuthToObject;
/**
 *
 * @export
 */ const setOAuthToObject = async function(object, name, scopes, configuration) {
    if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function' ? await configuration.accessToken(name, scopes) : await configuration.accessToken;
        object["Authorization"] = "Bearer " + localVarAccessTokenValue;
    }
};
exports.setOAuthToObject = setOAuthToObject;
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (parameter == null) return;
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach((item)=>setFlattenedQueryParams(urlSearchParams, item, key));
        } else {
            Object.keys(parameter).forEach((currentKey)=>setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    } else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        } else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */ const setSearchParams = function(url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
exports.setSearchParams = setSearchParams;
/**
 *
 * @export
 */ const serializeDataIfNeeded = function(value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers['Content-Type']) : nonString;
    return needsSerialization ? JSON.stringify(value !== undefined ? value : {}) : value || "";
};
exports.serializeDataIfNeeded = serializeDataIfNeeded;
/**
 *
 * @export
 */ const toPathString = function(url) {
    return url.pathname + url.search + url.hash;
};
exports.toPathString = toPathString;
/**
 *
 * @export
 */ const createRequestFunction = function(axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH)=>{
        var _a;
        const axiosRequestArgs = {
            ...axiosArgs.options,
            url: (axios.defaults.baseURL ? '' : (_a = configuration === null || configuration === void 0 ? void 0 : configuration.basePath) !== null && _a !== void 0 ? _a : basePath) + axiosArgs.url
        };
        return axios.request(axiosRequestArgs);
    };
};
exports.createRequestFunction = createRequestFunction;
}),
"[project]/node_modules/colivara-ts/dist/api.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * ColiVara
 * Colivara is a suite of services that allows you to store, search, and retrieve documents based on their visual embeddings.      It is a web-first implementation of the ColPali paper using ColQwen2 as backend model. It works exacly like RAG from the end-user standpoint - but using vision models instead of chunking and text-processing for documents.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@colivara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebhookApi = exports.WebhookApiFactory = exports.WebhookApiFp = exports.WebhookApiAxiosParamCreator = exports.SearchApi = exports.SearchApiFactory = exports.SearchApiFp = exports.SearchApiAxiosParamCreator = exports.HelpersApi = exports.HelpersApiFactory = exports.HelpersApiFp = exports.HelpersApiAxiosParamCreator = exports.HealthApi = exports.HealthApiFactory = exports.HealthApiFp = exports.HealthApiAxiosParamCreator = exports.FilterApi = exports.FilterApiFactory = exports.FilterApiFp = exports.FilterApiAxiosParamCreator = exports.EmbeddingsApi = exports.EmbeddingsApiFactory = exports.EmbeddingsApiFp = exports.EmbeddingsApiAxiosParamCreator = exports.DocumentsApi = exports.DocumentsApiFactory = exports.DocumentsApiFp = exports.DocumentsApiAxiosParamCreator = exports.CollectionsApi = exports.CollectionsApiFactory = exports.CollectionsApiFp = exports.CollectionsApiAxiosParamCreator = exports.TaskEnum = exports.OnEnum = exports.LookupEnum = void 0;
const axios_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-route] (ecmascript)"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = __turbopack_context__.r("[project]/node_modules/colivara-ts/dist/common.js [app-route] (ecmascript)");
// @ts-ignore
const base_1 = __turbopack_context__.r("[project]/node_modules/colivara-ts/dist/base.js [app-route] (ecmascript)");
/**
 *
 * @export
 * @enum {string}
 */ exports.LookupEnum = {
    KeyLookup: 'key_lookup',
    Contains: 'contains',
    ContainedBy: 'contained_by',
    HasKey: 'has_key',
    HasKeys: 'has_keys',
    HasAnyKeys: 'has_any_keys'
};
/**
 *
 * @export
 * @enum {string}
 */ exports.OnEnum = {
    Document: 'document',
    Collection: 'collection'
};
/**
 *
 * @export
 * @enum {string}
 */ exports.TaskEnum = {
    Image: 'image',
    Query: 'query'
};
/**
 * CollectionsApi - axios parameter creator
 * @export
 */ const CollectionsApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
         * @summary Create Collection
         * @param {CollectionIn} collectionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsCreateCollection: async (collectionIn, options = {})=>{
            // verify required parameter 'collectionIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsCreateCollection', 'collectionIn', collectionIn);
            const localVarPath = `/v1/collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(collectionIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
         * @summary Delete Collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsDeleteCollection: async (collectionName, options = {})=>{
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsDeleteCollection', 'collectionName', collectionName);
            const localVarPath = `/v1/collections/{collection_name}/`.replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
         * @summary Get Collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsGetCollection: async (collectionName, options = {})=>{
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsGetCollection', 'collectionName', collectionName);
            const localVarPath = `/v1/collections/{collection_name}/`.replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsListCollections: async (options = {})=>{
            const localVarPath = `/v1/collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
         * @summary Partial Update Collection
         * @param {string} collectionName
         * @param {PatchCollectionIn} patchCollectionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsPartialUpdateCollection: async (collectionName, patchCollectionIn, options = {})=>{
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsPartialUpdateCollection', 'collectionName', collectionName);
            // verify required parameter 'patchCollectionIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsPartialUpdateCollection', 'patchCollectionIn', patchCollectionIn);
            const localVarPath = `/v1/collections/{collection_name}/`.replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PATCH',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(patchCollectionIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.CollectionsApiAxiosParamCreator = CollectionsApiAxiosParamCreator;
/**
 * CollectionsApi - functional programming interface
 * @export
 */ const CollectionsApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.CollectionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
         * @summary Create Collection
         * @param {CollectionIn} collectionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsCreateCollection (collectionIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsCreateCollection(collectionIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CollectionsApi.apiViewsCreateCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
         * @summary Delete Collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsDeleteCollection (collectionName, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsDeleteCollection(collectionName, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CollectionsApi.apiViewsDeleteCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
         * @summary Get Collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsGetCollection (collectionName, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsGetCollection(collectionName, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CollectionsApi.apiViewsGetCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsListCollections (options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsListCollections(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CollectionsApi.apiViewsListCollections']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
         * @summary Partial Update Collection
         * @param {string} collectionName
         * @param {PatchCollectionIn} patchCollectionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsPartialUpdateCollection (collectionName, patchCollectionIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CollectionsApi.apiViewsPartialUpdateCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.CollectionsApiFp = CollectionsApiFp;
/**
 * CollectionsApi - factory interface
 * @export
 */ const CollectionsApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.CollectionsApiFp)(configuration);
    return {
        /**
         * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
         * @summary Create Collection
         * @param {CollectionIn} collectionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsCreateCollection (collectionIn, options) {
            return localVarFp.apiViewsCreateCollection(collectionIn, options).then((request)=>request(axios, basePath));
        },
        /**
         * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
         * @summary Delete Collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsDeleteCollection (collectionName, options) {
            return localVarFp.apiViewsDeleteCollection(collectionName, options).then((request)=>request(axios, basePath));
        },
        /**
         * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
         * @summary Get Collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsGetCollection (collectionName, options) {
            return localVarFp.apiViewsGetCollection(collectionName, options).then((request)=>request(axios, basePath));
        },
        /**
         * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsListCollections (options) {
            return localVarFp.apiViewsListCollections(options).then((request)=>request(axios, basePath));
        },
        /**
         * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
         * @summary Partial Update Collection
         * @param {string} collectionName
         * @param {PatchCollectionIn} patchCollectionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsPartialUpdateCollection (collectionName, patchCollectionIn, options) {
            return localVarFp.apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.CollectionsApiFactory = CollectionsApiFactory;
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */ class CollectionsApi extends base_1.BaseAPI {
    /**
     * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
     * @summary Create Collection
     * @param {CollectionIn} collectionIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */ apiViewsCreateCollection(collectionIn, options) {
        return (0, exports.CollectionsApiFp)(this.configuration).apiViewsCreateCollection(collectionIn, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */ apiViewsDeleteCollection(collectionName, options) {
        return (0, exports.CollectionsApiFp)(this.configuration).apiViewsDeleteCollection(collectionName, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
     * @summary Get Collection
     * @param {string} collectionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */ apiViewsGetCollection(collectionName, options) {
        return (0, exports.CollectionsApiFp)(this.configuration).apiViewsGetCollection(collectionName, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */ apiViewsListCollections(options) {
        return (0, exports.CollectionsApiFp)(this.configuration).apiViewsListCollections(options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
     * @summary Partial Update Collection
     * @param {string} collectionName
     * @param {PatchCollectionIn} patchCollectionIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */ apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options) {
        return (0, exports.CollectionsApiFp)(this.configuration).apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.CollectionsApi = CollectionsApi;
/**
 * DocumentsApi - axios parameter creator
 * @export
 */ const DocumentsApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
         * @summary Delete Document
         * @param {string} documentName
         * @param {string | null} [collectionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsDeleteDocument: async (documentName, collectionName, options = {})=>{
            // verify required parameter 'documentName' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsDeleteDocument', 'documentName', documentName);
            const localVarPath = `/v1/documents/delete-document/{document_name}/`.replace(`{${"document_name"}}`, encodeURIComponent(String(documentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
         * @summary Get Document
         * @param {string} documentName
         * @param {string | null} [collectionName]
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsGetDocument: async (documentName, collectionName, expand, options = {})=>{
            // verify required parameter 'documentName' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsGetDocument', 'documentName', documentName);
            const localVarPath = `/v1/documents/{document_name}/`.replace(`{${"document_name"}}`, encodeURIComponent(String(documentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }
            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
         * @summary List Documents
         * @param {string | null} [collectionName]
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsListDocuments: async (collectionName, expand, options = {})=>{
            const localVarPath = `/v1/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }
            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
         * @summary Partial Update Document
         * @param {string} documentName
         * @param {DocumentInPatch} documentInPatch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsPartialUpdateDocument: async (documentName, documentInPatch, options = {})=>{
            // verify required parameter 'documentName' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsPartialUpdateDocument', 'documentName', documentName);
            // verify required parameter 'documentInPatch' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsPartialUpdateDocument', 'documentInPatch', documentInPatch);
            const localVarPath = `/v1/documents/{document_name}/`.replace(`{${"document_name"}}`, encodeURIComponent(String(documentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PATCH',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(documentInPatch, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
         * @summary Upsert Document
         * @param {DocumentIn} documentIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsUpsertDocument: async (documentIn, options = {})=>{
            // verify required parameter 'documentIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsUpsertDocument', 'documentIn', documentIn);
            const localVarPath = `/v1/documents/upsert-document/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(documentIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.DocumentsApiAxiosParamCreator = DocumentsApiAxiosParamCreator;
/**
 * DocumentsApi - functional programming interface
 * @export
 */ const DocumentsApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.DocumentsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
         * @summary Delete Document
         * @param {string} documentName
         * @param {string | null} [collectionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsDeleteDocument (documentName, collectionName, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsDeleteDocument(documentName, collectionName, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DocumentsApi.apiViewsDeleteDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
         * @summary Get Document
         * @param {string} documentName
         * @param {string | null} [collectionName]
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsGetDocument (documentName, collectionName, expand, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsGetDocument(documentName, collectionName, expand, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DocumentsApi.apiViewsGetDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
         * @summary List Documents
         * @param {string | null} [collectionName]
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsListDocuments (collectionName, expand, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsListDocuments(collectionName, expand, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DocumentsApi.apiViewsListDocuments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
         * @summary Partial Update Document
         * @param {string} documentName
         * @param {DocumentInPatch} documentInPatch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsPartialUpdateDocument (documentName, documentInPatch, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsPartialUpdateDocument(documentName, documentInPatch, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DocumentsApi.apiViewsPartialUpdateDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
         * @summary Upsert Document
         * @param {DocumentIn} documentIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsUpsertDocument (documentIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsUpsertDocument(documentIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DocumentsApi.apiViewsUpsertDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.DocumentsApiFp = DocumentsApiFp;
/**
 * DocumentsApi - factory interface
 * @export
 */ const DocumentsApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.DocumentsApiFp)(configuration);
    return {
        /**
         * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
         * @summary Delete Document
         * @param {string} documentName
         * @param {string | null} [collectionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsDeleteDocument (documentName, collectionName, options) {
            return localVarFp.apiViewsDeleteDocument(documentName, collectionName, options).then((request)=>request(axios, basePath));
        },
        /**
         * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
         * @summary Get Document
         * @param {string} documentName
         * @param {string | null} [collectionName]
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsGetDocument (documentName, collectionName, expand, options) {
            return localVarFp.apiViewsGetDocument(documentName, collectionName, expand, options).then((request)=>request(axios, basePath));
        },
        /**
         * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
         * @summary List Documents
         * @param {string | null} [collectionName]
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsListDocuments (collectionName, expand, options) {
            return localVarFp.apiViewsListDocuments(collectionName, expand, options).then((request)=>request(axios, basePath));
        },
        /**
         * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
         * @summary Partial Update Document
         * @param {string} documentName
         * @param {DocumentInPatch} documentInPatch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsPartialUpdateDocument (documentName, documentInPatch, options) {
            return localVarFp.apiViewsPartialUpdateDocument(documentName, documentInPatch, options).then((request)=>request(axios, basePath));
        },
        /**
         * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
         * @summary Upsert Document
         * @param {DocumentIn} documentIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsUpsertDocument (documentIn, options) {
            return localVarFp.apiViewsUpsertDocument(documentIn, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.DocumentsApiFactory = DocumentsApiFactory;
/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */ class DocumentsApi extends base_1.BaseAPI {
    /**
     * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
     * @summary Delete Document
     * @param {string} documentName
     * @param {string | null} [collectionName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */ apiViewsDeleteDocument(documentName, collectionName, options) {
        return (0, exports.DocumentsApiFp)(this.configuration).apiViewsDeleteDocument(documentName, collectionName, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
     * @summary Get Document
     * @param {string} documentName
     * @param {string | null} [collectionName]
     * @param {string | null} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */ apiViewsGetDocument(documentName, collectionName, expand, options) {
        return (0, exports.DocumentsApiFp)(this.configuration).apiViewsGetDocument(documentName, collectionName, expand, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
     * @summary List Documents
     * @param {string | null} [collectionName]
     * @param {string | null} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */ apiViewsListDocuments(collectionName, expand, options) {
        return (0, exports.DocumentsApiFp)(this.configuration).apiViewsListDocuments(collectionName, expand, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
     * @summary Partial Update Document
     * @param {string} documentName
     * @param {DocumentInPatch} documentInPatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */ apiViewsPartialUpdateDocument(documentName, documentInPatch, options) {
        return (0, exports.DocumentsApiFp)(this.configuration).apiViewsPartialUpdateDocument(documentName, documentInPatch, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
     * @summary Upsert Document
     * @param {DocumentIn} documentIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */ apiViewsUpsertDocument(documentIn, options) {
        return (0, exports.DocumentsApiFp)(this.configuration).apiViewsUpsertDocument(documentIn, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.DocumentsApi = DocumentsApi;
/**
 * EmbeddingsApi - axios parameter creator
 * @export
 */ const EmbeddingsApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
         * @summary Embeddings
         * @param {EmbeddingsIn} embeddingsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsEmbeddings: async (embeddingsIn, options = {})=>{
            // verify required parameter 'embeddingsIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsEmbeddings', 'embeddingsIn', embeddingsIn);
            const localVarPath = `/v1/embeddings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(embeddingsIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.EmbeddingsApiAxiosParamCreator = EmbeddingsApiAxiosParamCreator;
/**
 * EmbeddingsApi - functional programming interface
 * @export
 */ const EmbeddingsApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.EmbeddingsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
         * @summary Embeddings
         * @param {EmbeddingsIn} embeddingsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsEmbeddings (embeddingsIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsEmbeddings(embeddingsIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EmbeddingsApi.apiViewsEmbeddings']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.EmbeddingsApiFp = EmbeddingsApiFp;
/**
 * EmbeddingsApi - factory interface
 * @export
 */ const EmbeddingsApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.EmbeddingsApiFp)(configuration);
    return {
        /**
         * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
         * @summary Embeddings
         * @param {EmbeddingsIn} embeddingsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsEmbeddings (embeddingsIn, options) {
            return localVarFp.apiViewsEmbeddings(embeddingsIn, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.EmbeddingsApiFactory = EmbeddingsApiFactory;
/**
 * EmbeddingsApi - object-oriented interface
 * @export
 * @class EmbeddingsApi
 * @extends {BaseAPI}
 */ class EmbeddingsApi extends base_1.BaseAPI {
    /**
     * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
     * @summary Embeddings
     * @param {EmbeddingsIn} embeddingsIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddingsApi
     */ apiViewsEmbeddings(embeddingsIn, options) {
        return (0, exports.EmbeddingsApiFp)(this.configuration).apiViewsEmbeddings(embeddingsIn, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.EmbeddingsApi = EmbeddingsApi;
/**
 * FilterApi - axios parameter creator
 * @export
 */ const FilterApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
         * @summary Filter
         * @param {QueryFilter} queryFilter
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsFilter: async (queryFilter, expand, options = {})=>{
            // verify required parameter 'queryFilter' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsFilter', 'queryFilter', queryFilter);
            const localVarPath = `/v1/filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(queryFilter, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.FilterApiAxiosParamCreator = FilterApiAxiosParamCreator;
/**
 * FilterApi - functional programming interface
 * @export
 */ const FilterApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.FilterApiAxiosParamCreator)(configuration);
    return {
        /**
         * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
         * @summary Filter
         * @param {QueryFilter} queryFilter
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsFilter (queryFilter, expand, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsFilter(queryFilter, expand, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FilterApi.apiViewsFilter']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.FilterApiFp = FilterApiFp;
/**
 * FilterApi - factory interface
 * @export
 */ const FilterApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.FilterApiFp)(configuration);
    return {
        /**
         * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
         * @summary Filter
         * @param {QueryFilter} queryFilter
         * @param {string | null} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsFilter (queryFilter, expand, options) {
            return localVarFp.apiViewsFilter(queryFilter, expand, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.FilterApiFactory = FilterApiFactory;
/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */ class FilterApi extends base_1.BaseAPI {
    /**
     * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
     * @summary Filter
     * @param {QueryFilter} queryFilter
     * @param {string | null} [expand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */ apiViewsFilter(queryFilter, expand, options) {
        return (0, exports.FilterApiFp)(this.configuration).apiViewsFilter(queryFilter, expand, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.FilterApi = FilterApi;
/**
 * HealthApi - axios parameter creator
 * @export
 */ const HealthApiAxiosParamCreator = function(configuration) {
    return {
        /**
         *
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsHealth: async (options = {})=>{
            const localVarPath = `/v1/health/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.HealthApiAxiosParamCreator = HealthApiAxiosParamCreator;
/**
 * HealthApi - functional programming interface
 * @export
 */ const HealthApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.HealthApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsHealth (options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsHealth(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HealthApi.apiViewsHealth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.HealthApiFp = HealthApiFp;
/**
 * HealthApi - factory interface
 * @export
 */ const HealthApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.HealthApiFp)(configuration);
    return {
        /**
         *
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsHealth (options) {
            return localVarFp.apiViewsHealth(options).then((request)=>request(axios, basePath));
        }
    };
};
exports.HealthApiFactory = HealthApiFactory;
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */ class HealthApi extends base_1.BaseAPI {
    /**
     *
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */ apiViewsHealth(options) {
        return (0, exports.HealthApiFp)(this.configuration).apiViewsHealth(options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.HealthApi = HealthApi;
/**
 * HelpersApi - axios parameter creator
 * @export
 */ const HelpersApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
         * @summary File To Base64
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsFileToBase64: async (file, options = {})=>{
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsFileToBase64', 'file', file);
            const localVarPath = `/v1/helpers/file-to-base64/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
         * @summary File To Imgbase64
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsFileToImgbase64: async (file, options = {})=>{
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsFileToImgbase64', 'file', file);
            const localVarPath = `/v1/helpers/file-to-imgbase64/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.HelpersApiAxiosParamCreator = HelpersApiAxiosParamCreator;
/**
 * HelpersApi - functional programming interface
 * @export
 */ const HelpersApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.HelpersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
         * @summary File To Base64
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsFileToBase64 (file, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsFileToBase64(file, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HelpersApi.apiViewsFileToBase64']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
         * @summary File To Imgbase64
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsFileToImgbase64 (file, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsFileToImgbase64(file, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HelpersApi.apiViewsFileToImgbase64']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.HelpersApiFp = HelpersApiFp;
/**
 * HelpersApi - factory interface
 * @export
 */ const HelpersApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.HelpersApiFp)(configuration);
    return {
        /**
         * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
         * @summary File To Base64
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsFileToBase64 (file, options) {
            return localVarFp.apiViewsFileToBase64(file, options).then((request)=>request(axios, basePath));
        },
        /**
         * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
         * @summary File To Imgbase64
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsFileToImgbase64 (file, options) {
            return localVarFp.apiViewsFileToImgbase64(file, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.HelpersApiFactory = HelpersApiFactory;
/**
 * HelpersApi - object-oriented interface
 * @export
 * @class HelpersApi
 * @extends {BaseAPI}
 */ class HelpersApi extends base_1.BaseAPI {
    /**
     * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
     * @summary File To Base64
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpersApi
     */ apiViewsFileToBase64(file, options) {
        return (0, exports.HelpersApiFp)(this.configuration).apiViewsFileToBase64(file, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
     * @summary File To Imgbase64
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpersApi
     */ apiViewsFileToImgbase64(file, options) {
        return (0, exports.HelpersApiFp)(this.configuration).apiViewsFileToImgbase64(file, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.HelpersApi = HelpersApi;
/**
 * SearchApi - axios parameter creator
 * @export
 */ const SearchApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search
         * @param {QueryIn} queryIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsSearch: async (queryIn, options = {})=>{
            // verify required parameter 'queryIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsSearch', 'queryIn', queryIn);
            const localVarPath = `/v1/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(queryIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Search for pages similar to a given image.  This endpoint allows the user to search for pages similar to a given image. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (SearchImageIn): The input data for the search, which includes the image in base64 format and collection ID.  Returns:     SearchImageOut: The search results, a list of similar pages.  Raises:     HttpError: If the collection does not exist or the img_base64 is invalid.  Example:     POST /search-image/     {         \"img_base64\": \"base64_string\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search Image
         * @param {SearchImageIn} searchImageIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsSearchImage: async (searchImageIn, options = {})=>{
            // verify required parameter 'searchImageIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsSearchImage', 'searchImageIn', searchImageIn);
            const localVarPath = `/v1/search-image/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchImageIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.SearchApiAxiosParamCreator = SearchApiAxiosParamCreator;
/**
 * SearchApi - functional programming interface
 * @export
 */ const SearchApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.SearchApiAxiosParamCreator)(configuration);
    return {
        /**
         * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search
         * @param {QueryIn} queryIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsSearch (queryIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsSearch(queryIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SearchApi.apiViewsSearch']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for pages similar to a given image.  This endpoint allows the user to search for pages similar to a given image. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (SearchImageIn): The input data for the search, which includes the image in base64 format and collection ID.  Returns:     SearchImageOut: The search results, a list of similar pages.  Raises:     HttpError: If the collection does not exist or the img_base64 is invalid.  Example:     POST /search-image/     {         \"img_base64\": \"base64_string\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search Image
         * @param {SearchImageIn} searchImageIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsSearchImage (searchImageIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsSearchImage(searchImageIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SearchApi.apiViewsSearchImage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.SearchApiFp = SearchApiFp;
/**
 * SearchApi - factory interface
 * @export
 */ const SearchApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.SearchApiFp)(configuration);
    return {
        /**
         * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search
         * @param {QueryIn} queryIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsSearch (queryIn, options) {
            return localVarFp.apiViewsSearch(queryIn, options).then((request)=>request(axios, basePath));
        },
        /**
         * Search for pages similar to a given image.  This endpoint allows the user to search for pages similar to a given image. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (SearchImageIn): The input data for the search, which includes the image in base64 format and collection ID.  Returns:     SearchImageOut: The search results, a list of similar pages.  Raises:     HttpError: If the collection does not exist or the img_base64 is invalid.  Example:     POST /search-image/     {         \"img_base64\": \"base64_string\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search Image
         * @param {SearchImageIn} searchImageIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsSearchImage (searchImageIn, options) {
            return localVarFp.apiViewsSearchImage(searchImageIn, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.SearchApiFactory = SearchApiFactory;
/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */ class SearchApi extends base_1.BaseAPI {
    /**
     * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
     * @summary Search
     * @param {QueryIn} queryIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */ apiViewsSearch(queryIn, options) {
        return (0, exports.SearchApiFp)(this.configuration).apiViewsSearch(queryIn, options).then((request)=>request(this.axios, this.basePath));
    }
    /**
     * Search for pages similar to a given image.  This endpoint allows the user to search for pages similar to a given image. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (SearchImageIn): The input data for the search, which includes the image in base64 format and collection ID.  Returns:     SearchImageOut: The search results, a list of similar pages.  Raises:     HttpError: If the collection does not exist or the img_base64 is invalid.  Example:     POST /search-image/     {         \"img_base64\": \"base64_string\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
     * @summary Search Image
     * @param {SearchImageIn} searchImageIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */ apiViewsSearchImage(searchImageIn, options) {
        return (0, exports.SearchApiFp)(this.configuration).apiViewsSearchImage(searchImageIn, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.SearchApi = SearchApi;
/**
 * WebhookApi - axios parameter creator
 * @export
 */ const WebhookApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
         * @summary Add Webhook
         * @param {WebhookIn} webhookIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsAddWebhook: async (webhookIn, options = {})=>{
            // verify required parameter 'webhookIn' is not null or undefined
            (0, common_1.assertParamExists)('apiViewsAddWebhook', 'webhookIn', webhookIn);
            const localVarPath = `/v1/webhook/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Bearer required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookIn, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.WebhookApiAxiosParamCreator = WebhookApiAxiosParamCreator;
/**
 * WebhookApi - functional programming interface
 * @export
 */ const WebhookApiFp = function(configuration) {
    const localVarAxiosParamCreator = (0, exports.WebhookApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
         * @summary Add Webhook
         * @param {WebhookIn} webhookIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async apiViewsAddWebhook (webhookIn, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsAddWebhook(webhookIn, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.apiViewsAddWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath)=>(0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
    };
};
exports.WebhookApiFp = WebhookApiFp;
/**
 * WebhookApi - factory interface
 * @export
 */ const WebhookApiFactory = function(configuration, basePath, axios) {
    const localVarFp = (0, exports.WebhookApiFp)(configuration);
    return {
        /**
         * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
         * @summary Add Webhook
         * @param {WebhookIn} webhookIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ apiViewsAddWebhook (webhookIn, options) {
            return localVarFp.apiViewsAddWebhook(webhookIn, options).then((request)=>request(axios, basePath));
        }
    };
};
exports.WebhookApiFactory = WebhookApiFactory;
/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */ class WebhookApi extends base_1.BaseAPI {
    /**
     * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
     * @summary Add Webhook
     * @param {WebhookIn} webhookIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */ apiViewsAddWebhook(webhookIn, options) {
        return (0, exports.WebhookApiFp)(this.configuration).apiViewsAddWebhook(webhookIn, options).then((request)=>request(this.axios, this.basePath));
    }
}
exports.WebhookApi = WebhookApi;
}),
"[project]/node_modules/colivara-ts/dist/configuration.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * ColiVara
 * Colivara is a suite of services that allows you to store, search, and retrieve documents based on their visual embeddings.      It is a web-first implementation of the ColPali paper using ColQwen2 as backend model. It works exacly like RAG from the end-user standpoint - but using vision models instead of chunking and text-processing for documents.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@colivara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}){
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
exports.Configuration = Configuration;
}),
"[project]/node_modules/colivara-ts/dist/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ColiVara = void 0;
// client.ts
process.emitWarning = ()=>{};
const configuration_1 = __turbopack_context__.r("[project]/node_modules/colivara-ts/dist/configuration.js [app-route] (ecmascript)");
const api_1 = __turbopack_context__.r("[project]/node_modules/colivara-ts/dist/api.js [app-route] (ecmascript)");
const axios_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-route] (ecmascript)"));
const svix_1 = __turbopack_context__.r("[project]/node_modules/svix/dist/index.js [app-route] (ecmascript)");
const fs = __importStar(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
const path = __importStar(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const mime = __importStar(__turbopack_context__.r("[project]/node_modules/mime-types/index.js [app-route] (ecmascript)"));
class ColiVaraError extends Error {
    constructor(message){
        super(message);
        this.name = "ColiVaraError";
    }
}
class ColiVara {
    constructor(apiKey, baseUrl = "https://api.colivara.com"){
        const configuration = new configuration_1.Configuration({
            basePath: baseUrl,
            accessToken: apiKey
        });
        this.collectionsApi = new api_1.CollectionsApi(configuration);
        this.documentsApi = new api_1.DocumentsApi(configuration);
        this.embeddingsApi = new api_1.EmbeddingsApi(configuration);
        this.searchApi = new api_1.SearchApi(configuration);
        this.filterApi = new api_1.FilterApi(configuration);
        this.webhookApi = new api_1.WebhookApi(configuration);
        this.helperApi = new api_1.HelpersApi(configuration);
        this.healthApi = new api_1.HealthApi(configuration);
    }
    handleError(error) {
        var _a, _b;
        if (axios_1.default.isAxiosError(error)) {
            const axiosError = error;
            const statusCode = (_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.status;
            const errorMessage = ((_b = axiosError.response) === null || _b === void 0 ? void 0 : _b.data) && typeof axiosError.response.data === "object" && "detail" in axiosError.response.data ? axiosError.response.data.detail : axiosError.message;
            throw new ColiVaraError(`API Error (${statusCode}): ${errorMessage}`);
        }
        throw error;
    }
    /**
     * Create a new collection.
     *
     * @param params - The parameters for collection creation
     * @param params.name - Name of the collection
     * @param params.metadata - Optional metadata for the collection
     * @returns Response from the API
     * @throws {ColiVaraError} If the API request fails
     */ async createCollection({ name, metadata = {} }) {
        try {
            const body = {
                name,
                metadata
            };
            const response = await this.collectionsApi.apiViewsCreateCollection(body);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Gets a specific collection.
     *
     * @param params - The parameters for getting a collection
     * @param params.collection_name - The name of the collection to get
     * @returns The requested CollectionOut object
     * @throws {ColiVaraError} If the collection is not found or an unexpected error occurs
     */ async getCollection({ collection_name }) {
        try {
            const response = await this.collectionsApi.apiViewsGetCollection(collection_name);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Lists all collections.
     *
     * @returns A list of CollectionOut objects
     * @throws {ColiVaraError} If the response format is unexpected or an unexpected error occurs
     */ async listCollections() {
        try {
            const response = await this.collectionsApi.apiViewsListCollections();
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Deletes a specific collection.
     *
     * @param params - The parameters for deleting a collection
     * @param params.collection_name - The name of the collection to delete
     * @throws {ColiVaraError} If the collection is not found or an unexpected error occurs
     */ async deleteCollection({ collection_name }) {
        try {
            await this.collectionsApi.apiViewsDeleteCollection(collection_name);
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Partially updates a collection.
     *
     * @param params - The parameters for updating a collection
     * @param params.collection_name - The name of the collection to update
     * @param params.name - The new name for the collection (optional)
     * @param params.metadata - The new metadata for the collection (optional)
     * @returns The updated CollectionOut object
     * @throws {ColiVaraError} If the collection is not found or there's a problem with the update
     */ async partialUpdateCollection({ collection_name, name, metadata }) {
        try {
            const body = {
                name,
                metadata
            };
            const response = await this.collectionsApi.apiViewsPartialUpdateCollection(collection_name, body);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Retrieve a specific document from the user documents.
     *
     * @param params - The parameters for retrieving a document
     * @param params.document_name - The name of the document to retrieve
     * @param params.collection_name - The name of the collection containing the document. Defaults to "default_collection"
     * @param params.expand - A comma-separated list of fields to expand in the response.
     *                       Currently, only "pages" is supported, the document's pages will be included if provided
     * @returns The retrieved document with its details
     * @throws {ColiVaraError} If the document or collection is not found, or if the API request fails
     */ async getDocument({ document_name, collection_name = "default_collection", expand }) {
        try {
            const response = await this.documentsApi.apiViewsGetDocument(document_name, collection_name, expand);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Fetch a list of documents for a given collection.
     *
     * @param params - The parameters for listing documents
     * @param params.collection_name - The name of the collection to fetch documents from.
     *                                Defaults to "default_collection". Use "all" to fetch documents from all collections.
     * @param params.expand - A comma-separated string specifying additional fields to include in the response.
     *                       If "pages" is included, the pages of each document will be included.
     *
     * @returns A list of documents with their details
     * @throws {ColiVaraError} If the API request fails
     */ async listDocuments({ collection_name = "default_collection", expand } = {}) {
        try {
            const response = await this.documentsApi.apiViewsListDocuments(collection_name, expand);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Partially update a document.
     *
     * This method allows for partial updates to a document's details. Only the fields provided will be updated.
     *
     * @param params - The parameters for updating a document
     * @param params.document_name - The name of the document to be updated
     * @param params.name - The new name for the document, if changing
     * @param params.metadata - Updated metadata for the document
     * @param params.collection_name - The name of the collection to move the document to, if changing
     * @param params.document_url - The new URL of the document, if changing
     * @param params.document_base64 - The new base64-encoded string of the document content, if changing
     * @param params.use_proxy - Whether to use a proxy for the document URL
     *
     * @returns The updated document with its details
     * @throws {ColiVaraError} If the API request fails or the document is not found
     */ async partialUpdateDocument({ document_name, name, metadata, collection_name, document_url, document_base64, use_proxy = false }) {
        try {
            const body = {
                name,
                metadata,
                collection_name,
                url: document_url,
                base64: document_base64,
                use_proxy
            };
            const response = await this.documentsApi.apiViewsPartialUpdateDocument(document_name, body);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Create or update a document in a collection.
     *
     * This method allows you to upsert (insert or update) a document in the specified collection.
     * You can provide either a URL or a base64-encoded string of the document content.
     *
     * @param params - The parameters for document upsertion
     * @param params.name - The name of the document
     * @param params.metadata - Additional metadata for the document
     * @param params.collectionName - The name of the collection to add the document to. Defaults to "default_collection"
     * @param params.document_url - The URL of the document, if available
     * @param params.document_base64 - The base64-encoded string of the document content, if available
     * @param params.document_path - The path to the document file to be uploaded
     * @param params.wait - If true, wait for the document to be processed before returning
     * @param params.use_proxy - If true, use proxy for URL downloads
     *
     * @returns The created or updated document with its details
     *
     * @throws {ColiVaraError} If no valid document source is provided or if there's an error with file handling
     * @throws {ColiVaraError} If the API request fails
     */ async upsertDocument({ name, metadata = {}, collection_name = "default_collection", document_url, document_base64, document_path, wait = false, use_proxy = false }) {
        try {
            let base64Content = document_base64;
            if (document_path) {
                try {
                    const fileContent = await fs.promises.readFile(document_path);
                    base64Content = fileContent.toString("base64");
                } catch (error) {
                    // Remove the generic error catch and handle specific cases
                    if (error instanceof Error) {
                        const nodeError = error;
                        if (nodeError.code === "ENOENT") {
                            throw new ColiVaraError(`The specified file does not exist: ${document_path}`);
                        } else if (nodeError.code === "EACCES") {
                            throw new ColiVaraError(`No read permission for file: ${document_path}`);
                        }
                        throw new ColiVaraError(`Error reading file: ${nodeError.message}`);
                    }
                    throw error; // Re-throw any other type of error
                }
            }
            if (!document_url && !base64Content) {
                throw new ColiVaraError("Either document_url, document_base64, or document_path must be provided.");
            }
            const document = {
                name,
                metadata,
                collection_name,
                url: document_url,
                base64: base64Content,
                wait,
                use_proxy
            };
            const response = await this.documentsApi.apiViewsUpsertDocument(document);
            return response.data;
        } catch (error) {
            if (error instanceof ColiVaraError) {
                throw error;
            }
            this.handleError(error);
        }
    }
    /**
     * Delete a document by its name.
     *
     * @param params - The parameters for deleting a document
     * @param params.document_name - The name of the document to be deleted
     * @param params.collection_name - The name of the collection containing the document.
     *                                Defaults to "default_collection". Use "all" to access all collections belonging to the user.
     *
     * @throws {ColiVaraError} If the API request fails or if the document does not exist
     */ async deleteDocument({ document_name, collection_name = "default_collection" }) {
        try {
            await this.documentsApi.apiViewsDeleteDocument(document_name, collection_name);
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Filter for documents and collections that meet the criteria of the filter.
     *
     * @param params - The parameters for filtering
     * @param params.query_filter - A dictionary specifying the filter criteria.
     *                             The filter can be used to narrow down the search based on specific criteria.
     *                             The dictionary should contain the following keys:
     *                             - "on": "document" or "collection"
     *                             - "key": string or string[]
     *                             - "value": string | number | boolean | null
     *                             - "lookup": "key_lookup" | "contains" | "contained_by" | "has_key" | "has_keys" | "has_any_keys"
     * @param params.expand - A comma-separated list of fields to expand in the response.
     *                       Currently, only "pages" is supported, the document's pages will be included if provided.
     *
     * @returns The API Response containing documents or collections
     * @throws {ColiVaraError} If the query_filter is invalid or if the API request fails
     */ async filter({ query_filter, expand }) {
        var _a;
        try {
            // Simplify the filter model to match the API expectations
            const filter_model = {
                key: query_filter.key,
                value: (_a = query_filter.value) !== null && _a !== void 0 ? _a : "",
                lookup: query_filter.lookup,
                on: query_filter.on
            };
            const response = await this.filterApi.apiViewsFilter(filter_model, expand);
            return response.data;
        } catch (error) {
            if (error instanceof Error) {
                if (error.message.includes("key")) {
                    throw new ColiVaraError(`Missing required key: ${error.message}`);
                }
            }
            this.handleError(error);
        }
    }
    /**
     * Converts a file to a base64 encoded string.
     *
     * @param file_path - The path to the file to be converted
     * @returns A base64 encoded string of the file
     * @throws {ColiVaraError} If there's an error during the file conversion process
     */ async fileToBase64(file_path) {
        try {
            const fileContent = await fs.promises.readFile(file_path);
            return fileContent.toString("base64");
        } catch (error) {
            if (error instanceof Error) {
                const nodeError = error;
                if (nodeError.code === "ENOENT") {
                    throw new ColiVaraError(`The specified file does not exist: ${file_path}`);
                } else if (nodeError.code === "EACCES") {
                    throw new ColiVaraError(`No read permission for file: ${file_path}`);
                }
                throw new ColiVaraError(`Error reading file: ${error.message}`);
            }
            throw new ColiVaraError("Unknown error occurred while reading file");
        }
    }
    /**
     * Convert a file to base64-encoded strings for its image representations.
     *
     * @param file_path - Path to the file to be converted
     * @returns A list of FileOut objects containing base64-encoded strings of images
     * @throws {ColiVaraError} If there's an error during the file conversion process or API request fails
     */ async fileToImgbase64(file_path) {
        try {
            // Read the file content
            const fileContent = await fs.promises.readFile(file_path);
            // Create a File object from the buffer
            const fileName = path.basename(file_path);
            const file = new File([
                fileContent
            ], fileName, {
                type: mime.lookup(file_path) || "application/octet-stream"
            });
            // Make the API request
            const response = await this.helperApi.apiViewsFileToImgbase64(file);
            return response.data;
        } catch (error) {
            if (error instanceof Error) {
                const nodeError = error;
                if (nodeError.code === "ENOENT") {
                    throw new ColiVaraError(`The specified file does not exist: ${file_path}`);
                } else if (nodeError.code === "EACCES") {
                    throw new ColiVaraError(`No read permission for file: ${file_path}`);
                }
                throw new ColiVaraError(`Error reading file: ${error.message}`);
            }
            this.handleError(error);
        }
    }
    /**
     * Search for pages similar to a given query.
     *
     * This method allows you to search for pages similar to a given query across all documents
     * in the specified collection.
     *
     * @param params - The parameters for searching
     * @param params.query - The search query string
     * @param params.collection_name - The name of the collection to search in. Defaults to "all"
     * @param params.top_k - The number of top results to return. Defaults to 3
     * @param params.query_filter - An optional filter to apply to the search results.
     *                             The filter can be used to narrow down the search based on specific criteria.
     *                             It should contain the following possible keys:
     *                             - "on": "document" or "collection"
     *                             - "key": string or string[]
     *                             - "value": string | number | boolean | null
     *                             - "lookup": "key_lookup" | "contains" | "contained_by" | "has_key" | "has_keys" | "has_any_keys"
     *
     * @returns The search results, including the query and a list of similar pages
     * @throws {ColiVaraError} If the query is invalid, the collection does not exist, or the query_filter is invalid
     *
     * @example
     * // Simple search
     * const results = await client.search({ query: "what is 1+1?" });
     *
     * // Search with a specific collection
     * const results = await client.search({
     *     query: "what is 1+1?",
     *     collection_name: "my_collection"
     * });
     *
     * // Search with a filter on document metadata
     * const results = await client.search({
     *     query: "what is 1+1?",
     *     query_filter: {
     *         on: "document",
     *         key: "category",
     *         value: "AI",
     *         lookup: "contains"
     *     }
     * });
     *
     * // Search with a filter on collection metadata
     * const results = await client.search({
     *     query: "what is 1+1?",
     *     query_filter: {
     *         on: "collection",
     *         key: ["tag1", "tag2"],
     *         lookup: "has_any_keys"
     *     }
     * });
     */ async search({ query, collection_name = "all", top_k = 3, query_filter }) {
        var _a;
        try {
            let processedQueryFilter;
            if (query_filter) {
                processedQueryFilter = {
                    key: query_filter.key,
                    value: (_a = query_filter.value) !== null && _a !== void 0 ? _a : "",
                    lookup: query_filter.lookup,
                    on: query_filter.on
                };
            }
            const body = {
                query,
                collection_name,
                top_k,
                query_filter: processedQueryFilter
            };
            const response = await this.searchApi.apiViewsSearch(body);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Search for pages similar to a given image.
     *
     * This method allows you to search for pages similar to a given image across all documents
     * in the specified collection. You can provide either a path to an image file or a base64-encoded
     * string of the image content.
     *
     * @param params - The parameters for image searching
     * @param params.collection_name - The name of the collection to search in
     * @param params.image_path - Path to the image file to search with (optional if image_base64 is provided)
     * @param params.image_base64 - Base64-encoded string of the image content (optional if image_path is provided)
     * @param params.top_k - The number of top results to return. Defaults to 3
     * @param params.query_filter - An optional filter to apply to the search results.
     *                             The filter can be used to narrow down the search based on specific criteria.
     *                             It should contain the following possible keys:
     *                             - "on": "document" or "collection"
     *                             - "key": string or string[]
     *                             - "value": string | number | boolean | null
     *                             - "lookup": "key_lookup" | "contains" | "contained_by" | "has_key" | "has_keys" | "has_any_keys"
     *
     * @returns The search results, including a list of similar pages
     * @throws {ColiVaraError} If neither image_path nor image_base64 is provided, or if there's an error with file handling
     * @throws {ColiVaraError} If the API request fails
     *
     * @example
     * // Search with image file
     * const results = await client.searchImage({
     *     collection_name: "my_collection",
     *     image_path: "path/to/image.jpg"
     * });
     *
     * // Search with base64-encoded image
     * const results = await client.searchImage({
     *     collection_name: "my_collection",
     *     image_base64: "base64_encoded_string"
     * });
     *
     * // Search with filter
     * const results = await client.searchImage({
     *     collection_name: "my_collection",
     *     image_path: "path/to/image.jpg",
     *     query_filter: {
     *         on: "document",
     *         key: "category",
     *         value: "landscape",
     *         lookup: "contains"
     *     }
     * });
     */ async searchImage({ collection_name, image_path, image_base64, top_k = 3, query_filter }) {
        var _a;
        try {
            let img_base64 = image_base64;
            if (image_path) {
                try {
                    const fileContent = await fs.promises.readFile(image_path);
                    img_base64 = fileContent.toString("base64");
                } catch (error) {
                    if (error instanceof Error) {
                        const nodeError = error;
                        if (nodeError.code === "ENOENT") {
                            throw new ColiVaraError(`The specified file does not exist: ${image_path}`);
                        } else if (nodeError.code === "EACCES") {
                            throw new ColiVaraError(`No read permission for file: ${image_path}`);
                        }
                        throw new ColiVaraError(`Error reading file: ${nodeError.message}`);
                    }
                    throw error;
                }
            }
            if (!img_base64) {
                throw new ColiVaraError("Either image_path or image_base64 must be provided.");
            }
            let processedQueryFilter;
            if (query_filter) {
                processedQueryFilter = {
                    key: query_filter.key,
                    value: (_a = query_filter.value) !== null && _a !== void 0 ? _a : "",
                    lookup: query_filter.lookup,
                    on: query_filter.on
                };
            }
            const searchImageBody = {
                img_base64,
                collection_name,
                top_k,
                query_filter: processedQueryFilter
            };
            const response = await this.searchApi.apiViewsSearchImage(searchImageBody);
            return response.data;
        } catch (error) {
            if (error instanceof ColiVaraError) {
                throw error;
            }
            this.handleError(error);
        }
    }
    /**
     * Creates embeddings for the given input data.
     *
     * @param params - The parameters for creating embeddings
     * @param params.input_data - A string or array of strings to create embeddings for
     * @param params.task - The task type for embedding creation. Can be "query" or "image". Defaults to "query"
     *
     * @returns An EmbeddingsOut object containing the embeddings, model information, and usage data
     * @throws {ColiVaraError} If an invalid task is provided or if there's an unexpected error from the API
     *
     * @example
     * // Create embedding for a single query
     * const result = await client.createEmbedding({
     *     input_data: "what is 1+1?",
     *     task: "query"
     * });
     *
     * // Create embeddings for multiple images
     * const result = await client.createEmbedding({
     *     input_data: ["image1.jpg", "image2.jpg"],
     *     task: "image"
     * });
     */ async createEmbedding({ input_data, task = api_1.TaskEnum.Query }) {
        try {
            // Convert input_data to array if it's a string
            const inputArray = Array.isArray(input_data) ? input_data : [
                input_data
            ];
            // Validate and convert task to TaskEnum
            let processedTask;
            if (typeof task === "string") {
                const lowercaseTask = task.toLowerCase();
                if (lowercaseTask !== "query" && lowercaseTask !== "image") {
                    throw new ColiVaraError(`Invalid task: ${task}. Must be 'query' or 'image'.`);
                }
                processedTask = lowercaseTask === "query" ? api_1.TaskEnum.Query : api_1.TaskEnum.Image;
            } else {
                processedTask = task;
            }
            // If task is image, convert file paths to base64
            let processedInputData = [
                ...inputArray
            ];
            if (processedTask === api_1.TaskEnum.Image) {
                processedInputData = await Promise.all(inputArray.map(async (data)=>{
                    try {
                        // Check if the input is a file path
                        const stats = await fs.promises.stat(data);
                        if (stats.isFile()) {
                            return await this.fileToBase64(data);
                        }
                        return data;
                    } catch (error) {
                        // If stat fails, assume the input is already base64 or raw data
                        return data;
                    }
                }));
            }
            const body = {
                input_data: processedInputData,
                task: processedTask
            };
            const response = await this.embeddingsApi.apiViewsEmbeddings(body);
            return response.data;
        } catch (error) {
            if (error instanceof ColiVaraError) {
                throw error;
            }
            this.handleError(error);
        }
    }
    /**
     * Add a webhook to the service.
     *
     * This endpoint allows the user to add a webhook to the service. The webhook will be called
     * when a document is upserted with the upsertion status.
     *
     * Events are document upsert successful, document upsert failed.
     *
     * @param params - The parameters for adding a webhook
     * @param params.url - The URL of the webhook to be added
     *
     * @returns The added webhook endpoint id, associated app id, and webhook secret
     * @throws {ColiVaraError} If the API request fails
     *
     * @example
     * const webhook = await client.addWebhook({
     *     url: "https://your-webhook-endpoint.com/webhook"
     * });
     */ async addWebhook({ url }) {
        try {
            const body = {
                url
            };
            const response = await this.webhookApi.apiViewsAddWebhook(body);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    /**
     * Validates a webhook request.
     *
     * This endpoint allows the user to validate a webhook request given the webhook secret,
     * payload, and headers.
     *
     * @param params - The parameters for validating a webhook
     * @param params.webhook_secret - The webhook secret to validate the request
     * @param params.payload - The payload of the webhook request
     * @param params.headers - The headers of the webhook request
     *
     * @returns True if the request is valid, False otherwise
     *
     * @example
     * const isValid = client.validateWebhook({
     *     webhook_secret: "whsec_xxx",
     *     payload: JSON.stringify(requestBody),
     *     headers: {
     *         'svix-id': 'msg_xxx',
     *         'svix-timestamp': '1234567890',
     *         'svix-signature': 'v1,xxx'
     *     }
     * });
     */ validateWebhook({ webhook_secret, payload, headers }) {
        try {
            const wh = new svix_1.Webhook(webhook_secret);
            wh.verify(payload, headers);
            return true;
        } catch (error) {
            return false;
        }
    }
    /**
     * Check the health of the API.
     *
     * @returns Health status of the API
     * @throws {ColiVaraError} If the API request fails
     *
     * @example
     * try {
     *     await client.checkHealth();
     *     console.log('API is healthy');
     * } catch (error) {
     *     console.error('API health check failed:', error);
     * }
     */ async checkHealth() {
        try {
            const response = await this.healthApi.apiViewsHealth();
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
}
exports.ColiVara = ColiVara;
}),
"[project]/node_modules/colivara-ts/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * ColiVara
 * Colivara is a suite of services that allows you to store, search, and retrieve documents based on their visual embeddings.      It is a web-first implementation of the ColPali paper using ColQwen2 as backend model. It works exacly like RAG from the end-user standpoint - but using vision models instead of chunking and text-processing for documents.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: abdulhaleem@tjmlabs.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/colivara-ts/dist/api.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/colivara-ts/dist/configuration.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/colivara-ts/dist/client.js [app-route] (ecmascript)"), exports);
}),
];

//# sourceMappingURL=node_modules_colivara-ts_dist_0c177714._.js.map