{"version":3,"sources":["../../../../lib/services/jwt-service.ts","../../../../lib/services/auth-service.ts","../../../../lib/auth-context.tsx"],"sourcesContent":["// This service is for handling custom JWT tokens for database authentication\r\n\r\nexport interface TokenPayload {\r\n  userId: string;\r\n  email: string;\r\n  role: string;\r\n  iat: number;\r\n  exp: number;\r\n}\r\n\r\nclass JWTService {\r\n  private readonly secret: string;\r\n\r\n  constructor() {\r\n    this.secret = process.env.JWT_SECRET || '6dFk5d0vbyLnZC0Amy83LtI47DsNr/KB4M+FgbUc6njd4cjk7XB2/8nTuhQDWW8OOgQ6fI74huxJE3a/RP2giw==';\r\n  }\r\n\r\n  /**\r\n   * Convert a string to a Uint8Array (which can be used with Web Crypto API)\r\n   */\r\n private stringToUint8Array(str: string): Uint8Array {\r\n    return new TextEncoder().encode(str);\r\n }\r\n\r\n /**\r\n  * Convert a Uint8Array to a base64url encoded string\r\n  */\r\n private uint8ArrayToBase64Url(uint8Array: Uint8Array): string {\r\n   let binary = '';\r\n   for (let i = 0; i < uint8Array.byteLength; i++) {\r\n     binary += String.fromCharCode(uint8Array[i]);\r\n   }\r\n   return btoa(binary)\r\n     .replace(/\\+/g, '-')\r\n     .replace(/\\//g, '_')\r\n     .replace(/=/g, '');\r\n }\r\n\r\n  /**\r\n   * Import the secret as a CryptoKey for use with Web Crypto API\r\n   */\r\n  private async importSecret(): Promise<CryptoKey> {\r\n    const encoder = new TextEncoder();\r\n    const keyBuffer = encoder.encode(this.secret);\r\n    \r\n    return await crypto.subtle.importKey(\r\n      'raw',\r\n      keyBuffer,\r\n      { name: 'HMAC', hash: 'SHA-256' },\r\n      false,\r\n      ['sign', 'verify']\r\n    );\r\n  }\r\n\r\n /**\r\n   * Generate a JWT token using Web Crypto API\r\n   */\r\n  async generateToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): Promise<string> {\r\n    try {\r\n      // Create the header\r\n      const header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n      };\r\n\r\n      // Add timestamp and expiration (1 hour from now)\r\n      const timestamp = Math.floor(Date.now() / 1000);\r\n      const expiration = timestamp + 3600; // 1 hour in seconds\r\n\r\n      // Create the payload with the provided data and timestamps\r\n      const fullPayload = {\r\n        ...payload,\r\n        iat: timestamp,\r\n        exp: expiration\r\n      };\r\n\r\n      // Encode header and payload to base64url\r\n      const encodedHeader = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(header))\r\n      );\r\n      const encodedPayload = this.uint8ArrayToBase64Url(\r\n        this.stringToUint8Array(JSON.stringify(fullPayload))\r\n      );\r\n\r\n      // Create the signing input\r\n      const signingInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Create signing input buffer in the proper format for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const signingInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Sign the token - use type assertion to handle TypeScript compatibility issues\r\n      const signatureBuffer = await crypto.subtle.sign(\r\n        'HMAC',\r\n        key,\r\n        signingInputBuffer as BufferSource\r\n      );\r\n\r\n      // Encode the signature - signatureBuffer is an ArrayBuffer, convert to base64url\r\n      const signatureUint8Array = new Uint8Array(signatureBuffer);\r\n      const encodedSignature = this.uint8ArrayToBase64Url(signatureUint8Array);\r\n\r\n      // Return the complete JWT token\r\n      return `${signingInput}.${encodedSignature}`;\r\n    } catch (error) {\r\n      console.error('JWT token generation failed:', error);\r\n      throw new Error('Failed to generate JWT token');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a JWT token using Web Crypto API\r\n   */\r\n  async verifyToken(token: string): Promise<TokenPayload | null> {\r\n    try {\r\n      // Check if token is valid before attempting to verify\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        console.error('Invalid token provided for verification');\r\n        return null;\r\n      }\r\n      \r\n      // Check if token has proper format (3 parts separated by dots)\r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const [encodedHeader, encodedPayload, encodedSignature] = tokenParts;\r\n\r\n      // Decode header\r\n      const decodedHeader = this.base64UrlDecode(encodedHeader);\r\n      if (!decodedHeader) {\r\n        console.error('Failed to decode token header');\r\n        return null;\r\n      }\r\n\r\n      // Decode payload\r\n      const decodedPayloadStr = this.base64UrlDecode(encodedPayload);\r\n      if (!decodedPayloadStr) {\r\n        console.error('Failed to decode token payload');\r\n        return null;\r\n      }\r\n\r\n      // Parse payload\r\n      const payloadObj = JSON.parse(decodedPayloadStr) as TokenPayload;\r\n      \r\n      // Check if token is expired\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      if (payloadObj.exp && payloadObj.exp < currentTime) {\r\n        console.error('Token has expired');\r\n        return null;\r\n      }\r\n\r\n      // Import the secret as a crypto key\r\n      const key = await this.importSecret();\r\n\r\n      // Verify the signature\r\n      const isValid = await this.verifySignature(\r\n        `${encodedHeader}.${encodedPayload}`,\r\n        encodedSignature,\r\n        key\r\n      );\r\n\r\n      if (!isValid) {\r\n        console.error('Token signature verification failed');\r\n        return null;\r\n      }\r\n\r\n      return payloadObj;\r\n    } catch (error: any) {\r\n      console.error('Token verification failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify the JWT signature using Web Crypto API\r\n   */\r\n  private async verifySignature(\r\n    signingInput: string,\r\n    signature: string,\r\n    key: CryptoKey\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Decode the signature from base64url to Uint8Array\r\n      const signatureBytes = this.base64UrlDecodeToUint8Array(signature);\r\n      if (!signatureBytes) {\r\n        return false;\r\n      }\r\n\r\n      // Create proper buffers for Web Crypto API\r\n      const encoder = new TextEncoder();\r\n      const verificationInputBuffer = encoder.encode(signingInput);\r\n      \r\n      // Use ArrayBufferView for signatureBytes and input buffer\r\n      // Cast to appropriate types to handle TypeScript issues\r\n      const signatureView = new Uint8Array(signatureBytes.buffer, signatureBytes.byteOffset, signatureBytes.byteLength);\r\n      const inputView = new Uint8Array(verificationInputBuffer.buffer, verificationInputBuffer.byteOffset, verificationInputBuffer.byteLength);\r\n      \r\n      // Verify the signature - use type assertion to handle TypeScript compatibility issues\r\n      const isValid = await crypto.subtle.verify(\r\n        'HMAC',\r\n        key,\r\n        signatureView as BufferSource,\r\n        inputView as BufferSource\r\n      );\r\n\r\n      return isValid;\r\n    } catch (error) {\r\n      console.error('Signature verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n /**\r\n   * Decode a JWT token without verification (for edge runtime compatibility)\r\n   * This only extracts the payload without validating the signature\r\n   * Use carefully - only for non-sensitive operations like checking expiration\r\n   */\r\n  decodeToken(token: string): TokenPayload | null {\r\n    try {\r\n      if (!token || typeof token !== 'string' || token.trim() === '') {\r\n        return null;\r\n      }\r\n      \r\n      const tokenParts = token.split('.');\r\n      if (tokenParts.length !== 3) {\r\n        console.error('Token format is invalid');\r\n        return null;\r\n      }\r\n\r\n      const payload = tokenParts[1];\r\n      const decodedPayload = this.base64UrlDecode(payload);\r\n      if (!decodedPayload) {\r\n        return null;\r\n      }\r\n      \r\n      return JSON.parse(decodedPayload) as TokenPayload;\r\n    } catch (error: any) {\r\n      console.error('Token decoding failed:', error?.message || error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a token is expired without full verification\r\n   * This uses the decode method which doesn't require the secret\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      const decoded = this.decodeToken(token);\r\n      if (!decoded || !decoded.exp) {\r\n        return true; // If we can't decode or there's no expiration, consider it expired\r\n      }\r\n      // Compare expiration timestamp with current time (in seconds)\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      return decoded.exp < currentTime;\r\n    } catch (error) {\r\n      console.error('Error checking token expiration:', error);\r\n      return true; // If there's an error, assume token is expired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url encoded strings\r\n   */\r\n  private base64UrlDecode(str: string): string | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      return decodeURIComponent(escape(rawData));\r\n    } catch (error) {\r\n      console.error('Base64 URL decode error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function to decode base64url string to Uint8Array\r\n   */\r\n  private base64UrlDecodeToUint8Array(str: string): Uint8Array | null {\r\n    try {\r\n      // Add padding if needed\r\n      const padding = '='.repeat((4 - (str.length % 4)) % 4);\r\n      const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;\r\n      const rawData = atob(base64);\r\n      \r\n      const buffer = new Uint8Array(rawData.length);\r\n      for (let i = 0; i < rawData.length; i++) {\r\n        buffer[i] = rawData.charCodeAt(i);\r\n      }\r\n      \r\n      return buffer;\r\n    } catch (error) {\r\n      console.error('Base64 URL decode to Uint8Array error:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new JWTService();","import type { User as AppUser } from '../types';\r\nimport jwtService from './jwt-service';\r\n\r\ninterface LoginResult {\r\n  success: boolean;\r\n  user?: AppUser;\r\n  error?: string;\r\n}\r\n\r\n// Cache configuration\r\nconst SESSION_CACHE_KEY = 'lspu_kmis_session_cache';\r\nconst LAST_CHECK_KEY = 'lspu_kmis_last_auth_check';\r\nconst DEFAULT_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\nclass DatabaseAuthService {\r\n  private sessionValidationDebounce: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    // No external client initialization needed\r\n  }\r\n\r\n  /**\r\n   * Get cached session data if it exists and hasn't expired\r\n   */\r\n  getCachedSession(): any | null {\r\n    if (typeof window !== 'undefined') {\r\n      const cached = localStorage.getItem(SESSION_CACHE_KEY);\r\n      if (cached) {\r\n        try {\r\n          const { data, expiration } = JSON.parse(cached);\r\n          // Only use cache if not expired\r\n          if (Date.now() < expiration) {\r\n            return data;\r\n          } else {\r\n            // Clear expired cache\r\n            localStorage.removeItem(SESSION_CACHE_KEY);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error parsing cached session:', error);\r\n          localStorage.removeItem(SESSION_CACHE_KEY);\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Set cached session data with expiration\r\n   */\r\n  setCachedSession(sessionData: any, ttl: number = DEFAULT_CACHE_TTL) {\r\n    if (typeof window !== 'undefined') {\r\n      const expiration = Date.now() + ttl;\r\n      try {\r\n        localStorage.setItem(SESSION_CACHE_KEY, JSON.stringify({\r\n          data: sessionData,\r\n          expiration\r\n        }));\r\n      } catch (error) {\r\n        console.error('Error caching session:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear cached session\r\n   */\r\n  clearCachedSession() {\r\n    if (typeof window !== 'undefined') {\r\n      localStorage.removeItem(SESSION_CACHE_KEY);\r\n      localStorage.removeItem(LAST_CHECK_KEY);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the last auth check timestamp\r\n   */\r\n  getLastAuthCheck(): number | null {\r\n    if (typeof window !== 'undefined') {\r\n      const lastCheck = localStorage.getItem(LAST_CHECK_KEY);\r\n      return lastCheck ? parseInt(lastCheck) : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Set the last auth check timestamp\r\n   */\r\n  setLastAuthCheck(timestamp: number) {\r\n    if (typeof window !== 'undefined') {\r\n      localStorage.setItem(LAST_CHECK_KEY, timestamp.toString());\r\n    }\r\n }\r\n\r\n  /**\r\n   * Validate session without triggering loading state\r\n   */\r\n async validateSessionWithoutLoading(): Promise<boolean> {\r\n   if (this.sessionValidationDebounce) {\r\n     clearTimeout(this.sessionValidationDebounce);\r\n   }\r\n   \r\n   return new Promise((resolve) => {\r\n     this.sessionValidationDebounce = setTimeout(async () => {\r\n       try {\r\n         const token = this.getAccessTokenFromStorage();\r\n         if (!token) {\r\n           resolve(false);\r\n           return;\r\n         }\r\n\r\n         // Check if we're in the browser environment\r\n         if (typeof window !== 'undefined') {\r\n           // In browser, check if token is expired without full verification\r\n           const isExpired = jwtService.isTokenExpired(token);\r\n           if (isExpired) {\r\n             // Try to refresh the token\r\n             const refreshed = await this.refreshToken();\r\n             resolve(refreshed);\r\n           } else {\r\n             resolve(true);\r\n           }\r\n         } else {\r\n           // On server, verify the JWT token\r\n           jwtService.verifyToken(token).then(decoded => {\r\n             resolve(!!decoded);\r\n           }).catch(() => resolve(false));\r\n         }\r\n       } catch (error) {\r\n         console.error('Session validation error:', error);\r\n         resolve(false);\r\n       }\r\n     }, 500); // Only validate after 500ms of inactivity\r\n   });\r\n }\r\n\r\n  private getAccessTokenFromStorage(): string | null {\r\n    if (typeof window !== 'undefined') {\r\n      return localStorage.getItem('access_token');\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private setAccessTokenInStorage(token: string): void {\r\n    if (typeof window !== 'undefined') {\r\n      localStorage.setItem('access_token', token);\r\n    }\r\n  }\r\n\r\n  private removeAccessTokenFromStorage(): void {\r\n    if (typeof window !== 'undefined') {\r\n      localStorage.removeItem('access_token');\r\n    }\r\n  }\r\n\r\n  async login(email: string, password: string): Promise<LoginResult> {\r\n    try {\r\n      // Call the API route to perform login\r\n      const response = await fetch('/api/auth/login', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ email, password }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json().catch(() => ({}));\r\n        return { success: false, error: errorData.error || 'Login failed' };\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      if (data.success && data.token && data.user) {\r\n        // Store the access token in localStorage\r\n        this.setAccessTokenInStorage(data.token);\r\n        \r\n        // Generate a mock refresh token and store it\r\n        const refreshToken = this.generateMockRefreshToken();\r\n        localStorage.setItem('refresh_token', refreshToken);\r\n        \r\n        // Store refresh token in mock store\r\n        this.refreshTokensStore.set(refreshToken, {\r\n          userId: data.user.id,\r\n          email: data.user.email,\r\n          role: data.user.role\r\n        });\r\n\r\n        // Return user data\r\n        const userData: AppUser = {\r\n          id: data.user.id,\r\n          email: data.user.email,\r\n          name: data.user.name,\r\n          role: data.user.role as 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL',\r\n          unitId: data.user.unitId || undefined,\r\n        };\r\n\r\n        return {\r\n          success: true,\r\n          user: userData,\r\n        };\r\n      } else {\r\n        return { success: false, error: data.error || 'Login failed' };\r\n      }\r\n    } catch (error) {\r\n      console.error('Login error:', error);\r\n      return { success: false, error: 'An unexpected error occurred during login' };\r\n    }\r\n  }\r\n\r\n  async signup(email: string, password: string, name: string, role: 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL' = 'STUDENT', department?: string): Promise<LoginResult> {\r\n    try {\r\n      // Call the API route to perform signup\r\n      const response = await fetch('/api/auth/signup', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ email, password, name, role, department }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json().catch(() => ({}));\r\n        return { success: false, error: errorData.error || 'Signup failed' };\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      if (data.success && data.token && data.user) {\r\n        // Store the access token in localStorage\r\n        this.setAccessTokenInStorage(data.token);\r\n        \r\n        // Generate a mock refresh token and store it\r\n        const refreshToken = this.generateMockRefreshToken();\r\n        localStorage.setItem('refresh_token', refreshToken);\r\n        \r\n        // Store refresh token in mock store\r\n        this.refreshTokensStore.set(refreshToken, {\r\n          userId: data.user.id,\r\n          email: data.user.email,\r\n          role: data.user.role\r\n        });\r\n\r\n        // Return user data\r\n        const userData: AppUser = {\r\n          id: data.user.id,\r\n          email: data.user.email,\r\n          name: data.user.name,\r\n          role: data.user.role as 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL',\r\n          unitId: data.user.unitId || undefined,\r\n        };\r\n\r\n        return {\r\n          success: true,\r\n          user: userData,\r\n        };\r\n      } else {\r\n        return { success: false, error: data.error || 'Signup failed' };\r\n      }\r\n    } catch (error) {\r\n      console.error('Signup error:', error);\r\n      return { success: false, error: 'An unexpected error occurred during signup' };\r\n    }\r\n }\r\n\r\n  async logout(): Promise<void> {\r\n    try {\r\n      // Call the API route to perform logout (optional - mainly for server-side cleanup)\r\n      await fetch('/api/auth/logout', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${this.getAccessTokenFromStorage()}`\r\n        },\r\n      });\r\n\r\n      // Remove the tokens from localStorage\r\n      const refreshToken = localStorage.getItem('refresh_token');\r\n      this.removeAccessTokenFromStorage();\r\n      localStorage.removeItem('refresh_token');\r\n      \r\n      // Remove refresh token from mock store if it exists\r\n      if (refreshToken) {\r\n        this.refreshTokensStore.delete(refreshToken);\r\n      }\r\n    } catch (error) {\r\n      console.error('Logout error:', error);\r\n      // Still remove the tokens from localStorage even if API call fails\r\n      const refreshToken = localStorage.getItem('refresh_token');\r\n      this.removeAccessTokenFromStorage();\r\n      localStorage.removeItem('refresh_token');\r\n      \r\n      // Remove refresh token from mock store if it exists\r\n      if (refreshToken) {\r\n        this.refreshTokensStore.delete(refreshToken);\r\n      }\r\n    }\r\n  }\r\n\r\n  async getCurrentUser(): Promise<AppUser | null> {\r\n    try {\r\n      const token = this.getAccessTokenFromStorage();\r\n      if (!token) {\r\n        return null;\r\n      }\r\n\r\n      // Check if we're in the browser environment\r\n      if (typeof window !== 'undefined') {\r\n        // In browser, check if token is expired without full verification\r\n        const isExpired = jwtService.isTokenExpired(token);\r\n        if (isExpired) {\r\n          // Try to refresh the token\r\n          const refreshed = await this.refreshToken();\r\n          if (refreshed) {\r\n            // Get the new token after refresh\r\n            const refreshedToken = this.getAccessTokenFromStorage();\r\n            if (refreshedToken) {\r\n              // Fetch user data from the API route with the refreshed token\r\n              const response = await fetch('/api/auth/me', {\r\n                headers: {\r\n                  'Authorization': `Bearer ${refreshedToken}`,\r\n                  'Content-Type': 'application/json',\r\n                }\r\n              });\r\n              \r\n              if (!response.ok) {\r\n                return null;\r\n              }\r\n              \r\n              const data = await response.json();\r\n              if (data.user) {\r\n                return {\r\n                  id: data.user.id,\r\n                  email: data.user.email,\r\n                  name: data.user.name,\r\n                  role: data.user.role as 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL',\r\n                  unitId: data.user.unitId || undefined,\r\n                };\r\n              } else {\r\n                return null;\r\n              }\r\n            } else {\r\n              return null; // If no new token after refresh, return null\r\n            }\r\n          } else {\r\n            return null; // If refresh failed, return null\r\n          }\r\n        }\r\n      } else {\r\n        // On server, verify the JWT token\r\n        const decoded = await jwtService.verifyToken(token);\r\n        if (!decoded) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // Fetch user data from the API route\r\n      const response = await fetch('/api/auth/me', {\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'Content-Type': 'application/json',\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        // If the response is 401 (unauthorized), try to refresh the token\r\n        if (response.status === 401) {\r\n          const refreshed = await this.refreshToken();\r\n          if (refreshed) {\r\n            // If token was refreshed, try the request again\r\n            const newToken = this.getAccessTokenFromStorage();\r\n            if (newToken) {\r\n              const retryResponse = await fetch('/api/auth/me', {\r\n                headers: {\r\n                  'Authorization': `Bearer ${newToken}`,\r\n                  'Content-Type': 'application/json',\r\n                }\r\n              });\r\n              \r\n              if (!retryResponse.ok) {\r\n                return null;\r\n              }\r\n              \r\n              const retryData = await retryResponse.json();\r\n              if (retryData.user) {\r\n                return {\r\n                  id: retryData.user.id,\r\n                  email: retryData.user.email,\r\n                  name: retryData.user.name,\r\n                  role: retryData.user.role as 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL',\r\n                  unitId: retryData.user.unitId || undefined,\r\n                };\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      if (data.user) {\r\n        return {\r\n          id: data.user.id,\r\n          email: data.user.email,\r\n          name: data.user.name,\r\n          role: data.user.role as 'ADMIN' | 'FACULTY' | 'STUDENT' | 'EXTERNAL',\r\n          unitId: data.user.unitId || undefined,\r\n        };\r\n      } else {\r\n        return null;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in getCurrentUser:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getSession() {\r\n    const token = this.getAccessTokenFromStorage();\r\n    if (!token) {\r\n      return null;\r\n    }\r\n\r\n    // Check if we're in the browser environment\r\n    if (typeof window !== 'undefined') {\r\n      // In browser, decode token without verification\r\n      const decoded = jwtService.decodeToken(token);\r\n      if (!decoded) {\r\n        // If we can't decode the token, try to refresh it\r\n        const refreshed = await this.refreshToken();\r\n        if (refreshed) {\r\n          const newToken = this.getAccessTokenFromStorage();\r\n          if (newToken) {\r\n            const newDecoded = jwtService.decodeToken(newToken);\r\n            return newDecoded ? { access_token: newToken, expires_at: newDecoded.exp } : null;\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n      return decoded ? { access_token: token, expires_at: decoded.exp } : null;\r\n    } else {\r\n      // On server, verify the JWT token\r\n      const decoded = await jwtService.verifyToken(token);\r\n      if (!decoded) {\r\n        // If token verification fails, try to refresh it\r\n        const refreshed = await this.refreshToken();\r\n        if (refreshed) {\r\n          const newToken = this.getAccessTokenFromStorage();\r\n          if (newToken) {\r\n            const newDecoded = await jwtService.verifyToken(newToken);\r\n            return newDecoded ? { access_token: newToken, expires_at: newDecoded.exp } : null;\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n      return decoded ? { access_token: token, expires_at: decoded.exp } : null;\r\n    }\r\n  }\r\n\r\n  async getUser() {\r\n    return await this.getCurrentUser();\r\n  }\r\n\r\n  // Mock refresh token store - in a real implementation this would be a database\r\n  private refreshTokensStore: Map<string, { userId: string; email: string; role: string }> = new Map();\r\n\r\n  generateMockRefreshToken(): string {\r\n    // Generate a mock refresh token\r\n    return `mock_refresh_token_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\r\n  }\r\n\r\n  async refreshToken(): Promise<boolean> {\r\n    try {\r\n      // Get the refresh token from storage\r\n      const refreshToken = localStorage.getItem('refresh_token');\r\n      if (!refreshToken) {\r\n        return false;\r\n      }\r\n\r\n      // Call the refresh endpoint\r\n      const response = await fetch('/api/auth/refresh', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ refreshToken }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        // If refresh fails, clear all tokens\r\n        this.removeAccessTokenFromStorage();\r\n        localStorage.removeItem('refresh_token');\r\n        // Remove refresh token from mock store if it exists\r\n        this.refreshTokensStore.delete(refreshToken);\r\n        return false;\r\n      }\r\n\r\n      const data = await response.json();\r\n      if (data.token) {\r\n        // Store the new access token\r\n        this.setAccessTokenInStorage(data.token);\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error refreshing token:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async updatePassword(newPassword: string) {\r\n    try {\r\n      const token = await this.getAccessToken();\r\n      if (!token) {\r\n        return { error: 'User not authenticated' };\r\n      }\r\n\r\n      const response = await fetch('/api/auth/update-password', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${token}`\r\n        },\r\n        body: JSON.stringify({ newPassword }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        // If the response is 401 (unauthorized), try to refresh the token\r\n        if (response.status === 401) {\r\n          const refreshed = await this.refreshToken();\r\n          if (refreshed) {\r\n            // Get the new token after refresh\r\n            const newToken = await this.getAccessToken();\r\n            if (newToken) {\r\n              // Try the request again with the new token\r\n              const retryResponse = await fetch('/api/auth/update-password', {\r\n                method: 'POST',\r\n                headers: {\r\n                  'Content-Type': 'application/json',\r\n                  'Authorization': `Bearer ${newToken}`\r\n                },\r\n                body: JSON.stringify({ newPassword }),\r\n              });\r\n\r\n              if (!retryResponse.ok) {\r\n                const errorData = await retryResponse.json().catch(() => ({}));\r\n                return { error: errorData.error || 'Failed to update password' };\r\n              }\r\n\r\n              return { error: null };\r\n            }\r\n          }\r\n        }\r\n        const errorData = await response.json().catch(() => ({}));\r\n        return { error: errorData.error || 'Failed to update password' };\r\n      }\r\n\r\n      return { error: null };\r\n    } catch (error) {\r\n      console.error('Error updating password:', error);\r\n      return { error: 'Failed to update password' };\r\n    }\r\n  }\r\n\r\n  async resetPassword(email: string) {\r\n    try {\r\n      const response = await fetch('/api/auth/reset-password', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ email }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json().catch(() => ({}));\r\n        return { error: errorData.error || 'Failed to reset password' };\r\n      }\r\n\r\n      return { error: null };\r\n    } catch (error) {\r\n      console.error('Error resetting password:', error);\r\n      return { error: 'Failed to reset password' };\r\n    }\r\n  }\r\n\r\n  async isAuthenticated(): Promise<boolean> {\r\n    try {\r\n      const token = this.getAccessTokenFromStorage();\r\n      if (!token) {\r\n        return false;\r\n      }\r\n\r\n      // Check if we're in the browser environment\r\n      if (typeof window !== 'undefined') {\r\n        // In browser, check if token is expired without full verification\r\n        const isExpired = jwtService.isTokenExpired(token);\r\n        if (isExpired) {\r\n          // Try to refresh the token\r\n          const refreshed = await this.refreshToken();\r\n          return refreshed;\r\n        }\r\n        return true;\r\n      } else {\r\n        // On server, verify the JWT token\r\n        const decoded = await jwtService.verifyToken(token);\r\n        return !!decoded;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in isAuthenticated:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getAccessToken(): Promise<string | null> {\r\n    try {\r\n      const token = this.getAccessTokenFromStorage();\r\n      if (!token) {\r\n        return null;\r\n      }\r\n\r\n      // Check if we're in the browser environment\r\n      if (typeof window !== 'undefined') {\r\n        // In browser, check if token is expired without full verification\r\n        const isExpired = jwtService.isTokenExpired(token);\r\n        if (isExpired) {\r\n          // Try to refresh the token\r\n          const refreshed = await this.refreshToken();\r\n          if (refreshed) {\r\n            // Get the new token after refresh\r\n            const newToken = this.getAccessTokenFromStorage();\r\n            return newToken;\r\n          } else {\r\n            return null; // If refresh failed, return null\r\n          }\r\n        }\r\n        return token;\r\n      } else {\r\n        // On server, verify the JWT token\r\n        const decoded = await jwtService.verifyToken(token);\r\n        return decoded ? token : null;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting access token:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch comprehensive user data in a single call to optimize performance\r\n   * This method uses the new /api/auth/me endpoint to get all user information at once\r\n   */\r\n  async getComprehensiveUserData(): Promise<any> {\r\n    try {\r\n      // Check if we have cached session data and it's still valid\r\n      const cachedSession = this.getCachedSession();\r\n      if (cachedSession) {\r\n        return cachedSession;\r\n      }\r\n\r\n      const token = await this.getAccessToken();\r\n      \r\n      if (!token) {\r\n        // If no token is available, check if user is authenticated before throwing error\r\n        const isAuthenticated = await this.isAuthenticated();\r\n        if (!isAuthenticated) {\r\n          // User is not authenticated, return null to indicate this\r\n          return { authenticated: false, user: null };\r\n        } else {\r\n          // User is authenticated but we can't get a token, return not authenticated\r\n          return { authenticated: false, user: null };\r\n        }\r\n      }\r\n      \r\n      const response = await fetch('/api/auth/me', {\r\n        headers: {\r\n          'Authorization': `Bearer ${token}`,\r\n          'Content-Type': 'application/json',\r\n        }\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        // If the error is authentication-related, try to refresh the token\r\n        if (response.status === 401 || response.status === 404) {\r\n          // Try to refresh the token\r\n          const refreshed = await this.refreshToken();\r\n          if (refreshed) {\r\n            // Get the new token after refresh\r\n            const refreshedToken = await this.getAccessToken();\r\n            if (refreshedToken) {\r\n              // Try the request again with the refreshed token\r\n              const retryResponse = await fetch('/api/auth/me', {\r\n                headers: {\r\n                  'Authorization': `Bearer ${refreshedToken}`,\r\n                  'Content-Type': 'application/json',\r\n                }\r\n              });\r\n              \r\n              if (!retryResponse.ok) {\r\n                // Clear cache on authentication failure\r\n                this.clearCachedSession();\r\n                return { authenticated: false, user: null };\r\n              }\r\n              \r\n              const retryData = await retryResponse.json();\r\n              // Cache the comprehensive user data\r\n              this.setCachedSession(retryData);\r\n              return retryData;\r\n            }\r\n          }\r\n          // Clear cache on authentication failure\r\n          this.clearCachedSession();\r\n          return { authenticated: false, user: null };\r\n        }\r\n        const errorData = await response.json().catch(() => ({}));\r\n        throw new Error(errorData.error || `Failed to fetch user data: ${response.status} ${response.statusText}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      \r\n      // Cache the comprehensive user data\r\n      this.setCachedSession(data);\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching comprehensive user data:', error);\r\n      // Check if this is an authentication error\r\n      if (error instanceof Error && error.message.includes('No authentication token available')) {\r\n        // Clear cache on authentication failure\r\n        this.clearCachedSession();\r\n        return { authenticated: false, user: null };\r\n      }\r\n      // For any other error, return not authenticated to prevent the error from propagating\r\n      this.clearCachedSession();\r\n      return { authenticated: false, user: null };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear cached session data\r\n   */\r\n  clearCache() {\r\n    this.clearCachedSession();\r\n  }\r\n}\r\n\r\nexport default new DatabaseAuthService();","\"use client\"\n\nimport { createContext, useContext, useState, useEffect, type ReactNode } from \"react\"\nimport type { User } from \"./types\"\nimport AuthService from \"./services/auth-service\"\n\ninterface AuthResult {\n  success: boolean\n  user?: User\n  error?: string\n}\n\ninterface AuthContextType {\n  user: User | null\n  login: (email: string, password: string) => Promise<AuthResult>\n  logout: () => Promise<void>\n isAuthenticated: boolean\n isLoading: boolean\n error: string | null\n}\n\n// Create a default context value to prevent hydration errors\nconst defaultContextValue: AuthContextType = {\n user: null,\n  login: async () => ({ success: false, error: 'Auth service not initialized' }),\n  logout: async () => {},\n  isAuthenticated: false,\n  isLoading: true,\n  error: null,\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  // Initialize with default values that match between server and client\n  const [user, setUser] = useState<User | null>(null)\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false)\n  const [isLoading, setIsLoading] = useState<boolean>(true) // Start as true initially\n const [error, setError] = useState<string | null>(null)\n  \n  // Initialize AuthService after component mounts to ensure window is available\n  const [authService] = useState(AuthService);\n\n  useEffect(() => {\n    let isMounted = true; // Track if component is still mounted\n    \n    // Immediately check session on mount to get initial state quickly\n    const checkInitialSession = async () => {\n      try {\n        // Use the new comprehensive endpoint if available, otherwise fall back to existing method\n        try {\n          const comprehensiveData = await authService.getComprehensiveUserData();\n          if (comprehensiveData && comprehensiveData.authenticated) {\n            // Set basic auth state immediately to prevent loading\n            if (isMounted) {\n              setIsAuthenticated(true);\n              setUser(comprehensiveData.user);\n              setIsLoading(false);\n            }\n          } else {\n            if (isMounted) {\n              setUser(null);\n              setIsAuthenticated(false);\n              setIsLoading(false);\n            }\n          }\n        } catch (comprehensiveError) {\n          console.warn('Comprehensive user data fetch failed, falling back to standard method:', comprehensiveError);\n          // Fallback to the original method\n          try {\n            // Use the database authentication method\n            const currentUser = await authService.getCurrentUser();\n            if (currentUser) {\n              // Set basic auth state immediately to prevent loading\n              if (isMounted) {\n                setIsAuthenticated(true);\n                setIsLoading(true); // Set loading to true while we fetch user details\n              }\n              \n              // Fetch user profile in background\n              if (isMounted) {\n                setUser(currentUser);\n                setIsLoading(false);\n              }\n            } else {\n              if (isMounted) {\n                setUser(null);\n                setIsAuthenticated(false);\n                setIsLoading(false);\n              }\n            }\n          } catch (sessionError) {\n            console.error('Session check error during initial load:', sessionError);\n            if (isMounted) {\n              setUser(null);\n              setIsAuthenticated(false);\n              setIsLoading(false);\n            }\n          }\n        }\n      } catch (err) {\n        console.error('Initial session check error:', err);\n        if (isMounted) {\n          setUser(null);\n          setIsAuthenticated(false);\n          setIsLoading(false);\n        }\n      }\n    };\n\n    // Add page visibility change handler to prevent loading state on tab focus\n    const handleVisibilityChange = async () => {\n      if (document.visibilityState === 'visible') {\n        // Only validate if it's been more than 10 minutes since last check\n        const lastChecked = authService.getLastAuthCheck();\n        const now = Date.now();\n        \n        // Only re-validate if more than 10 minutes have passed\n        if (!lastChecked || (now - lastChecked) > 10 * 60 * 1000) {\n          // Perform lightweight session validation without showing loading\n          const isValid = await authService.validateSessionWithoutLoading();\n          if (!isValid) {\n            // Session is no longer valid, clear user state\n            if (isMounted) {\n              setUser(null);\n              setIsAuthenticated(false);\n            }\n          }\n          // Update last check timestamp\n          authService.setLastAuthCheck(now);\n        }\n      }\n    };\n\n    // Run initial session check\n    if (typeof window !== 'undefined') {\n      // Add a small delay to ensure React hydration is complete\n      const timer = setTimeout(() => {\n        if (isMounted) {\n          checkInitialSession();\n        }\n      }, 0);\n      \n      // Add visibility change listener\n      document.addEventListener('visibilitychange', handleVisibilityChange);\n      \n      return () => {\n        clearTimeout(timer);\n        isMounted = false;\n        \n        // Remove visibility change listener\n        if (typeof window !== 'undefined') {\n          document.removeEventListener('visibilitychange', handleVisibilityChange);\n        }\n      };\n    } else {\n      // For server-side rendering, set initial state and return\n      setIsLoading(false);\n      return () => {\n        isMounted = false;\n      };\n    }\n}, []); // Empty dependency array since we only want to run this once on mount\n\n  const login = async (email: string, password: string): Promise<AuthResult> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const result = await authService.login(email, password);\n      \n      if (result.success && result.user) {\n        // Set user and authentication state immediately to allow faster redirects\n        setUser(result.user);\n        setIsAuthenticated(true);\n        setIsLoading(false); // Set loading to false after successful login\n        return result;\n      } else {\n        setError(result.error || 'Login failed');\n        setIsLoading(false); // Explicitly set loading to false on error\n        return result;\n      }\n    } catch (err) {\n      console.error('Login error:', err);\n      setError('An error occurred during login');\n      setIsLoading(false); // Explicitly set loading to false on error\n      return { success: false, error: 'An error occurred during login' };\n    }\n  };\n\n  const logout = async (): Promise<void> => {\n    setIsLoading(true);\n    try {\n      await authService.logout();\n      // Clear user state immediately to allow faster UI updates\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsLoading(false);\n    } catch (err) {\n      console.error('Logout error:', err);\n      // Still clear local state even if API call fails\n      setUser(null);\n      setIsAuthenticated(false);\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        login,\n        logout,\n        isAuthenticated,\n        isLoading,\n        error,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    // During server-side rendering, return the default context value\n    // This prevents the error while maintaining type safety\n    if (typeof window === 'undefined') {\n      return defaultContextValue;\n    } else {\n      throw new Error(\"useAuth must be used within an AuthProvider\")\n    }\n  }\n  return context\n}\n"],"names":[],"mappings":"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"}